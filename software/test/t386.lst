Sections:
00: ".pgtbl" (0-A)
01: ".bss" (0-A)
02: ".data" (0-A)
03: ".rodata" (0-6)
04: ".text" (0-24CA)


Source: "t386.asm"
                      	     1: # t386.asm rf386 cpu test
                      	     2: # Port to vasm standard syntax including mods.
                      	     3: # (c) 2024 Robert Finch <robfinch@finitron.ca>
                      	     4: #
                      	     5: # Original work from test386.asm
                      	     6: #   Copyright (C) 2012-2015 Jeff Parsons <Jeff@pcjs.org>
                      	     7: #   Copyright (C) 2017-2021 Marco Bortolin <barotto@gmail.com>
                      	     8: #
                      	     9: #   This file is a derivative work of PCjs
                      	    10: #   https://www.pcjs.org/software/pcx86/test/cpu/80386/test386.asm
                      	    11: #
                      	    12: #   test386.asm is free software: you can redistribute it and/or modify it under
                      	    13: #   the terms of the GNU General Public License as published by the Free
                      	    14: #   Software Foundation, either version 3 of the License, or (at your option)
                      	    15: #   any later version.
                      	    16: #
                      	    17: #   test386.asm is distributed in the hope that it will be useful, but WITHOUT ANY
                      	    18: #   WARRANTY without even the implied warranty of MERCHANTABILITY or FITNESS
                      	    19: #   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
                      	    20: #   details.
                      	    21: #
                      	    22: #   You should have received a copy of the GNU General Public License along with
                      	    23: #   test386.asm.  If not see <http://www.gnu.org/licenses/gpl.html>.
                      	    24: #
                      	    25: #   This program was originally developed for IBMulator
                      	    26: #   https://barotto.github.io/IBMulator
                      	    27: #
                      	    28: #   Overview
                      	    29: #   --------
                      	    30: #   This file is designed to run as a test ROM, loaded in place of the BIOS.
                      	    31: #   Its pourpose is to test the CPU, reporting its status to the POST port and
                      	    32: #   its computational results in ASCII form to various configurable ports.
                      	    33: #   A 80386 or later CPU is required. This ROM is designed to test an emulator
                      	    34: #   CPU and was never tested on real hardware.
                      	    35: #
                      	    36: #   It must be installed at physical address 0xffff0000 and aliased at physical
                      	    37: #   address 0xffff0000.  The jump at resetVector should align with the CPU reset
                      	    38: #   address 0xfffffff0, which will transfer control to f000:0045.  From that
                      	    39: #   point on, all memory accesses should remain within the first 1MB.
                      	    40: #
                      	    41: 
                      	    42: #
                      	    43: # WARNING
                      	    44: #
                      	    45: #   A word of caution before you start developing.
                      	    46: #   NASM (2.11.08) generates [ebp + ebp] for [ebp*2] (i.e. no base register),
                      	    47: #   which are not the same thing: [ebp+ebp] references the SS segment, [ebp*2]
                      	    48: #   references the DS segment.
                      	    49: #   NASM developers think [ebp*2] and [ebp+ebp] are the same, but that is true
                      	    50: #   only assuming a flat memory model. Until the time NASM authors realize their
                      	    51: #   mistake (any assumption of a flat memory model should be optional), you can
                      	    52: #   disable this behaviour by writing: [nosplit ebp*2].
                      	    53: #
                      	    54: #	NASM Assembly            Translated               Assembled
                      	    55: #	mov eax,[ebp*2]          mov eax,[ebp+ebp*1+0x0]  8B442D00
                      	    56: #	mov eax,[nosplit ebp*2]  mov eax,[ebp*2+0x0]      8B046D00000000
                      	    57: #
                      	    58: 
                      	    59: .macro cpyright
                      	    60: 	.ascii "t386.asm (c) 2024 Robert Finch (C) 2012-2015 Jeff Parsons, (C) 2017-2021 Marco Bortolin ",0
                      	    61: .endm
                      	    62: .macro RELEASE
                      	    63: 	.ascii "??/??/24",0
                      	    64: .endm
                      	    65: 
                      	    66: 	.set POST_PORT,0x190
                      	    67: 
                      	    68: #
                      	    69: # memory map:
                      	    70: #  FFF80000-FFF8FFFF page table
                      	    71: #  FFF90000-FFF903FF real mode IDT
                      	    72: #  FFF90400-FFF904FF protected mode IDT
                      	    73: #  FFF90500-FFF9077F protected mode GDT
                      	    74: #  FFF90800-FFF90FFF protected mode LDT
                      	    75: #  FFFA0000-FFFAFFFF read only data
                      	    76: #  FFFC0000-FFFCFFFF stack
                      	    77: #  FFF01000-FFF01FFF page directory
                      	    78: #  FFF94000-FFF95FFF TSS
                      	    79: #  20000-9FFFF tests
                      	    80: #
                      	    81: 
                      	    82: .set realmd_mask,0x0000ffff
                      	    83: .set rodata_seg,0x0fffa000
                      	    84: .set start_rodata,0xfffa0000
                      	    85: .set TEST_BASE,0xFFFC0000
                      	    86: .set TEST_CODE,0xFFFF0000
                      	    87: .set TEST_BASE1,TEST_BASE+0x0000
                      	    88: .set TEST_BASE2,TEST_BASE+0x2000
                      	    89: 
                      	    90: 	.section .pgtbl
00:00000000 00        	    91: 	.space 10
00:00000001 *
                      	    92: 
                      	    93: 	.bss
01:00000000 00        	    94: 	.space	10
01:00000001 *
                      	    95: 
                      	    96: 	.data
02:00000000 00        	    97: 	.space	10
02:00000001 *
                      	    98: 
                      	    99: 	.rodata
                      	   100: idt_addr:
03:00000000 0004      	   101: 	.2byte 0x400
03:00000002 0000F9FF  	   102: 	.4byte 0xFFF90000		# Linear address of table
                      	   103: 
                      	   104: #	.org	0xF0000
                      	   105: 	.text
                      	   106: 	.code16
                      	   107: #	.align	0
                      	   108: .extern	_bootrom
                      	   109: .extern _Fibonacci
                      	   110: 
                      	   111: #
                      	   112: #   Real mode segments
                      	   113: #
                      	   114: .set C_SEG_REAL,0xF000
                      	   115: .set S_SEG_REAL,0xC000
                      	   116: .set IDT_SEG_REAL,0x9000
                      	   117: .set IDT_SEG_PROT,0x9040
                      	   118: .set GDT_SEG_REAL,0x9050
                      	   119: .set GDT_SEG_LIMIT,0x2FF
                      	   120: .set D1_SEG_REAL,TEST_BASE1 >> 4
                      	   121: .set D2_SEG_REAL,TEST_BASE2 >> 4
                      	   122: 
                      	   123: .set ESP_REAL,0x7ffc
                      	   124: 
                      	   125: 
                      	   126: .include "x86_e.asm"

Source: "x86_e.asm"
                      	     1: .set PS_CF,0x0001
                      	     2: .set PS_PF,0x0004
                      	     3: .set PS_AF,0x0010
                      	     4: .set PS_ZF,0x0040
                      	     5: .set PS_SF,0x0080
                      	     6: .set PS_TF,0x0100
                      	     7: .set PS_IF,0x0200
                      	     8: .set PS_DF,0x0400
                      	     9: .set PS_OF,0x0800
                      	    10: .set PS_ARITH,(PS_CF | PS_PF | PS_AF | PS_ZF | PS_SF | PS_OF)
                      	    11: .set PS_LOGIC,(PS_CF | PS_PF | PS_ZF | PS_SF | PS_OF)
                      	    12: .set PS_MULTIPLY,(PS_CF | PS_OF) # only CF and OF are "defined" following MUL or IMUL
                      	    13: .set PS_DIVIDE,0 # none of the Processor Status flags are "defined" following DIV or IDIV
                      	    14: .set PS_SHIFTS_1,(PS_CF | PS_SF | PS_ZF | PS_PF | PS_OF)
                      	    15: .set PS_SHIFTS_R,(PS_CF | PS_SF | PS_ZF | PS_PF)
                      	    16: 
                      	    17: .set CR0_MSW_PE,0x0001
                      	    18: .set CR0_PG,0x80000000	# set if paging enabled
                      	    19: 
                      	    20: .set ACC_TYPE_GATE386_INT,0x0E00
                      	    21: .set ACC_TYPE_GATE386_CALL,0x0C00
                      	    22: .set ACC_TYPE_SEG,0x1000
                      	    23: .set ACC_PRESENT,0x8000
                      	    24: .set ACC_TYPE_CODE_R,0x1a00
                      	    25: .set ACC_TYPE_CONFORMING,0x0400
                      	    26: .set ACC_TYPE_DATA_R,0x1000
                      	    27: .set ACC_TYPE_DATA_W,0x1200
                      	    28: .set ACC_TYPE_LDT,0x0200
                      	    29: .set ACC_TYPE_TSS,0x0900
                      	    30: 
                      	    31: .set ACC_DPL_0,0x0000
                      	    32: .set ACC_DPL_1,0x2000
                      	    33: .set ACC_DPL_2,0x4000
                      	    34: .set ACC_DPL_3,0x6000
                      	    35: 
                      	    36: .set EXT_NONE,0x0000
                      	    37: .set EXT_16BIT,EXT_NONE
                      	    38: .set EXT_32BIT,0x0040 # size bit
                      	    39: .set EXT_PAGE,0x0080 # granularity bit
                      	    40: 
                      	    41: # i386 paging
                      	    42: #PTE_FRAME,0xffffe000
                      	    43: #PTE_DIRTY,0x00000040 		# page has been modified
                      	    44: #PTE_ACCESSED  equ 0x00000020 ; page has been accessed
                      	    45: #PTE_USER      equ 0x00000004 ; set for user level (CPL 3), clear for supervisor level (CPL 0-2)
                      	    46: #PTE_WRITE     equ 0x00000002 ; set for read/write, clear for read-only (affects CPL 3 only)
                      	    47: #PTE_PRESENT   equ 0x00000001 ; set for present page, clear for not-present page
                      	    48: 
                      	    49: # Bigfoot paging
                      	    50: .set PTE_FRAME,0xffffe000
                      	    51: .set PTE_DIRTY,0x00000080 		# page has been modified
                      	    52: .set PTE_ACCESSED,0x00000040 	# page has been accessed
                      	    53: .set PTE_USER,0x00000010 			# set for user level (CPL 3), clear for supervisor level (CPL 0-2)
                      	    54: .set PTE_WRITE,0x00000004 		# set for read/write, clear for read-only (affects CPL 3 only)
                      	    55: .set PTE_PRESENT,0x00000001 	# set for present page, clear for not-present page
                      	    56: 
                      	    57: #PTE_PRESENT_BIT   equ 0000001b
                      	    58: #PTE_WRITE_BIT     equ 0000010b
                      	    59: #PTE_USER_BIT      equ 0000100b
                      	    60: #PTE_ACCESSED_BIT  equ 0100000b
                      	    61: #PTE_DIRTY_BIT     equ 1000000b
                      	    62: 
                      	    63: .set EX_DE,0
                      	    64: .set EX_DB,1
                      	    65: .set EX_BP,3
                      	    66: .set EX_OF,4
                      	    67: .set EX_BR,5
                      	    68: .set EX_UD,6
                      	    69: .set EX_NM,7
                      	    70: .set EX_DF,8
                      	    71: .set EX_MP,9
                      	    72: .set EX_TS,10
                      	    73: .set EX_NP,11
                      	    74: .set EX_SS,12
                      	    75: .set EX_GP,13
                      	    76: .set EX_PF,14
                      	    77: .set EX_MF,15
                      	    78: 

Source: "t386.asm"
                      	   127: .include "macros_m.asm"

Source: "macros_m.asm"
                      	     1: #
                      	     2: #   Output a byte to the POST port, destroys al and dx
                      	     3: #
                      	     4: .macro POST arg1
                      	     5: 	movb \arg1,%al
                      	     6: 	movw $POST_PORT,%dx
                      	     7: 	out %al,%dx
                      	     8: .endm
                      	     9: 
                      	    10: #
                      	    11: # Initializes an interrupt gate in system memory.
                      	    12: # This is the body of procedures used in 16 and 32-bit code segments.
                      	    13: #
                      	    14: #    7                             0 7                             0
                      	    15: #   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â
                      	    16: # +7â•‘                          OFFSET 31-16                         â•‘+6
                      	    17: #   â•Ÿâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â
                      	    18: # +5â•‘ P â”‚  DPL  â”‚ 0 â”‚ 1   1   1   0 â”‚            UNUSED             â•‘+4
                      	    19: #   â•Ÿâ”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â
                      	    20: # +3â•‘                           SELECTOR                            â•‘+2
                      	    21: #   â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â
                      	    22: # +1â•‘                          OFFSET 15-0                          â•‘ 0
                      	    23: #   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â
                      	    24: #    15                                                            0
                      	    25: #
                      	    26: # DS:EBX pointer to IDT
                      	    27: # EAX vector
                      	    28: # ESI selector
                      	    29: # EDI offset
                      	    30: # DX DPL (use ACC_DPL_* equs)
                      	    31: #
                      	    32: .macro initIntGate
                      	    33: 	shl $3,%eax
                      	    34: 	add	%eax,%ebx
                      	    35: 	movw %di,(%ebx)
                      	    36: 	movw %si,2(%ebx)
                      	    37: 	orw $ACC_TYPE_GATE386_INT | ACC_PRESENT, %dx
                      	    38: 	movw %dx,4(%ebx)
                      	    39: 	shr $16,%edi
                      	    40: 	movw %di,6(%ebx)
                      	    41: .endm
                      	    42: 
                      	    43: #
                      	    44: # Set a descriptor in system memory.
                      	    45: # This is the body of procedures used in 16 and 32-bit code segments.
                      	    46: #
                      	    47: #    7                             0 7                             0
                      	    48: #   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•¤â•â
                      	    49: # +7â•‘            BASE 31-24         â”‚ G â”‚B/Dâ”‚ 0 â”‚AVLâ”‚  LIMIT 19-16  â•‘+6
                      	    50: #   â•Ÿâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¼â”€â”€â”€â”´â”€â
                      	    51: # +5â•‘ P â”‚  DPL  â”‚ S â”‚    TYPE    (A)â”‚          BASE 23-16           â•‘+4
                      	    52: #   â•Ÿâ”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â
                      	    53: # +3â•‘                           BASE 15-0                           â•‘+2
                      	    54: #   â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â
                      	    55: # +1â•‘                           LIMIT 15-0                          â•‘ 0
                      	    56: #   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â
                      	    57: #    15                                                            0
                      	    58: #
                      	    59: # DS:EBX pointer to the descriptor table
                      	    60: # EAX segment selector
                      	    61: # ESI base
                      	    62: # EDI limit
                      	    63: # DL ext nibble (upper 4 bits)
                      	    64: # DH acc byte (P|DPL|S|TYPE|A)
                      	    65: #
                      	    66: .macro initDescriptor
                      	    67: 	and $0xFFF8,%eax
                      	    68: 	add %eax,%ebx
                      	    69: 	movw %di,(%ebx)						# LIMIT 15-0
                      	    70: 	movw %si,2(%ebx)					# BASE 15-0
                      	    71: 	shr $16,%esi
                      	    72: 	mov %si,%ax								# AX := BASE 31-16
                      	    73: 	movb %al,4(%ebx)					# BASE 23-16
                      	    74: 	movb %dh,5(%ebx)					# acc byte
                      	    75: 	shr $16,%edi
                      	    76: 	mov %di,%cx
                      	    77: 	and $0x0f,%cl
                      	    78: 	movb %cl,6(%ebx)					# LIMIT 19-16
                      	    79: 	and $0xf0,%dl
                      	    80: 	orb %dl,6(%ebx)						# ext nybble
                      	    81: 	movb %ah,7(%ebx)					# BASE 31-24
                      	    82: .endm
                      	    83: 
                      	    84: 
                      	    85: .macro advTestBase
                      	    86: 	.set TEST_BASE1,TEST_BASE1+0x1000
                      	    87: 	.set TEST_BASE2,TEST_BASE2+0x1000
                      	    88: .endm
                      	    89: 

Source: "t386.asm"
                      	   128: .include "shift_m.asm"

Source: "shift_m.asm"
                      	     1: #
                      	     2: #   Executes a byte shift operation and checks the resulting flags.
                      	     3: #
                      	     4: #   %1 operation
                      	     5: #   %2 al: byte operand
                      	     6: #   %3 cl: shift count
                      	     7: #   %4 flags: value of flags before %1 execution
                      	     8: #   %5 flags: expected value of flags after %1 execution (cmp with PS_ARITH mask)
                      	     9: #
                      	    10: #   Uses: AX, CL, Flags
                      	    11: #
                      	    12: 
                      	    13: .macro testShiftBFlags arg1,arg2,arg3,arg4,arg5
                      	    14: 	mov \arg4,%ax
                      	    15: 	push %ax
                      	    16: 	popf
                      	    17: 	mov $0xff,%ah
                      	    18: 	mov \arg2,%al
                      	    19: 	mov \arg3,%cl
                      	    20: 	\arg1 %cl,%al
                      	    21: 	pushf
                      	    22: 	pop %ax
                      	    23: 	and $PS_ARITH,%ax
                      	    24: 	cmp \arg5,%ax
                      	    25: 	jne error
                      	    26: .endm
                      	    27: 
                      	    28: #
                      	    29: #   Executes a word shift operation and checks the resulting flags.
                      	    30: #
                      	    31: #   %1 operation
                      	    32: #   %2 ax: word operand
                      	    33: #   %3 cl: shift count
                      	    34: #   %4 flags: value of flags before %1 execution
                      	    35: #   %5 flags: expected value of flags after %1 execution (cmp with PS_ARITH mask)
                      	    36: #
                      	    37: #   Uses: AX, CL, Flags
                      	    38: #
                      	    39: .macro testShiftWFlags arg1,arg2,arg3,arg4,arg5
                      	    40: 	mov \arg4,%ax
                      	    41: 	push %ax
                      	    42: 	popf
                      	    43: 	mov \arg2,%ax
                      	    44: 	mov \arg3,%cl
                      	    45: 	\arg1 %cl,%ax
                      	    46: 	pushf
                      	    47: 	pop %ax
                      	    48: 	and $PS_ARITH,%ax
                      	    49: 	cmp \arg5,%ax
                      	    50: 	jne error
                      	    51: .endm
                      	    52: 

Source: "t386.asm"
                      	   129: 
                      	   130: _start:
04:00000000 EB59      	   131: 	jmp _start1
                      	   132: header:
                      	   133: 	cpyright
04:00000002 743338362E	     1M 	.ascii "t386.asm (c) 2024 Robert Finch (C) 2012-2015 Jeff Parsons, (C) 2017-2021 Marco Bortolin ",0
04:00000007 61736D2028
04:0000000C 6329203230
04:00000011 323420526F
04:00000016 6265727420
04:0000001B 46696E6368
04:00000020 2028432920
04:00000025 323031322D
04:0000002A 3230313520
04:0000002F 4A65666620
04:00000034 506172736F
04:00000039 6E732C2028
04:0000003E 4329203230
04:00000043 31372D3230
04:00000048 3231204D61
04:0000004D 72636F2042
04:00000052 6F72746F6C
04:00000057 696E20
04:0000005A 00
                      	   134: 
                      	   135: _start1:
04:0000005B FA        	   136: 	cli	
                      	   137: # init IDT
                      	   138: #	mov $17,%cx
                      	   139: #	movl $error,%edx
                      	   140: #	movl $0xfff90000,%eax
                      	   141: #	movl $error,%edx
                      	   142: #.aloop:
                      	   143: #	movw %dx,(%eax)
                      	   144: #	movw $0xf000,2(%eax)
                      	   145: ##	movw $error,(,%eax,4)
                      	   146: ##	movw $0xf000,2(,%eax,4)
                      	   147: #	addl $4,%eax
                      	   148: #	loop .aloop
                      	   149: 
                      	   150: #	mov $ESP_REAL,%esp
                      	   151: 
                      	   152: # ==============================================================================
                      	   153: #	Real mode tests
                      	   154: # ==============================================================================
                      	   155: 
                      	   156: .include "real_m.asm"

Source: "real_m.asm"
                      	     1: #
                      	     2: # Advances the base address of data segments used by tests, D1_SEG_REAL and
                      	     3: # D2_SEG_REAL.
                      	     4: #
                      	     5: # Loads DS with D1_SEG_REAL and ES with D2_SEG_REAL.
                      	     6: #
                      	     7: .macro advTestSegReal
                      	     8: 	advTestBase
                      	     9: 	.set D1_SEG_REAL,TEST_BASE1 >> 4
                      	    10: 	.set D2_SEG_REAL,TEST_BASE2 >> 4
                      	    11: 	mov $D1_SEG_REAL,%dx
                      	    12: 	mov %dx,%ds
                      	    13: 	mov $D2_SEG_REAL,%dx
                      	    14: 	mov %dx,%es
                      	    15: .endm
                      	    16: 
                      	    17: #
                      	    18: # Initializes the real mode IDT with C_SEG_REAL:error
                      	    19: # This code is called in real mode.
                      	    20: #
                      	    21: .macro initRealModeIDT
                      	    22: 	mov $IDT_SEG_REAL,%ax
                      	    23: 	mov %ax,%ds
                      	    24: 	xor %di,%di
                      	    25: 	mov $17,%cx
                      	    26: aloop\@:
                      	    27: 	movw $error,(%di)
                      	    28: 	movw $C_SEG_REAL,2(%di)
                      	    29: 	add $4,%di
                      	    30: 	loop aloop\@
                      	    31: .endm
                      	    32: 
                      	    33: 
                      	    34: #
                      	    35: # Exception handling testing in real mode
                      	    36: #
                      	    37: 
                      	    38: # Initialises an exc handler
                      	    39: # %1: vector
                      	    40: # %2: handler IP
                      	    41: # Trashes AX,DS
                      	    42: 
                      	    43: .macro realModeExcInit arg1,arg2
                      	    44: 	mov $IDT_SEG_REAL,%ax
                      	    45: 	mov %ax,%ds
                      	    46: 	movw $\arg2,\arg1*4
                      	    47: 	movw $C_SEG_REAL,\arg1*4+2
                      	    48: .endm
                      	    49: 
                      	    50: # Checks exc result and restores the default handler
                      	    51: # %1: vector
                      	    52: # %2: expected pushed value of IP
                      	    53: # Trashes AX,DS
                      	    54: 
                      	    55: .macro realModeExcCheck arg1,arg2
                      	    56: 	cmp $ESP_REAL-6,%sp
                      	    57: 	jne error
                      	    58: 	cmpw $C_SEG_REAL,%ss:ESP_REAL-4
                      	    59: 	jne error
                      	    60: 	cmpw $\arg2,%ss:ESP_REAL-6
                      	    61: 	jne error
                      	    62: 	mov $0,%ax
                      	    63: 	mov %ax,%ds
                      	    64: 	movw $error,\arg1*4
                      	    65: 	movw $C_SEG_REAL,\arg1*4+2
                      	    66: .endm
                      	    67: 
                      	    68: 
                      	    69: # Tests a fault
                      	    70: # %1: vector
                      	    71: # %2: instruction to execute that causes a fault
                      	    72: 
                      	    73: .macro realModeFaultTest arg1,arg2,arg3
                      	    74: 	realModeExcInit \arg1,continue\@
                      	    75: 	mov $S_SEG_REAL,%ax
                      	    76: 	mov %ax,%ss
                      	    77: 	mov $ESP_REAL,%sp
                      	    78: test\@:
                      	    79: 	\arg2,%\arg3
                      	    80: 	jmp error
                      	    81: continue\@:
                      	    82: 	realModeExcCheck \arg1,test\@
                      	    83: .endm
                      	    84: 

Source: "t386.asm"
                      	   157: #-------------------------------------------------------------------------------
                      	   158: 	POST $0x00
04:0000005C B000      	     1M 	movb $0x00,%al
04:0000005E BA9001    	     2M 	movw $POST_PORT,%dx
04:00000061 EE        	     3M 	out %al,%dx
                      	   159: #-------------------------------------------------------------------------------
                      	   160: #
                      	   161: #   Real mode initialization
                      	   162: #
04:00000062 B800A0    	   163: 	mov $rodata_seg & realmd_mask,%ax
04:00000065 8ED8      	   164: 	mov %ax,%ds
04:00000067 0F011E0000	   165: 	lidt idt_addr-start_rodata
                      	   166: 	initRealModeIDT
04:0000006C B80090    	     1M 	mov $IDT_SEG_REAL,%ax
04:0000006F 8ED8      	     2M 	mov %ax,%ds
04:00000071 31FF      	     3M 	xor %di,%di
04:00000073 B91100    	     4M 	mov $17,%cx
                      	     5M aloop7:
04:00000076 C705AD24  	     6M 	movw $error,(%di)
04:0000007A C7450200F0	     7M 	movw $C_SEG_REAL,2(%di)
04:0000007F 83C704    	     8M 	add $4,%di
04:00000082 E2F2      	     9M 	loop aloop7
04:00000084 B800C0    	   167: 	mov $S_SEG_REAL,%ax
04:00000087 8ED0      	   168: 	mov %ax,%ss
04:00000089 BCFC7F    	   169: 	mov $ESP_REAL,%sp
04:0000008C C7C200C0  	   170: 	mov $D1_SEG_REAL,%dx
04:00000090 8EDA      	   171: 	mov %dx,%ds
04:00000092 C7C200C2  	   172: 	mov $D2_SEG_REAL,%dx
04:00000096 8EC2      	   173: 	mov %dx,%es
                      	   174: 
                      	   175: #-------------------------------------------------------------------------------
                      	   176: 	POST $0x01
04:00000098 B001      	     1M 	movb $0x01,%al
04:0000009A BA9001    	     2M 	movw $POST_PORT,%dx
04:0000009D EE        	     3M 	out %al,%dx
                      	   177: #-------------------------------------------------------------------------------
                      	   178: #
                      	   179: #   Conditional jumps
                      	   180: #
                      	   181: .include "jcc_m.asm"

Source: "jcc_m.asm"
                      	     1: #
                      	     2: # Tests conditional relative jumps.
                      	     3: # Uses: AX, ECX, Flags
                      	     4: #
                      	     5: # Opcodes tested, with positive and negative offsets:
                      	     6: #
                      	     7: # rel8  rel16/32 mnemonic condition
                      	     8: # 70    0F80     JO       OF=1
                      	     9: # 71    0F81     JNO      OF=0
                      	    10: # 72    0F82     JC       CF=1
                      	    11: # 73    0F83     JNC      CF=0
                      	    12: # 74    0F84     JZ       ZF=1
                      	    13: # 75    0F85     JNZ      ZF=0
                      	    14: # 76    0F86     JBE      CF=1 || ZF=1
                      	    15: # 77    0F87     JA       CF=0 && ZF=0
                      	    16: # 78    0F88     JS       SF=1
                      	    17: # 79    0F89     JNS      SF=0
                      	    18: # 7A    0F8A     JP       PF=1
                      	    19: # 7B    0F8B     JNP      PF=0
                      	    20: # 7C    0F8C     JL       SF!=OF
                      	    21: # 7D    0F8D     JNL      SF=OF
                      	    22: # 7E    0F8E     JLE      ZF=1 || SF!=OF
                      	    23: # 7F    0F8F     JNLE     ZF=0 && SF=OF
                      	    24: # E3             JCXZ     CX=0
                      	    25: # E3             JECXZ    ECX=0
                      	    26: #
                      	    27: .macro testJcc arg1
                      	    28: 	mov $PS_CF,%ah
                      	    29: 	sahf         # dont use the stack (pushf/popf)
                      	    30: 	jnc err1\@ 	# 73 / 0F83   JNC  CF=0
                      	    31: 	jc jcok\@ 	# 72 / 0F82   JC   CF=1
                      	    32: 	hlt
                      	    33: jz\@:
                      	    34: 	mov $PS_ZF,%ah
                      	    35: 	sahf
                      	    36: 	jnz err1\@ 	# 75 / 0F85   JNZ  ZF=0
                      	    37: 	jz jzok\@ 	# 74 / 0F84   JZ   ZF=1
                      	    38: 	hlt
                      	    39: jp\@:
                      	    40: 	mov $PS_PF,%ah
                      	    41: 	sahf
                      	    42: 	jnp err1\@ 	# 7B / 0F8B   JNP  PF=0
                      	    43: 	jp jpok\@ 	# 7A / 0F8A   JP   PF=1
                      	    44: 	hlt
                      	    45: js\@:
                      	    46: 	mov $PS_SF,%ah
                      	    47: 	sahf
                      	    48: 	jns err1\@ 	# 79 / 0F89   JNS  SF=0
                      	    49: 	js jsok\@ 	# 78 / 0F88   JS   SF=1
                      	    50: 	hlt
                      	    51: jna\@:
                      	    52: 	mov $PS_ZF|PS_CF,%ah
                      	    53: 	sahf
                      	    54: 	ja err1\@  	# 77 / 0F87   JA   CF=0 && ZF=0
                      	    55: 	jna jnaok\@ # 76 / 0F86   JBE  CF=1 || ZF=1
                      	    56: next1\@:
                      	    57: 	jmp jnc\@
                      	    58: 
                      	    59: .if \arg1==16
                      	    60: 	.rept 128
                      	    61: 		hlt
                      	    62: 	.endr
                      	    63: .endif
                      	    64: 
                      	    65: err1\@:
                      	    66: 	hlt
                      	    67: 
                      	    68: # test negative offsets
                      	    69: jcok\@:   jc   jz\@
                      	    70: jzok\@:   jz   jp\@
                      	    71: jpok\@:   jp   js\@
                      	    72: jsok\@:   js   jna\@
                      	    73: jnaok\@:  jna  next1\@
                      	    74: 
                      	    75: 
                      	    76: jnc\@:
                      	    77: 	mov $PS_SF|PS_ZF|PS_AF|PS_PF,%ah
                      	    78: 	sahf
                      	    79: 	mov $0,%ax
                      	    80: 	sahf
                      	    81: 	jnc   jncok\@ # 73 / 0F83   JNC  CF=0
                      	    82: 	hlt
                      	    83: jnz\@:
                      	    84: 	mov $PS_SF|PS_AF|PS_PF|PS_CF,%ah
                      	    85: 	sahf
                      	    86: 	jnz   jnzok\@ # 75 / 0F85   JNZ  ZF=0
                      	    87: 	hlt
                      	    88: jnp\@:
                      	    89: 	mov $PS_SF|PS_ZF|PS_AF|PS_CF,%ah
                      	    90: 	sahf
                      	    91: 	jnp   jnpok\@ # 7B / 0F8B   JNP  PF=0
                      	    92: 	hlt
                      	    93: jns\@:
                      	    94: 	mov $PS_ZF|PS_AF|PS_PF|PS_CF,%ah
                      	    95: 	sahf
                      	    96: 	jns jnsok\@ # 79 /  0F89  JNS  SF=0
                      	    97: 	hlt
                      	    98: ja\@:
                      	    99: 	mov $PS_SF|PS_AF|PS_PF,%ah
                      	   100: 	sahf
                      	   101: 	ja    jaok\@  # 77 / 0F87   JA   CF=0 && ZF=0
                      	   102: 	hlt
                      	   103: next2\@:
                      	   104: 	jmp   jo\@
                      	   105: 
                      	   106: .if \arg1==16
                      	   107: 	.rept 128
                      	   108: 		hlt
                      	   109: 	.endr
                      	   110: .endif
                      	   111: 
                      	   112: # test negative offsets
                      	   113: jncok\@:  jnc  jnz\@
                      	   114: jnzok\@:  jnz  jnp\@
                      	   115: jnpok\@:  jnp  jns\@
                      	   116: jnsok\@:  jns  ja\@
                      	   117: jaok\@:   ja   next2\@
                      	   118: 
                      	   119: jo\@:
                      	   120: 	mov $0,%ah
                      	   121: 	sahf
                      	   122: 	mov $0b1000000,%al
                      	   123: 	shl $1,%al   	# OF = high-order bit of AL <> (CF), ZF=0,SF=1,OF=1
                      	   124: 	jno err2\@
                      	   125: 	jo jook\@
                      	   126: 	hlt
                      	   127: jnl\@:
                      	   128: 	jl err2\@   	# 7C / 0F8C   JL   SF!=OF
                      	   129: 	jnl jnlok\@  	# 7D / 0F8D   JNL  SF=OF
                      	   130: 	hlt
                      	   131: jnle\@:
                      	   132: 	jle err2\@   	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
                      	   133: 	jnle jnleok\@ # 7F / 0F8F   JNLE ZF=0 && SF=OF
                      	   134: 	hlt
                      	   135: jl\@:
                      	   136: 	mov $PS_ZF,%ah
                      	   137: 	sahf          # ZF=1,SF=0,OF=1
                      	   138: 	jl jlok\@   	# 7C / 0F8C   JL   SF!=OF
                      	   139: 	hlt
                      	   140: jle\@:
                      	   141: 	jle jleok\@  	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
                      	   142: 	hlt
                      	   143: jcxz\@:
                      	   144: .if \arg1==8
                      	   145: 	mov $1,%ecx
                      	   146: 	jcxz err2\@      	# E3   JCXZ  CX=0
                      	   147: 	mov $0x10000,%ecx
                      	   148: 	jcxz jcxzok\@
                      	   149: jecxz\@:
                      	   150: 	jecxz err2\@
                      	   151: 	mov $0,%ecx
                      	   152: 	jecxz jecxzok\@ 	# E3   JECXZ   ECX=0
                      	   153: jecxze\@:
                      	   154: .endif
                      	   155: 	jmp exit\@
                      	   156: 
                      	   157: .if \arg1==16
                      	   158: 	.rept 128
                      	   159: 		hlt
                      	   160: 	.endr
                      	   161: .endif
                      	   162: 
                      	   163: err2\@:
                      	   164: 	hlt
                      	   165: 
                      	   166: # test negative offsets
                      	   167: jook\@:   jo   jnl\@
                      	   168: jnlok\@:  jnl  jnle\@
                      	   169: jnleok\@: jnle jl\@
                      	   170: jlok\@:   jl   jle\@
                      	   171: jleok\@:  jle  jcxz\@
                      	   172: .if \arg1==8
                      	   173: jcxzok\@:  jcxz  jecxz\@
                      	   174: jecxzok\@: jecxz jecxze\@
                      	   175: .endif
                      	   176: 
                      	   177: exit\@:
                      	   178: .endm
                      	   179: 

Source: "t386.asm"
                      	   182: 	testJcc 8
04:0000009E B401      	     1M 	mov $PS_CF,%ah
04:000000A0 9E        	     2M 	sahf         # dont use the stack (pushf/popf)
04:000000A1 7324      	     3M 	jnc err110 	# 73 / 0F83   JNC  CF=0
04:000000A3 7223      	     4M 	jc jcok10 	# 72 / 0F82   JC   CF=1
04:000000A5 F4        	     5M 	hlt
                      	     6M jz10:
04:000000A6 B440      	     7M 	mov $PS_ZF,%ah
04:000000A8 9E        	     8M 	sahf
04:000000A9 751C      	     9M 	jnz err110 	# 75 / 0F85   JNZ  ZF=0
04:000000AB 741D      	    10M 	jz jzok10 	# 74 / 0F84   JZ   ZF=1
04:000000AD F4        	    11M 	hlt
                      	    12M jp10:
04:000000AE B404      	    13M 	mov $PS_PF,%ah
04:000000B0 9E        	    14M 	sahf
04:000000B1 7B14      	    15M 	jnp err110 	# 7B / 0F8B   JNP  PF=0
04:000000B3 7A17      	    16M 	jp jpok10 	# 7A / 0F8A   JP   PF=1
04:000000B5 F4        	    17M 	hlt
                      	    18M js10:
04:000000B6 B480      	    19M 	mov $PS_SF,%ah
04:000000B8 9E        	    20M 	sahf
04:000000B9 790C      	    21M 	jns err110 	# 79 / 0F89   JNS  SF=0
04:000000BB 7811      	    22M 	js jsok10 	# 78 / 0F88   JS   SF=1
04:000000BD F4        	    23M 	hlt
                      	    24M jna10:
04:000000BE B441      	    25M 	mov $PS_ZF|PS_CF,%ah
04:000000C0 9E        	    26M 	sahf
04:000000C1 7704      	    27M 	ja err110  	# 77 / 0F87   JA   CF=0 && ZF=0
04:000000C3 760B      	    28M 	jna jnaok10 # 76 / 0F86   JBE  CF=1 || ZF=1
                      	    29M next110:
04:000000C5 EB0B      	    30M 	jmp jnc10
                      	    31M 
                      	    32M .if 8==16
                      	    33M 	.rept 128
                      	    34M 		hlt
                      	    35M 	.endr
                      	    36M .endif
                      	    37M 
                      	    38M err110:
04:000000C7 F4        	    39M 	hlt
                      	    40M 
                      	    41M # test negative offsets
04:000000C8 72DC      	    42M jcok10:   jc   jz10
04:000000CA 74E2      	    43M jzok10:   jz   jp10
04:000000CC 7AE8      	    44M jpok10:   jp   js10
04:000000CE 78EE      	    45M jsok10:   js   jna10
04:000000D0 76F3      	    46M jnaok10:  jna  next110
                      	    47M 
                      	    48M 
                      	    49M jnc10:
04:000000D2 B4D4      	    50M 	mov $PS_SF|PS_ZF|PS_AF|PS_PF,%ah
04:000000D4 9E        	    51M 	sahf
04:000000D5 B80000    	    52M 	mov $0,%ax
04:000000D8 9E        	    53M 	sahf
04:000000D9 731B      	    54M 	jnc   jncok10 # 73 / 0F83   JNC  CF=0
04:000000DB F4        	    55M 	hlt
                      	    56M jnz10:
04:000000DC B495      	    57M 	mov $PS_SF|PS_AF|PS_PF|PS_CF,%ah
04:000000DE 9E        	    58M 	sahf
04:000000DF 7517      	    59M 	jnz   jnzok10 # 75 / 0F85   JNZ  ZF=0
04:000000E1 F4        	    60M 	hlt
                      	    61M jnp10:
04:000000E2 B4D1      	    62M 	mov $PS_SF|PS_ZF|PS_AF|PS_CF,%ah
04:000000E4 9E        	    63M 	sahf
04:000000E5 7B13      	    64M 	jnp   jnpok10 # 7B / 0F8B   JNP  PF=0
04:000000E7 F4        	    65M 	hlt
                      	    66M jns10:
04:000000E8 B455      	    67M 	mov $PS_ZF|PS_AF|PS_PF|PS_CF,%ah
04:000000EA 9E        	    68M 	sahf
04:000000EB 790F      	    69M 	jns jnsok10 # 79 /  0F89  JNS  SF=0
04:000000ED F4        	    70M 	hlt
                      	    71M ja10:
04:000000EE B494      	    72M 	mov $PS_SF|PS_AF|PS_PF,%ah
04:000000F0 9E        	    73M 	sahf
04:000000F1 770B      	    74M 	ja    jaok10  # 77 / 0F87   JA   CF=0 && ZF=0
04:000000F3 F4        	    75M 	hlt
                      	    76M next210:
04:000000F4 EB0A      	    77M 	jmp   jo10
                      	    78M 
                      	    79M .if 8==16
                      	    80M 	.rept 128
                      	    81M 		hlt
                      	    82M 	.endr
                      	    83M .endif
                      	    84M 
                      	    85M # test negative offsets
04:000000F6 73E4      	    86M jncok10:  jnc  jnz10
04:000000F8 75E8      	    87M jnzok10:  jnz  jnp10
04:000000FA 7BEC      	    88M jnpok10:  jnp  jns10
04:000000FC 79F0      	    89M jnsok10:  jns  ja10
04:000000FE 77F4      	    90M jaok10:   ja   next210
                      	    91M 
                      	    92M jo10:
04:00000100 B400      	    93M 	mov $0,%ah
04:00000102 9E        	    94M 	sahf
04:00000103 B040      	    95M 	mov $0b1000000,%al
04:00000105 C0E001    	    96M 	shl $1,%al   	# OF = high-order bit of AL <> (CF), ZF=0,SF=1,OF=1
04:00000108 7132      	    97M 	jno err210
04:0000010A 7031      	    98M 	jo jook10
04:0000010C F4        	    99M 	hlt
                      	   100M jnl10:
04:0000010D 7C2D      	   101M 	jl err210   	# 7C / 0F8C   JL   SF!=OF
04:0000010F 7D2E      	   102M 	jnl jnlok10  	# 7D / 0F8D   JNL  SF=OF
04:00000111 F4        	   103M 	hlt
                      	   104M jnle10:
04:00000112 7E28      	   105M 	jle err210   	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
04:00000114 7F2B      	   106M 	jnle jnleok10 # 7F / 0F8F   JNLE ZF=0 && SF=OF
04:00000116 F4        	   107M 	hlt
                      	   108M jl10:
04:00000117 B440      	   109M 	mov $PS_ZF,%ah
04:00000119 9E        	   110M 	sahf          # ZF=1,SF=0,OF=1
04:0000011A 7C27      	   111M 	jl jlok10   	# 7C / 0F8C   JL   SF!=OF
04:0000011C F4        	   112M 	hlt
                      	   113M jle10:
04:0000011D 7E26      	   114M 	jle jleok10  	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
04:0000011F F4        	   115M 	hlt
                      	   116M jcxz10:
                      	   117M .if 8==8
04:00000120 66B9010000	   118M 	mov $1,%ecx
04:00000125 00
04:00000126 E314      	   119M 	jcxz err210      	# E3   JCXZ  CX=0
04:00000128 66B9000001	   120M 	mov $0x10000,%ecx
04:0000012D 00
04:0000012E E317      	   121M 	jcxz jcxzok10
                      	   122M jecxz10:
04:00000130 E30A      	   123M 	jecxz err210
04:00000132 66B9000000	   124M 	mov $0,%ecx
04:00000137 00
04:00000138 E30F      	   125M 	jecxz jecxzok10 	# E3   JECXZ   ECX=0
                      	   126M jecxze10:
                      	   127M .endif
04:0000013A EB0F      	   128M 	jmp exit10
                      	   129M 
                      	   130M .if 8==16
                      	   131M 	.rept 128
                      	   132M 		hlt
                      	   133M 	.endr
                      	   134M .endif
                      	   135M 
                      	   136M err210:
04:0000013C F4        	   137M 	hlt
                      	   138M 
                      	   139M # test negative offsets
04:0000013D 70CE      	   140M jook10:   jo   jnl10
04:0000013F 7DD1      	   141M jnlok10:  jnl  jnle10
04:00000141 7FD4      	   142M jnleok10: jnle jl10
04:00000143 7CD8      	   143M jlok10:   jl   jle10
04:00000145 7ED9      	   144M jleok10:  jle  jcxz10
                      	   145M .if 8==8
04:00000147 E3E7      	   146M jcxzok10:  jcxz  jecxz10
04:00000149 E3EF      	   147M jecxzok10: jecxz jecxze10
                      	   148M .endif
                      	   149M 
                      	   150M exit10:
                      	   183: 	testJcc 16
04:0000014B B401      	     1M 	mov $PS_CF,%ah
04:0000014D 9E        	     2M 	sahf         # dont use the stack (pushf/popf)
04:0000014E 0F83B700  	     3M 	jnc err111 	# 73 / 0F83   JNC  CF=0
04:00000152 0F82B400  	     4M 	jc jcok11 	# 72 / 0F82   JC   CF=1
04:00000156 F4        	     5M 	hlt
                      	     6M jz11:
04:00000157 B440      	     7M 	mov $PS_ZF,%ah
04:00000159 9E        	     8M 	sahf
04:0000015A 0F85AB00  	     9M 	jnz err111 	# 75 / 0F85   JNZ  ZF=0
04:0000015E 0F84AC00  	    10M 	jz jzok11 	# 74 / 0F84   JZ   ZF=1
04:00000162 F4        	    11M 	hlt
                      	    12M jp11:
04:00000163 B404      	    13M 	mov $PS_PF,%ah
04:00000165 9E        	    14M 	sahf
04:00000166 0F8B9F00  	    15M 	jnp err111 	# 7B / 0F8B   JNP  PF=0
04:0000016A 0F8AA400  	    16M 	jp jpok11 	# 7A / 0F8A   JP   PF=1
04:0000016E F4        	    17M 	hlt
                      	    18M js11:
04:0000016F B480      	    19M 	mov $PS_SF,%ah
04:00000171 9E        	    20M 	sahf
04:00000172 0F899300  	    21M 	jns err111 	# 79 / 0F89   JNS  SF=0
04:00000176 0F889C00  	    22M 	js jsok11 	# 78 / 0F88   JS   SF=1
04:0000017A F4        	    23M 	hlt
                      	    24M jna11:
04:0000017B B441      	    25M 	mov $PS_ZF|PS_CF,%ah
04:0000017D 9E        	    26M 	sahf
04:0000017E 0F878700  	    27M 	ja err111  	# 77 / 0F87   JA   CF=0 && ZF=0
04:00000182 0F869400  	    28M 	jna jnaok11 # 76 / 0F86   JBE  CF=1 || ZF=1
                      	    29M next111:
04:00000186 E99500    	    30M 	jmp jnc11
                      	    31M 
                      	    32M .if 16==16
                      	    33M 	.rept 128
                      	    34M 		hlt
                      	    35M 	.endr
04:00000189 F4        	     1M 		hlt
                      	     2M 	
04:0000018A F4        	     1M 		hlt
                      	     2M 	
04:0000018B F4        	     1M 		hlt
                      	     2M 	
04:0000018C F4        	     1M 		hlt
                      	     2M 	
04:0000018D F4        	     1M 		hlt
                      	     2M 	
04:0000018E F4        	     1M 		hlt
                      	     2M 	
04:0000018F F4        	     1M 		hlt
                      	     2M 	
04:00000190 F4        	     1M 		hlt
                      	     2M 	
04:00000191 F4        	     1M 		hlt
                      	     2M 	
04:00000192 F4        	     1M 		hlt
                      	     2M 	
04:00000193 F4        	     1M 		hlt
                      	     2M 	
04:00000194 F4        	     1M 		hlt
                      	     2M 	
04:00000195 F4        	     1M 		hlt
                      	     2M 	
04:00000196 F4        	     1M 		hlt
                      	     2M 	
04:00000197 F4        	     1M 		hlt
                      	     2M 	
04:00000198 F4        	     1M 		hlt
                      	     2M 	
04:00000199 F4        	     1M 		hlt
                      	     2M 	
04:0000019A F4        	     1M 		hlt
                      	     2M 	
04:0000019B F4        	     1M 		hlt
                      	     2M 	
04:0000019C F4        	     1M 		hlt
                      	     2M 	
04:0000019D F4        	     1M 		hlt
                      	     2M 	
04:0000019E F4        	     1M 		hlt
                      	     2M 	
04:0000019F F4        	     1M 		hlt
                      	     2M 	
04:000001A0 F4        	     1M 		hlt
                      	     2M 	
04:000001A1 F4        	     1M 		hlt
                      	     2M 	
04:000001A2 F4        	     1M 		hlt
                      	     2M 	
04:000001A3 F4        	     1M 		hlt
                      	     2M 	
04:000001A4 F4        	     1M 		hlt
                      	     2M 	
04:000001A5 F4        	     1M 		hlt
                      	     2M 	
04:000001A6 F4        	     1M 		hlt
                      	     2M 	
04:000001A7 F4        	     1M 		hlt
                      	     2M 	
04:000001A8 F4        	     1M 		hlt
                      	     2M 	
04:000001A9 F4        	     1M 		hlt
                      	     2M 	
04:000001AA F4        	     1M 		hlt
                      	     2M 	
04:000001AB F4        	     1M 		hlt
                      	     2M 	
04:000001AC F4        	     1M 		hlt
                      	     2M 	
04:000001AD F4        	     1M 		hlt
                      	     2M 	
04:000001AE F4        	     1M 		hlt
                      	     2M 	
04:000001AF F4        	     1M 		hlt
                      	     2M 	
04:000001B0 F4        	     1M 		hlt
                      	     2M 	
04:000001B1 F4        	     1M 		hlt
                      	     2M 	
04:000001B2 F4        	     1M 		hlt
                      	     2M 	
04:000001B3 F4        	     1M 		hlt
                      	     2M 	
04:000001B4 F4        	     1M 		hlt
                      	     2M 	
04:000001B5 F4        	     1M 		hlt
                      	     2M 	
04:000001B6 F4        	     1M 		hlt
                      	     2M 	
04:000001B7 F4        	     1M 		hlt
                      	     2M 	
04:000001B8 F4        	     1M 		hlt
                      	     2M 	
04:000001B9 F4        	     1M 		hlt
                      	     2M 	
04:000001BA F4        	     1M 		hlt
                      	     2M 	
04:000001BB F4        	     1M 		hlt
                      	     2M 	
04:000001BC F4        	     1M 		hlt
                      	     2M 	
04:000001BD F4        	     1M 		hlt
                      	     2M 	
04:000001BE F4        	     1M 		hlt
                      	     2M 	
04:000001BF F4        	     1M 		hlt
                      	     2M 	
04:000001C0 F4        	     1M 		hlt
                      	     2M 	
04:000001C1 F4        	     1M 		hlt
                      	     2M 	
04:000001C2 F4        	     1M 		hlt
                      	     2M 	
04:000001C3 F4        	     1M 		hlt
                      	     2M 	
04:000001C4 F4        	     1M 		hlt
                      	     2M 	
04:000001C5 F4        	     1M 		hlt
                      	     2M 	
04:000001C6 F4        	     1M 		hlt
                      	     2M 	
04:000001C7 F4        	     1M 		hlt
                      	     2M 	
04:000001C8 F4        	     1M 		hlt
                      	     2M 	
04:000001C9 F4        	     1M 		hlt
                      	     2M 	
04:000001CA F4        	     1M 		hlt
                      	     2M 	
04:000001CB F4        	     1M 		hlt
                      	     2M 	
04:000001CC F4        	     1M 		hlt
                      	     2M 	
04:000001CD F4        	     1M 		hlt
                      	     2M 	
04:000001CE F4        	     1M 		hlt
                      	     2M 	
04:000001CF F4        	     1M 		hlt
                      	     2M 	
04:000001D0 F4        	     1M 		hlt
                      	     2M 	
04:000001D1 F4        	     1M 		hlt
                      	     2M 	
04:000001D2 F4        	     1M 		hlt
                      	     2M 	
04:000001D3 F4        	     1M 		hlt
                      	     2M 	
04:000001D4 F4        	     1M 		hlt
                      	     2M 	
04:000001D5 F4        	     1M 		hlt
                      	     2M 	
04:000001D6 F4        	     1M 		hlt
                      	     2M 	
04:000001D7 F4        	     1M 		hlt
                      	     2M 	
04:000001D8 F4        	     1M 		hlt
                      	     2M 	
04:000001D9 F4        	     1M 		hlt
                      	     2M 	
04:000001DA F4        	     1M 		hlt
                      	     2M 	
04:000001DB F4        	     1M 		hlt
                      	     2M 	
04:000001DC F4        	     1M 		hlt
                      	     2M 	
04:000001DD F4        	     1M 		hlt
                      	     2M 	
04:000001DE F4        	     1M 		hlt
                      	     2M 	
04:000001DF F4        	     1M 		hlt
                      	     2M 	
04:000001E0 F4        	     1M 		hlt
                      	     2M 	
04:000001E1 F4        	     1M 		hlt
                      	     2M 	
04:000001E2 F4        	     1M 		hlt
                      	     2M 	
04:000001E3 F4        	     1M 		hlt
                      	     2M 	
04:000001E4 F4        	     1M 		hlt
                      	     2M 	
04:000001E5 F4        	     1M 		hlt
                      	     2M 	
04:000001E6 F4        	     1M 		hlt
                      	     2M 	
04:000001E7 F4        	     1M 		hlt
                      	     2M 	
04:000001E8 F4        	     1M 		hlt
                      	     2M 	
04:000001E9 F4        	     1M 		hlt
                      	     2M 	
04:000001EA F4        	     1M 		hlt
                      	     2M 	
04:000001EB F4        	     1M 		hlt
                      	     2M 	
04:000001EC F4        	     1M 		hlt
                      	     2M 	
04:000001ED F4        	     1M 		hlt
                      	     2M 	
04:000001EE F4        	     1M 		hlt
                      	     2M 	
04:000001EF F4        	     1M 		hlt
                      	     2M 	
04:000001F0 F4        	     1M 		hlt
                      	     2M 	
04:000001F1 F4        	     1M 		hlt
                      	     2M 	
04:000001F2 F4        	     1M 		hlt
                      	     2M 	
04:000001F3 F4        	     1M 		hlt
                      	     2M 	
04:000001F4 F4        	     1M 		hlt
                      	     2M 	
04:000001F5 F4        	     1M 		hlt
                      	     2M 	
04:000001F6 F4        	     1M 		hlt
                      	     2M 	
04:000001F7 F4        	     1M 		hlt
                      	     2M 	
04:000001F8 F4        	     1M 		hlt
                      	     2M 	
04:000001F9 F4        	     1M 		hlt
                      	     2M 	
04:000001FA F4        	     1M 		hlt
                      	     2M 	
04:000001FB F4        	     1M 		hlt
                      	     2M 	
04:000001FC F4        	     1M 		hlt
                      	     2M 	
04:000001FD F4        	     1M 		hlt
                      	     2M 	
04:000001FE F4        	     1M 		hlt
                      	     2M 	
04:000001FF F4        	     1M 		hlt
                      	     2M 	
04:00000200 F4        	     1M 		hlt
                      	     2M 	
04:00000201 F4        	     1M 		hlt
                      	     2M 	
04:00000202 F4        	     1M 		hlt
                      	     2M 	
04:00000203 F4        	     1M 		hlt
                      	     2M 	
04:00000204 F4        	     1M 		hlt
                      	     2M 	
04:00000205 F4        	     1M 		hlt
                      	     2M 	
04:00000206 F4        	     1M 		hlt
                      	     2M 	
04:00000207 F4        	     1M 		hlt
                      	     2M 	
04:00000208 F4        	     1M 		hlt
                      	     2M 	
                      	    36M .endif
                      	    37M 
                      	    38M err111:
04:00000209 F4        	    39M 	hlt
                      	    40M 
                      	    41M # test negative offsets
04:0000020A 0F8249FF  	    42M jcok11:   jc   jz11
04:0000020E 0F8451FF  	    43M jzok11:   jz   jp11
04:00000212 0F8A59FF  	    44M jpok11:   jp   js11
04:00000216 0F8861FF  	    45M jsok11:   js   jna11
04:0000021A 0F8668FF  	    46M jnaok11:  jna  next111
                      	    47M 
                      	    48M 
                      	    49M jnc11:
04:0000021E B4D4      	    50M 	mov $PS_SF|PS_ZF|PS_AF|PS_PF,%ah
04:00000220 9E        	    51M 	sahf
04:00000221 B80000    	    52M 	mov $0,%ax
04:00000224 9E        	    53M 	sahf
04:00000225 0F83A400  	    54M 	jnc   jncok11 # 73 / 0F83   JNC  CF=0
04:00000229 F4        	    55M 	hlt
                      	    56M jnz11:
04:0000022A B495      	    57M 	mov $PS_SF|PS_AF|PS_PF|PS_CF,%ah
04:0000022C 9E        	    58M 	sahf
04:0000022D 0F85A000  	    59M 	jnz   jnzok11 # 75 / 0F85   JNZ  ZF=0
04:00000231 F4        	    60M 	hlt
                      	    61M jnp11:
04:00000232 B4D1      	    62M 	mov $PS_SF|PS_ZF|PS_AF|PS_CF,%ah
04:00000234 9E        	    63M 	sahf
04:00000235 0F8B9C00  	    64M 	jnp   jnpok11 # 7B / 0F8B   JNP  PF=0
04:00000239 F4        	    65M 	hlt
                      	    66M jns11:
04:0000023A B455      	    67M 	mov $PS_ZF|PS_AF|PS_PF|PS_CF,%ah
04:0000023C 9E        	    68M 	sahf
04:0000023D 0F899800  	    69M 	jns jnsok11 # 79 /  0F89  JNS  SF=0
04:00000241 F4        	    70M 	hlt
                      	    71M ja11:
04:00000242 B494      	    72M 	mov $PS_SF|PS_AF|PS_PF,%ah
04:00000244 9E        	    73M 	sahf
04:00000245 0F879400  	    74M 	ja    jaok11  # 77 / 0F87   JA   CF=0 && ZF=0
04:00000249 F4        	    75M 	hlt
                      	    76M next211:
04:0000024A E99400    	    77M 	jmp   jo11
                      	    78M 
                      	    79M .if 16==16
                      	    80M 	.rept 128
                      	    81M 		hlt
                      	    82M 	.endr
04:0000024D F4        	     1M 		hlt
                      	     2M 	
04:0000024E F4        	     1M 		hlt
                      	     2M 	
04:0000024F F4        	     1M 		hlt
                      	     2M 	
04:00000250 F4        	     1M 		hlt
                      	     2M 	
04:00000251 F4        	     1M 		hlt
                      	     2M 	
04:00000252 F4        	     1M 		hlt
                      	     2M 	
04:00000253 F4        	     1M 		hlt
                      	     2M 	
04:00000254 F4        	     1M 		hlt
                      	     2M 	
04:00000255 F4        	     1M 		hlt
                      	     2M 	
04:00000256 F4        	     1M 		hlt
                      	     2M 	
04:00000257 F4        	     1M 		hlt
                      	     2M 	
04:00000258 F4        	     1M 		hlt
                      	     2M 	
04:00000259 F4        	     1M 		hlt
                      	     2M 	
04:0000025A F4        	     1M 		hlt
                      	     2M 	
04:0000025B F4        	     1M 		hlt
                      	     2M 	
04:0000025C F4        	     1M 		hlt
                      	     2M 	
04:0000025D F4        	     1M 		hlt
                      	     2M 	
04:0000025E F4        	     1M 		hlt
                      	     2M 	
04:0000025F F4        	     1M 		hlt
                      	     2M 	
04:00000260 F4        	     1M 		hlt
                      	     2M 	
04:00000261 F4        	     1M 		hlt
                      	     2M 	
04:00000262 F4        	     1M 		hlt
                      	     2M 	
04:00000263 F4        	     1M 		hlt
                      	     2M 	
04:00000264 F4        	     1M 		hlt
                      	     2M 	
04:00000265 F4        	     1M 		hlt
                      	     2M 	
04:00000266 F4        	     1M 		hlt
                      	     2M 	
04:00000267 F4        	     1M 		hlt
                      	     2M 	
04:00000268 F4        	     1M 		hlt
                      	     2M 	
04:00000269 F4        	     1M 		hlt
                      	     2M 	
04:0000026A F4        	     1M 		hlt
                      	     2M 	
04:0000026B F4        	     1M 		hlt
                      	     2M 	
04:0000026C F4        	     1M 		hlt
                      	     2M 	
04:0000026D F4        	     1M 		hlt
                      	     2M 	
04:0000026E F4        	     1M 		hlt
                      	     2M 	
04:0000026F F4        	     1M 		hlt
                      	     2M 	
04:00000270 F4        	     1M 		hlt
                      	     2M 	
04:00000271 F4        	     1M 		hlt
                      	     2M 	
04:00000272 F4        	     1M 		hlt
                      	     2M 	
04:00000273 F4        	     1M 		hlt
                      	     2M 	
04:00000274 F4        	     1M 		hlt
                      	     2M 	
04:00000275 F4        	     1M 		hlt
                      	     2M 	
04:00000276 F4        	     1M 		hlt
                      	     2M 	
04:00000277 F4        	     1M 		hlt
                      	     2M 	
04:00000278 F4        	     1M 		hlt
                      	     2M 	
04:00000279 F4        	     1M 		hlt
                      	     2M 	
04:0000027A F4        	     1M 		hlt
                      	     2M 	
04:0000027B F4        	     1M 		hlt
                      	     2M 	
04:0000027C F4        	     1M 		hlt
                      	     2M 	
04:0000027D F4        	     1M 		hlt
                      	     2M 	
04:0000027E F4        	     1M 		hlt
                      	     2M 	
04:0000027F F4        	     1M 		hlt
                      	     2M 	
04:00000280 F4        	     1M 		hlt
                      	     2M 	
04:00000281 F4        	     1M 		hlt
                      	     2M 	
04:00000282 F4        	     1M 		hlt
                      	     2M 	
04:00000283 F4        	     1M 		hlt
                      	     2M 	
04:00000284 F4        	     1M 		hlt
                      	     2M 	
04:00000285 F4        	     1M 		hlt
                      	     2M 	
04:00000286 F4        	     1M 		hlt
                      	     2M 	
04:00000287 F4        	     1M 		hlt
                      	     2M 	
04:00000288 F4        	     1M 		hlt
                      	     2M 	
04:00000289 F4        	     1M 		hlt
                      	     2M 	
04:0000028A F4        	     1M 		hlt
                      	     2M 	
04:0000028B F4        	     1M 		hlt
                      	     2M 	
04:0000028C F4        	     1M 		hlt
                      	     2M 	
04:0000028D F4        	     1M 		hlt
                      	     2M 	
04:0000028E F4        	     1M 		hlt
                      	     2M 	
04:0000028F F4        	     1M 		hlt
                      	     2M 	
04:00000290 F4        	     1M 		hlt
                      	     2M 	
04:00000291 F4        	     1M 		hlt
                      	     2M 	
04:00000292 F4        	     1M 		hlt
                      	     2M 	
04:00000293 F4        	     1M 		hlt
                      	     2M 	
04:00000294 F4        	     1M 		hlt
                      	     2M 	
04:00000295 F4        	     1M 		hlt
                      	     2M 	
04:00000296 F4        	     1M 		hlt
                      	     2M 	
04:00000297 F4        	     1M 		hlt
                      	     2M 	
04:00000298 F4        	     1M 		hlt
                      	     2M 	
04:00000299 F4        	     1M 		hlt
                      	     2M 	
04:0000029A F4        	     1M 		hlt
                      	     2M 	
04:0000029B F4        	     1M 		hlt
                      	     2M 	
04:0000029C F4        	     1M 		hlt
                      	     2M 	
04:0000029D F4        	     1M 		hlt
                      	     2M 	
04:0000029E F4        	     1M 		hlt
                      	     2M 	
04:0000029F F4        	     1M 		hlt
                      	     2M 	
04:000002A0 F4        	     1M 		hlt
                      	     2M 	
04:000002A1 F4        	     1M 		hlt
                      	     2M 	
04:000002A2 F4        	     1M 		hlt
                      	     2M 	
04:000002A3 F4        	     1M 		hlt
                      	     2M 	
04:000002A4 F4        	     1M 		hlt
                      	     2M 	
04:000002A5 F4        	     1M 		hlt
                      	     2M 	
04:000002A6 F4        	     1M 		hlt
                      	     2M 	
04:000002A7 F4        	     1M 		hlt
                      	     2M 	
04:000002A8 F4        	     1M 		hlt
                      	     2M 	
04:000002A9 F4        	     1M 		hlt
                      	     2M 	
04:000002AA F4        	     1M 		hlt
                      	     2M 	
04:000002AB F4        	     1M 		hlt
                      	     2M 	
04:000002AC F4        	     1M 		hlt
                      	     2M 	
04:000002AD F4        	     1M 		hlt
                      	     2M 	
04:000002AE F4        	     1M 		hlt
                      	     2M 	
04:000002AF F4        	     1M 		hlt
                      	     2M 	
04:000002B0 F4        	     1M 		hlt
                      	     2M 	
04:000002B1 F4        	     1M 		hlt
                      	     2M 	
04:000002B2 F4        	     1M 		hlt
                      	     2M 	
04:000002B3 F4        	     1M 		hlt
                      	     2M 	
04:000002B4 F4        	     1M 		hlt
                      	     2M 	
04:000002B5 F4        	     1M 		hlt
                      	     2M 	
04:000002B6 F4        	     1M 		hlt
                      	     2M 	
04:000002B7 F4        	     1M 		hlt
                      	     2M 	
04:000002B8 F4        	     1M 		hlt
                      	     2M 	
04:000002B9 F4        	     1M 		hlt
                      	     2M 	
04:000002BA F4        	     1M 		hlt
                      	     2M 	
04:000002BB F4        	     1M 		hlt
                      	     2M 	
04:000002BC F4        	     1M 		hlt
                      	     2M 	
04:000002BD F4        	     1M 		hlt
                      	     2M 	
04:000002BE F4        	     1M 		hlt
                      	     2M 	
04:000002BF F4        	     1M 		hlt
                      	     2M 	
04:000002C0 F4        	     1M 		hlt
                      	     2M 	
04:000002C1 F4        	     1M 		hlt
                      	     2M 	
04:000002C2 F4        	     1M 		hlt
                      	     2M 	
04:000002C3 F4        	     1M 		hlt
                      	     2M 	
04:000002C4 F4        	     1M 		hlt
                      	     2M 	
04:000002C5 F4        	     1M 		hlt
                      	     2M 	
04:000002C6 F4        	     1M 		hlt
                      	     2M 	
04:000002C7 F4        	     1M 		hlt
                      	     2M 	
04:000002C8 F4        	     1M 		hlt
                      	     2M 	
04:000002C9 F4        	     1M 		hlt
                      	     2M 	
04:000002CA F4        	     1M 		hlt
                      	     2M 	
04:000002CB F4        	     1M 		hlt
                      	     2M 	
04:000002CC F4        	     1M 		hlt
                      	     2M 	
                      	    83M .endif
                      	    84M 
                      	    85M # test negative offsets
04:000002CD 0F8359FF  	    86M jncok11:  jnc  jnz11
04:000002D1 0F855DFF  	    87M jnzok11:  jnz  jnp11
04:000002D5 0F8B61FF  	    88M jnpok11:  jnp  jns11
04:000002D9 0F8965FF  	    89M jnsok11:  jns  ja11
04:000002DD 0F8769FF  	    90M jaok11:   ja   next211
                      	    91M 
                      	    92M jo11:
04:000002E1 B400      	    93M 	mov $0,%ah
04:000002E3 9E        	    94M 	sahf
04:000002E4 B040      	    95M 	mov $0b1000000,%al
04:000002E6 C0E001    	    96M 	shl $1,%al   	# OF = high-order bit of AL <> (CF), ZF=0,SF=1,OF=1
04:000002E9 0F81A700  	    97M 	jno err211
04:000002ED 0F80A400  	    98M 	jo jook11
04:000002F1 F4        	    99M 	hlt
                      	   100M jnl11:
04:000002F2 0F8C9E00  	   101M 	jl err211   	# 7C / 0F8C   JL   SF!=OF
04:000002F6 0F8D9F00  	   102M 	jnl jnlok11  	# 7D / 0F8D   JNL  SF=OF
04:000002FA F4        	   103M 	hlt
                      	   104M jnle11:
04:000002FB 0F8E9500  	   105M 	jle err211   	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
04:000002FF 0F8F9A00  	   106M 	jnle jnleok11 # 7F / 0F8F   JNLE ZF=0 && SF=OF
04:00000303 F4        	   107M 	hlt
                      	   108M jl11:
04:00000304 B440      	   109M 	mov $PS_ZF,%ah
04:00000306 9E        	   110M 	sahf          # ZF=1,SF=0,OF=1
04:00000307 0F8C9600  	   111M 	jl jlok11   	# 7C / 0F8C   JL   SF!=OF
04:0000030B F4        	   112M 	hlt
                      	   113M jle11:
04:0000030C 0F8E9500  	   114M 	jle jleok11  	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
04:00000310 F4        	   115M 	hlt
                      	   116M jcxz11:
                      	   117M .if 16==8
                      	   118M 	mov $1,%ecx
                      	   119M 	jcxz err211      	# E3   JCXZ  CX=0
                      	   120M 	mov $0x10000,%ecx
                      	   121M 	jcxz jcxzok11
                      	   122M jecxz11:
                      	   123M 	jecxz err211
                      	   124M 	mov $0,%ecx
                      	   125M 	jecxz jecxzok11 	# E3   JECXZ   ECX=0
                      	   126M jecxze11:
                      	   127M .endif
04:00000311 E99500    	   128M 	jmp exit11
                      	   129M 
                      	   130M .if 16==16
                      	   131M 	.rept 128
                      	   132M 		hlt
                      	   133M 	.endr
04:00000314 F4        	     1M 		hlt
                      	     2M 	
04:00000315 F4        	     1M 		hlt
                      	     2M 	
04:00000316 F4        	     1M 		hlt
                      	     2M 	
04:00000317 F4        	     1M 		hlt
                      	     2M 	
04:00000318 F4        	     1M 		hlt
                      	     2M 	
04:00000319 F4        	     1M 		hlt
                      	     2M 	
04:0000031A F4        	     1M 		hlt
                      	     2M 	
04:0000031B F4        	     1M 		hlt
                      	     2M 	
04:0000031C F4        	     1M 		hlt
                      	     2M 	
04:0000031D F4        	     1M 		hlt
                      	     2M 	
04:0000031E F4        	     1M 		hlt
                      	     2M 	
04:0000031F F4        	     1M 		hlt
                      	     2M 	
04:00000320 F4        	     1M 		hlt
                      	     2M 	
04:00000321 F4        	     1M 		hlt
                      	     2M 	
04:00000322 F4        	     1M 		hlt
                      	     2M 	
04:00000323 F4        	     1M 		hlt
                      	     2M 	
04:00000324 F4        	     1M 		hlt
                      	     2M 	
04:00000325 F4        	     1M 		hlt
                      	     2M 	
04:00000326 F4        	     1M 		hlt
                      	     2M 	
04:00000327 F4        	     1M 		hlt
                      	     2M 	
04:00000328 F4        	     1M 		hlt
                      	     2M 	
04:00000329 F4        	     1M 		hlt
                      	     2M 	
04:0000032A F4        	     1M 		hlt
                      	     2M 	
04:0000032B F4        	     1M 		hlt
                      	     2M 	
04:0000032C F4        	     1M 		hlt
                      	     2M 	
04:0000032D F4        	     1M 		hlt
                      	     2M 	
04:0000032E F4        	     1M 		hlt
                      	     2M 	
04:0000032F F4        	     1M 		hlt
                      	     2M 	
04:00000330 F4        	     1M 		hlt
                      	     2M 	
04:00000331 F4        	     1M 		hlt
                      	     2M 	
04:00000332 F4        	     1M 		hlt
                      	     2M 	
04:00000333 F4        	     1M 		hlt
                      	     2M 	
04:00000334 F4        	     1M 		hlt
                      	     2M 	
04:00000335 F4        	     1M 		hlt
                      	     2M 	
04:00000336 F4        	     1M 		hlt
                      	     2M 	
04:00000337 F4        	     1M 		hlt
                      	     2M 	
04:00000338 F4        	     1M 		hlt
                      	     2M 	
04:00000339 F4        	     1M 		hlt
                      	     2M 	
04:0000033A F4        	     1M 		hlt
                      	     2M 	
04:0000033B F4        	     1M 		hlt
                      	     2M 	
04:0000033C F4        	     1M 		hlt
                      	     2M 	
04:0000033D F4        	     1M 		hlt
                      	     2M 	
04:0000033E F4        	     1M 		hlt
                      	     2M 	
04:0000033F F4        	     1M 		hlt
                      	     2M 	
04:00000340 F4        	     1M 		hlt
                      	     2M 	
04:00000341 F4        	     1M 		hlt
                      	     2M 	
04:00000342 F4        	     1M 		hlt
                      	     2M 	
04:00000343 F4        	     1M 		hlt
                      	     2M 	
04:00000344 F4        	     1M 		hlt
                      	     2M 	
04:00000345 F4        	     1M 		hlt
                      	     2M 	
04:00000346 F4        	     1M 		hlt
                      	     2M 	
04:00000347 F4        	     1M 		hlt
                      	     2M 	
04:00000348 F4        	     1M 		hlt
                      	     2M 	
04:00000349 F4        	     1M 		hlt
                      	     2M 	
04:0000034A F4        	     1M 		hlt
                      	     2M 	
04:0000034B F4        	     1M 		hlt
                      	     2M 	
04:0000034C F4        	     1M 		hlt
                      	     2M 	
04:0000034D F4        	     1M 		hlt
                      	     2M 	
04:0000034E F4        	     1M 		hlt
                      	     2M 	
04:0000034F F4        	     1M 		hlt
                      	     2M 	
04:00000350 F4        	     1M 		hlt
                      	     2M 	
04:00000351 F4        	     1M 		hlt
                      	     2M 	
04:00000352 F4        	     1M 		hlt
                      	     2M 	
04:00000353 F4        	     1M 		hlt
                      	     2M 	
04:00000354 F4        	     1M 		hlt
                      	     2M 	
04:00000355 F4        	     1M 		hlt
                      	     2M 	
04:00000356 F4        	     1M 		hlt
                      	     2M 	
04:00000357 F4        	     1M 		hlt
                      	     2M 	
04:00000358 F4        	     1M 		hlt
                      	     2M 	
04:00000359 F4        	     1M 		hlt
                      	     2M 	
04:0000035A F4        	     1M 		hlt
                      	     2M 	
04:0000035B F4        	     1M 		hlt
                      	     2M 	
04:0000035C F4        	     1M 		hlt
                      	     2M 	
04:0000035D F4        	     1M 		hlt
                      	     2M 	
04:0000035E F4        	     1M 		hlt
                      	     2M 	
04:0000035F F4        	     1M 		hlt
                      	     2M 	
04:00000360 F4        	     1M 		hlt
                      	     2M 	
04:00000361 F4        	     1M 		hlt
                      	     2M 	
04:00000362 F4        	     1M 		hlt
                      	     2M 	
04:00000363 F4        	     1M 		hlt
                      	     2M 	
04:00000364 F4        	     1M 		hlt
                      	     2M 	
04:00000365 F4        	     1M 		hlt
                      	     2M 	
04:00000366 F4        	     1M 		hlt
                      	     2M 	
04:00000367 F4        	     1M 		hlt
                      	     2M 	
04:00000368 F4        	     1M 		hlt
                      	     2M 	
04:00000369 F4        	     1M 		hlt
                      	     2M 	
04:0000036A F4        	     1M 		hlt
                      	     2M 	
04:0000036B F4        	     1M 		hlt
                      	     2M 	
04:0000036C F4        	     1M 		hlt
                      	     2M 	
04:0000036D F4        	     1M 		hlt
                      	     2M 	
04:0000036E F4        	     1M 		hlt
                      	     2M 	
04:0000036F F4        	     1M 		hlt
                      	     2M 	
04:00000370 F4        	     1M 		hlt
                      	     2M 	
04:00000371 F4        	     1M 		hlt
                      	     2M 	
04:00000372 F4        	     1M 		hlt
                      	     2M 	
04:00000373 F4        	     1M 		hlt
                      	     2M 	
04:00000374 F4        	     1M 		hlt
                      	     2M 	
04:00000375 F4        	     1M 		hlt
                      	     2M 	
04:00000376 F4        	     1M 		hlt
                      	     2M 	
04:00000377 F4        	     1M 		hlt
                      	     2M 	
04:00000378 F4        	     1M 		hlt
                      	     2M 	
04:00000379 F4        	     1M 		hlt
                      	     2M 	
04:0000037A F4        	     1M 		hlt
                      	     2M 	
04:0000037B F4        	     1M 		hlt
                      	     2M 	
04:0000037C F4        	     1M 		hlt
                      	     2M 	
04:0000037D F4        	     1M 		hlt
                      	     2M 	
04:0000037E F4        	     1M 		hlt
                      	     2M 	
04:0000037F F4        	     1M 		hlt
                      	     2M 	
04:00000380 F4        	     1M 		hlt
                      	     2M 	
04:00000381 F4        	     1M 		hlt
                      	     2M 	
04:00000382 F4        	     1M 		hlt
                      	     2M 	
04:00000383 F4        	     1M 		hlt
                      	     2M 	
04:00000384 F4        	     1M 		hlt
                      	     2M 	
04:00000385 F4        	     1M 		hlt
                      	     2M 	
04:00000386 F4        	     1M 		hlt
                      	     2M 	
04:00000387 F4        	     1M 		hlt
                      	     2M 	
04:00000388 F4        	     1M 		hlt
                      	     2M 	
04:00000389 F4        	     1M 		hlt
                      	     2M 	
04:0000038A F4        	     1M 		hlt
                      	     2M 	
04:0000038B F4        	     1M 		hlt
                      	     2M 	
04:0000038C F4        	     1M 		hlt
                      	     2M 	
04:0000038D F4        	     1M 		hlt
                      	     2M 	
04:0000038E F4        	     1M 		hlt
                      	     2M 	
04:0000038F F4        	     1M 		hlt
                      	     2M 	
04:00000390 F4        	     1M 		hlt
                      	     2M 	
04:00000391 F4        	     1M 		hlt
                      	     2M 	
04:00000392 F4        	     1M 		hlt
                      	     2M 	
04:00000393 F4        	     1M 		hlt
                      	     2M 	
                      	   134M .endif
                      	   135M 
                      	   136M err211:
04:00000394 F4        	   137M 	hlt
                      	   138M 
                      	   139M # test negative offsets
04:00000395 0F8059FF  	   140M jook11:   jo   jnl11
04:00000399 0F8D5EFF  	   141M jnlok11:  jnl  jnle11
04:0000039D 0F8F63FF  	   142M jnleok11: jnle jl11
04:000003A1 0F8C67FF  	   143M jlok11:   jl   jle11
04:000003A5 0F8E68FF  	   144M jleok11:  jle  jcxz11
                      	   145M .if 16==8
                      	   146M jcxzok11:  jcxz  jecxz11
                      	   147M jecxzok11: jecxz jecxze11
                      	   148M .endif
                      	   149M 
                      	   150M exit11:
                      	   184: 
                      	   185: #
                      	   186: #   Loops
                      	   187: #
                      	   188: .include "loop_m.asm"

Source: "loop_m.asm"
                      	     1: #
                      	     2: #   Test of loop, loopz, loopnz
                      	     3: #   Use: EAX, ECX, Flags
                      	     4: #
                      	     5: 
                      	     6: .macro testLoop
                      	     7: 
                      	     8: 	mov $0x20000,%ecx
                      	     9: 	mov $0,%eax
                      	    10: loop16\@:
                      	    11: 	inc %eax
                      	    12: 	loopw loop16\@
                      	    13: 	cmp $0x10000,%eax
                      	    14: 	jne error
                      	    15: 	cmp $0x20000,%ecx
                      	    16: 	jne error
                      	    17: 
                      	    18: 	mov $0x20000,%ecx
                      	    19: 	mov $0,%eax
                      	    20: loop32\@:
                      	    21: 	inc %eax
                      	    22: 	loopl loop32\@
                      	    23: 	cmp $0x20000,%eax
                      	    24: 	jne error
                      	    25: 	cmp $0,%ecx
                      	    26: 	jne error
                      	    27: 
                      	    28: .endm
                      	    29: 
                      	    30: .macro testLoopZ
                      	    31: 
                      	    32: 	mov $0xFFFF,%cx
                      	    33: 	mov $0,%ax
                      	    34: loop16a\@:
                      	    35: 	inc %ax
                      	    36: 	cmp $0,%ah
                      	    37: 	loopzw loop16a\@
                      	    38: 	cmp $0x0100,%ax
                      	    39: 	jne error
                      	    40: 	cmp $0xFEFF,%cx
                      	    41: 	jne error
                      	    42: 
                      	    43: 	mov $0x00FF,%cx
                      	    44: 	mov $0,%ax
                      	    45: loop16b\@:
                      	    46: 	inc %ax
                      	    47: 	cmp $0,%ah
                      	    48: 	loopzw loop16b\@
                      	    49: 	cmp $0x00FF,%ax
                      	    50: 	jne error
                      	    51: 	cmp $0,%cx
                      	    52: 	jne error
                      	    53: 
                      	    54: 	mov $0x20000,%ecx
                      	    55: 	mov $0,%eax
                      	    56: loop32\@:
                      	    57: 	inc %eax
                      	    58: 	test $0x10000,%eax
                      	    59: 	loopzl loop32\@
                      	    60: 	cmp $0x10000,%eax
                      	    61: 	jne error
                      	    62: 	cmp $0x10000,%ecx
                      	    63: 	jne error
                      	    64: 
                      	    65: .endm
                      	    66: 
                      	    67: .macro testLoopNZ
                      	    68: 
                      	    69: 	mov $0xFFFF,%cx
                      	    70: 	mov $0,%ax
                      	    71: loop16a\@:
                      	    72: 	inc %ax
                      	    73: 	test $0xFF,%al
                      	    74: 	loopnzw loop16a\@
                      	    75: 	cmp $0x0100,%ax
                      	    76: 	jne error
                      	    77: 	cmp $0xFEFF,%cx
                      	    78: 	jne error
                      	    79: 
                      	    80: 	mov $0x00FF,%cx
                      	    81: 	mov $0,%ax
                      	    82: loop16b\@:
                      	    83: 	inc %ax
                      	    84: 	test $0xFF,%al
                      	    85: 	loopnzw loop16b\@
                      	    86: 	cmp $0x00FF,%ax
                      	    87: 	jne error
                      	    88: 	cmp $0,%cx
                      	    89: 	jne error
                      	    90: 
                      	    91: 	mov $0x10000,%ecx
                      	    92: 	mov $0,%eax
                      	    93: loop32\@:
                      	    94: 	inc %eax
                      	    95: 	test $0x0FFFF,%eax
                      	    96: 	loopnzl loop32\@
                      	    97: 	cmp $0x10000,%eax
                      	    98: 	jne error
                      	    99: 	cmp $0,%ecx
                      	   100: 	jne error
                      	   101: 
                      	   102: .endm

Source: "t386.asm"
                      	   189: #	testLoop
                      	   190: #	testLoopZ
                      	   191: #	testLoopNZ
                      	   192: 
                      	   193: #-------------------------------------------------------------------------------
                      	   194: 	POST $0x02
04:000003A9 B002      	     1M 	movb $0x02,%al
04:000003AB BA9001    	     2M 	movw $POST_PORT,%dx
04:000003AE EE        	     3M 	out %al,%dx
                      	   195: #-------------------------------------------------------------------------------
                      	   196: #
                      	   197: #   Quick tests of unsigned 32-bit multiplication and division
                      	   198: #   Thorough arithmetical and logical tests are done later
                      	   199: #
04:000003AF 66B8010000	   200: 	mov $0x80000001,%eax
04:000003B4 80
04:000003B5 66F7E8    	   201: 	imul %eax
04:000003B8 66B8112233	   202: 	mov $0x44332211,%eax
04:000003BD 44
04:000003BE 6689C3    	   203: 	mov %eax,%ebx
04:000003C1 66B9556677	   204: 	mov $0x88776655,%ecx
04:000003C6 88
04:000003C7 66F7E1    	   205: 	mul %ecx
04:000003CA 66F7F1    	   206: 	div %ecx
04:000003CD 6639D8    	   207: 	cmp %ebx,%eax
04:000003D0 0F85D920  	   208: 	jne error
                      	   209: 
                      	   210: .include "mov_m.asm"

Source: "mov_m.asm"
                      	     1: #
                      	     2: #   Tests MOV from segment registers in real mode
                      	     3: #
                      	     4: #   %1 the segment register to test
                      	     5: #
                      	     6: .macro testMovSegR_real arg1
                      	     7: 	.ifc \arg1, cs
                      	     8: 	mov $C_SEG_REAL,%dx
                      	     9: 	.else
                      	    10: 	mov $D1_SEG_REAL,%dx
                      	    11: 	.endif
                      	    12: 
                      	    13: 	# MOV reg to Sreg
                      	    14: 	.ifc \arg1, cs
                      	    15: 	realModeFaultTest EX_UD, "mov %dx", \arg1 # test for #UD
                      	    16: 	.else
                      	    17: 	mov %dx,%\arg1
                      	    18: 	.endif
                      	    19: 
                      	    20: 	# MOV Sreg to 16 bit reg
                      	    21: 	xor %ax,%ax
                      	    22: 	mov %\arg1,%ax
                      	    23: 	cmp %dx,%ax
                      	    24: 	jne error
                      	    25: 
                      	    26: 	# MOV Sreg to 32 bit reg
                      	    27: 	mov $-1,%eax
                      	    28: 	mov %\arg1,%eax
                      	    29: 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    30: 	# TODO: verify on real hw and check TEST_UNDEF
                      	    31: 	cmp %dx,%ax
                      	    32: 	jne error
                      	    33: 
                      	    34: 	# MOV Sreg to word mem
                      	    35: 	movw $0xbeef,0
                      	    36: 	mov %\arg1,0
                      	    37: 	cmp %dx,0
                      	    38: 	jne error
                      	    39: 
                      	    40: 	# MOV word mem to Sreg
                      	    41: 	.ifc \arg1, cs
                      	    42: 	realModeFaultTest EX_UD, "mov 0", \arg1 # test for #UD
                      	    43: 	.else
                      	    44: 	mov %ds,%cx	 	# save current DS in CX
                      	    45: 	xor %ax,%ax
                      	    46: 	mov %ax,%\arg1
                      	    47: 	.ifc \arg1, ds
                      	    48: 	mov %cx,%es
                      	    49: 	mov %es:0,%\arg1
                      	    50: 	.else
                      	    51: 	mov 0,%\arg1
                      	    52: 	.endif
                      	    53: 	mov %\arg1,%ax
                      	    54: 	cmp %dx,%ax
                      	    55: 	jne error
                      	    56: 	.endif
                      	    57: 
                      	    58: .endm
                      	    59: 
                      	    60: 
                      	    61: .macro testMovSegR_prot arg1
                      	    62: 	mov $-1,%edx
                      	    63: 	.ifc \arg1, cs
                      	    64: 	mov $C_SEG_PROT32,%dx
                      	    65: 	%else
                      	    66: 	mov $D1_SEG_PROT,%dx
                      	    67: 	%endif
                      	    68: 
                      	    69: 	# MOV reg to Sreg
                      	    70: 	.ifc \arg1, cs
                      	    71: 	loadProtModeStack
                      	    72: 	protModeFaultTest EX_UD, $0, "mov %dx", \arg1 	# #UD: attempt is made to load the CS register.
                      	    73: 	.else
                      	    74: 	mov %dx,%\arg1
                      	    75: 	.endif
                      	    76: 
                      	    77: 	# MOV Sreg to 16 bit reg
                      	    78: 	xor %ax,%ax
                      	    79: 	mov %\arg1,%ax
                      	    80: 	cmp %dx,%ax
                      	    81: 	jne error
                      	    82: 
                      	    83: 	# MOV Sreg to 32 bit reg
                      	    84: 	mov $-1,%eax
                      	    85: 	mov %\arg1,%eax
                      	    86: 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    87: 	# TODO: verify on real hw and check TEST_UNDEF
                      	    88: 	cmp %dx,%ax
                      	    89: 	jne error
                      	    90: 
                      	    91: 	# MOV Sreg to word mem
                      	    92: 	movl $-1,0
                      	    93: 	mov %\arg1,0
                      	    94: 	cmp %edx,0
                      	    95: 	jne error
                      	    96: 
                      	    97: 	# MOV word mem to Sreg
                      	    98: 	.ifc \arg1, cs
                      	    99: 	protModeFaultTest EX_UD, $0, "mov 0", \arg1 # test for #UD
                      	   100: 	.else
                      	   101: 	mov %ds,%cx 	# save current DS in CX
                      	   102: 	mov $DTEST_SEG_PROT,%ax
                      	   103: 	mov %ax,%\arg1
                      	   104: 	.ifc \arg1, ds
                      	   105: 	mov %cx,%es
                      	   106: 	mov %es:0,%\arg1
                      	   107: 	.else
                      	   108: 	mov 0,%\arg1
                      	   109: 	.endif
                      	   110: 	mov %\arg1,%ax
                      	   111: 	cmp %dx,%ax
                      	   112: 	jne error
                      	   113: 	.endif
                      	   114: 
                      	   115: 	loadProtModeStack
                      	   116: 	.ifc \arg1, ss
                      	   117: 	# #GP(0) If attempt is made to load SS register with NULL segment selector.
                      	   118: 	mov $NULL,%ax
                      	   119: 	protModeFaultTest EX_GP, $0, "mov %ax", \arg1
                      	   120: 	# #GP(selector) If the SS register is being loaded and the segment selector's RPL and the segment descriptor’s DPL are
                      	   121: 	mov $DPL1_SEG_PROT|1,%ax
                      	   122: 	protModeFaultTest EX_GP, $DPL1_SEG_PROT, "mov %ax" ,\arg1
                      	   123: 	# #GP(selector) If the SS register is being loaded and the segment pointed to is a non-writable data segment.
                      	   124: 	mov $RO_SEG_PROT,%ax
                      	   125: 	protModeFaultTest EX_GP, $RO_SEG_PROT, "mov %ax", \arg1
                      	   126: 	# #SS(selector) If the SS register is being loaded and the segment pointed to is marked not present.
                      	   127: 	mov $NP_SEG_PROT,%ax
                      	   128: 	protModeFaultTest EX_SS, $NP_SEG_PROT, "mov %ax", \arg1
                      	   129: 	.endif
                      	   130: 	.ifnc \arg1, cs
                      	   131: 	# #GP(selector) If segment selector index is outside descriptor table limits.
                      	   132: 	mov $0xFFF8,%ax
                      	   133: 	protModeFaultTest EX_GP, $0xfff8, "mov %ax", \arg1
                      	   134: 	.ifnc \arg1, ss
                      	   135: 	# #NP(selector) If the DS, ES, FS, or GS register is being loaded and the segment pointed to is marked not present.
                      	   136: 	mov $NP_SEG_PROT,%ax
                      	   137: 	protModeFaultTest EX_NP, $NP_SEG_PROT, "mov %ax", \arg1
                      	   138: 	# #GP(selector) If the DS, ES, FS, or GS register is being loaded and the segment pointed to is not a data or readable
                      	   139: 	mov $SYS_SEG_PROT,%ax
                      	   140: 	protModeFaultTest EX_GP, $SYS_SEG_PROT, "mov %ax", \arg1
                      	   141: 	# #GP(selector)
                      	   142: 	# If the DS, ES, FS, or GS register is being loaded and the segment pointed to is a data or nonconforming code segment
                      	   143: 	call switchToRing3 # CPL=3
                      	   144: 	mov $DTEST_SEG_PROT|3,%ax 	# RPL=3,DPL=0
                      	   145: 	protModeFaultTest EX_GP, $DTEST_SEG_PROT, "mov %ax", \arg1
                      	   146: 	call switchToRing0
                      	   147: 	.endif
                      	   148: 	.endif
                      	   149: 
                      	   150: .endm
                      	   151: 

Source: "t386.asm"
                      	   211: #-------------------------------------------------------------------------------
                      	   212: 	POST $0x03
04:000003D4 B003      	     1M 	movb $0x03,%al
04:000003D6 BA9001    	     2M 	movw $POST_PORT,%dx
04:000003D9 EE        	     3M 	out %al,%dx
                      	   213: #-------------------------------------------------------------------------------
                      	   214: #
                      	   215: #   Move segment registers in real mode
                      	   216: #
                      	   217: 	testMovSegR_real ss
                      	     1M 	.ifc ss, cs
                      	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
04:000003DA C7C200C0  	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc ss, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", ss # test for #UD
                      	    10M 	.else
04:000003DE 8ED2      	    11M 	mov %dx,%ss
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:000003E0 31C0      	    15M 	xor %ax,%ax
04:000003E2 8CD0      	    16M 	mov %ss,%ax
04:000003E4 39D0      	    17M 	cmp %dx,%ax
04:000003E6 0F85C320  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:000003EA 66B8FFFFFF	    21M 	mov $-1,%eax
04:000003EF FF
04:000003F0 668CD0    	    22M 	mov %ss,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:000003F3 39D0      	    25M 	cmp %dx,%ax
04:000003F5 0F85B420  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:000003F9 C7060000EF	    29M 	movw $0xbeef,0
04:000003FE BE
04:000003FF 8C160000  	    30M 	mov %ss,0
04:00000403 39160000  	    31M 	cmp %dx,0
04:00000407 0F85A220  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc ss, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", ss # test for #UD
                      	    37M 	.else
04:0000040B 8CD9      	    38M 	mov %ds,%cx	 	# save current DS in CX
04:0000040D 31C0      	    39M 	xor %ax,%ax
04:0000040F 8ED0      	    40M 	mov %ax,%ss
                      	    41M 	.ifc ss, ds
                      	    42M 	mov %cx,%es
                      	    43M 	mov %es:0,%ss
                      	    44M 	.else
04:00000411 8E160000  	    45M 	mov 0,%ss
                      	    46M 	.endif
04:00000415 8CD0      	    47M 	mov %ss,%ax
04:00000417 39D0      	    48M 	cmp %dx,%ax
04:00000419 0F859020  	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   218: 	testMovSegR_real ds
                      	     1M 	.ifc ds, cs
                      	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
04:0000041D C7C200C0  	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc ds, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", ds # test for #UD
                      	    10M 	.else
04:00000421 8EDA      	    11M 	mov %dx,%ds
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:00000423 31C0      	    15M 	xor %ax,%ax
04:00000425 8CD8      	    16M 	mov %ds,%ax
04:00000427 39D0      	    17M 	cmp %dx,%ax
04:00000429 0F858020  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:0000042D 66B8FFFFFF	    21M 	mov $-1,%eax
04:00000432 FF
04:00000433 668CD8    	    22M 	mov %ds,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:00000436 39D0      	    25M 	cmp %dx,%ax
04:00000438 0F857120  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:0000043C C7060000EF	    29M 	movw $0xbeef,0
04:00000441 BE
04:00000442 8C1E0000  	    30M 	mov %ds,0
04:00000446 39160000  	    31M 	cmp %dx,0
04:0000044A 0F855F20  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc ds, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", ds # test for #UD
                      	    37M 	.else
04:0000044E 8CD9      	    38M 	mov %ds,%cx	 	# save current DS in CX
04:00000450 31C0      	    39M 	xor %ax,%ax
04:00000452 8ED8      	    40M 	mov %ax,%ds
                      	    41M 	.ifc ds, ds
04:00000454 8EC1      	    42M 	mov %cx,%es
04:00000456 268E1E0000	    43M 	mov %es:0,%ds
                      	    44M 	.else
                      	    45M 	mov 0,%ds
                      	    46M 	.endif
04:0000045B 8CD8      	    47M 	mov %ds,%ax
04:0000045D 39D0      	    48M 	cmp %dx,%ax
04:0000045F 0F854A20  	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   219: 	testMovSegR_real es
                      	     1M 	.ifc es, cs
                      	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
04:00000463 C7C200C0  	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc es, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", es # test for #UD
                      	    10M 	.else
04:00000467 8EC2      	    11M 	mov %dx,%es
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:00000469 31C0      	    15M 	xor %ax,%ax
04:0000046B 8CC0      	    16M 	mov %es,%ax
04:0000046D 39D0      	    17M 	cmp %dx,%ax
04:0000046F 0F853A20  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:00000473 66B8FFFFFF	    21M 	mov $-1,%eax
04:00000478 FF
04:00000479 668CC0    	    22M 	mov %es,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:0000047C 39D0      	    25M 	cmp %dx,%ax
04:0000047E 0F852B20  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:00000482 C7060000EF	    29M 	movw $0xbeef,0
04:00000487 BE
04:00000488 8C060000  	    30M 	mov %es,0
04:0000048C 39160000  	    31M 	cmp %dx,0
04:00000490 0F851920  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc es, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", es # test for #UD
                      	    37M 	.else
04:00000494 8CD9      	    38M 	mov %ds,%cx	 	# save current DS in CX
04:00000496 31C0      	    39M 	xor %ax,%ax
04:00000498 8EC0      	    40M 	mov %ax,%es
                      	    41M 	.ifc es, ds
                      	    42M 	mov %cx,%es
                      	    43M 	mov %es:0,%es
                      	    44M 	.else
04:0000049A 8E060000  	    45M 	mov 0,%es
                      	    46M 	.endif
04:0000049E 8CC0      	    47M 	mov %es,%ax
04:000004A0 39D0      	    48M 	cmp %dx,%ax
04:000004A2 0F850720  	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   220: 	testMovSegR_real fs
                      	     1M 	.ifc fs, cs
                      	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
04:000004A6 C7C200C0  	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc fs, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", fs # test for #UD
                      	    10M 	.else
04:000004AA 8EE2      	    11M 	mov %dx,%fs
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:000004AC 31C0      	    15M 	xor %ax,%ax
04:000004AE 8CE0      	    16M 	mov %fs,%ax
04:000004B0 39D0      	    17M 	cmp %dx,%ax
04:000004B2 0F85F71F  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:000004B6 66B8FFFFFF	    21M 	mov $-1,%eax
04:000004BB FF
04:000004BC 668CE0    	    22M 	mov %fs,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:000004BF 39D0      	    25M 	cmp %dx,%ax
04:000004C1 0F85E81F  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:000004C5 C7060000EF	    29M 	movw $0xbeef,0
04:000004CA BE
04:000004CB 8C260000  	    30M 	mov %fs,0
04:000004CF 39160000  	    31M 	cmp %dx,0
04:000004D3 0F85D61F  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc fs, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", fs # test for #UD
                      	    37M 	.else
04:000004D7 8CD9      	    38M 	mov %ds,%cx	 	# save current DS in CX
04:000004D9 31C0      	    39M 	xor %ax,%ax
04:000004DB 8EE0      	    40M 	mov %ax,%fs
                      	    41M 	.ifc fs, ds
                      	    42M 	mov %cx,%es
                      	    43M 	mov %es:0,%fs
                      	    44M 	.else
04:000004DD 8E260000  	    45M 	mov 0,%fs
                      	    46M 	.endif
04:000004E1 8CE0      	    47M 	mov %fs,%ax
04:000004E3 39D0      	    48M 	cmp %dx,%ax
04:000004E5 0F85C41F  	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   221: 	testMovSegR_real gs
                      	     1M 	.ifc gs, cs
                      	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
04:000004E9 C7C200C0  	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc gs, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", gs # test for #UD
                      	    10M 	.else
04:000004ED 8EEA      	    11M 	mov %dx,%gs
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:000004EF 31C0      	    15M 	xor %ax,%ax
04:000004F1 8CE8      	    16M 	mov %gs,%ax
04:000004F3 39D0      	    17M 	cmp %dx,%ax
04:000004F5 0F85B41F  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:000004F9 66B8FFFFFF	    21M 	mov $-1,%eax
04:000004FE FF
04:000004FF 668CE8    	    22M 	mov %gs,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:00000502 39D0      	    25M 	cmp %dx,%ax
04:00000504 0F85A51F  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:00000508 C7060000EF	    29M 	movw $0xbeef,0
04:0000050D BE
04:0000050E 8C2E0000  	    30M 	mov %gs,0
04:00000512 39160000  	    31M 	cmp %dx,0
04:00000516 0F85931F  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc gs, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", gs # test for #UD
                      	    37M 	.else
04:0000051A 8CD9      	    38M 	mov %ds,%cx	 	# save current DS in CX
04:0000051C 31C0      	    39M 	xor %ax,%ax
04:0000051E 8EE8      	    40M 	mov %ax,%gs
                      	    41M 	.ifc gs, ds
                      	    42M 	mov %cx,%es
                      	    43M 	mov %es:0,%gs
                      	    44M 	.else
04:00000520 8E2E0000  	    45M 	mov 0,%gs
                      	    46M 	.endif
04:00000524 8CE8      	    47M 	mov %gs,%ax
04:00000526 39D0      	    48M 	cmp %dx,%ax
04:00000528 0F85811F  	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   222: 	testMovSegR_real cs
                      	     1M 	.ifc cs, cs
04:0000052C BA00F0    	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
                      	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc cs, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", cs # test for #UD
                      	     1M 	realModeExcInit EX_UD,continue25
04:0000052F B80090    	     1M 	mov $IDT_SEG_REAL,%ax
04:00000532 8ED8      	     2M 	mov %ax,%ds
04:00000534 C70618004D	     3M 	movw $continue25,EX_UD*4
04:00000539 05
04:0000053A C7061A0000	     4M 	movw $C_SEG_REAL,EX_UD*4+2
04:0000053F F0
04:00000540 B800C0    	     2M 	mov $S_SEG_REAL,%ax
04:00000543 8ED0      	     3M 	mov %ax,%ss
04:00000545 BCFC7F    	     4M 	mov $ESP_REAL,%sp
                      	     5M test25:
04:00000548 8ECA      	     6M 	mov %dx,%cs
04:0000054A E9601F    	     7M 	jmp error
                      	     8M continue25:
                      	     9M 	realModeExcCheck EX_UD,test25
04:0000054D 81FCF67F  	     1M 	cmp $ESP_REAL-6,%sp
04:00000551 0F85581F  	     2M 	jne error
04:00000555 36813EF87F	     3M 	cmpw $C_SEG_REAL,%ss:ESP_REAL-4
04:0000055A 00F0
04:0000055C 0F854D1F  	     4M 	jne error
04:00000560 36813EF67F	     5M 	cmpw $test25,%ss:ESP_REAL-6
04:00000565 4805
04:00000567 0F85421F  	     6M 	jne error
04:0000056B B80000    	     7M 	mov $0,%ax
04:0000056E 8ED8      	     8M 	mov %ax,%ds
04:00000570 C7061800AD	     9M 	movw $error,EX_UD*4
04:00000575 24
04:00000576 C7061A0000	    10M 	movw $C_SEG_REAL,EX_UD*4+2
04:0000057B F0
                      	    10M 	.else
                      	    11M 	mov %dx,%cs
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:0000057C 31C0      	    15M 	xor %ax,%ax
04:0000057E 8CC8      	    16M 	mov %cs,%ax
04:00000580 39D0      	    17M 	cmp %dx,%ax
04:00000582 0F85271F  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:00000586 66B8FFFFFF	    21M 	mov $-1,%eax
04:0000058B FF
04:0000058C 668CC8    	    22M 	mov %cs,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:0000058F 39D0      	    25M 	cmp %dx,%ax
04:00000591 0F85181F  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:00000595 C7060000EF	    29M 	movw $0xbeef,0
04:0000059A BE
04:0000059B 8C0E0000  	    30M 	mov %cs,0
04:0000059F 39160000  	    31M 	cmp %dx,0
04:000005A3 0F85061F  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc cs, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", cs # test for #UD
                      	     1M 	realModeExcInit EX_UD,continue28
04:000005A7 B80090    	     1M 	mov $IDT_SEG_REAL,%ax
04:000005AA 8ED8      	     2M 	mov %ax,%ds
04:000005AC C7061800C7	     3M 	movw $continue28,EX_UD*4
04:000005B1 05
04:000005B2 C7061A0000	     4M 	movw $C_SEG_REAL,EX_UD*4+2
04:000005B7 F0
04:000005B8 B800C0    	     2M 	mov $S_SEG_REAL,%ax
04:000005BB 8ED0      	     3M 	mov %ax,%ss
04:000005BD BCFC7F    	     4M 	mov $ESP_REAL,%sp
                      	     5M test28:
04:000005C0 8E0E0000  	     6M 	mov 0,%cs
04:000005C4 E9E61E    	     7M 	jmp error
                      	     8M continue28:
                      	     9M 	realModeExcCheck EX_UD,test28
04:000005C7 81FCF67F  	     1M 	cmp $ESP_REAL-6,%sp
04:000005CB 0F85DE1E  	     2M 	jne error
04:000005CF 36813EF87F	     3M 	cmpw $C_SEG_REAL,%ss:ESP_REAL-4
04:000005D4 00F0
04:000005D6 0F85D31E  	     4M 	jne error
04:000005DA 36813EF67F	     5M 	cmpw $test28,%ss:ESP_REAL-6
04:000005DF C005
04:000005E1 0F85C81E  	     6M 	jne error
04:000005E5 B80000    	     7M 	mov $0,%ax
04:000005E8 8ED8      	     8M 	mov %ax,%ds
04:000005EA C7061800AD	     9M 	movw $error,EX_UD*4
04:000005EF 24
04:000005F0 C7061A0000	    10M 	movw $C_SEG_REAL,EX_UD*4+2
04:000005F5 F0
                      	    37M 	.else
                      	    38M 	mov %ds,%cx	 	# save current DS in CX
                      	    39M 	xor %ax,%ax
                      	    40M 	mov %ax,%cs
                      	    41M 	.ifc cs, ds
                      	    42M 	mov %cx,%es
                      	    43M 	mov %es:0,%cs
                      	    44M 	.else
                      	    45M 	mov 0,%cs
                      	    46M 	.endif
                      	    47M 	mov %cs,%ax
                      	    48M 	cmp %dx,%ax
                      	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   223: 
                      	   224: 	advTestSegReal
                      	     1M 	advTestBase
                      	     1M 	.set TEST_BASE1,TEST_BASE1+0x1000
                      	     2M 	.set TEST_BASE2,TEST_BASE2+0x1000
                      	     2M 	.set D1_SEG_REAL,TEST_BASE1 >> 4
                      	     3M 	.set D2_SEG_REAL,TEST_BASE2 >> 4
04:000005F6 C7C200C1  	     4M 	mov $D1_SEG_REAL,%dx
04:000005FA 8EDA      	     5M 	mov %dx,%ds
04:000005FC C7C200C3  	     6M 	mov $D2_SEG_REAL,%dx
04:00000600 8EC2      	     7M 	mov %dx,%es
                      	   225: 
                      	   226: .include "string_m.asm"

Source: "string_m.asm"
                      	     1: #
                      	     2: #   Tests store, compare, scan, and move string operands
                      	     3: #   %1 data size b=byte, w=word, d=dword
                      	     4: #   %2 direction 0=increment, 1=decrement
                      	     5: #   %3 addressing a16=16-bit, a32=32-bit
                      	     6: #   DS test segment 1
                      	     7: #   ES test segment 2
                      	     8: #
                      	     9: .macro testStringOps arg1,arg2,arg3
                      	    10: 
                      	    11: 	.set value,0x12345678
                      	    12: 	.if \arg1 = b
                      	    13: 		.set val_size,1
                      	    14: 		.set val_mask,0x000000ff
                      	    15: 	.endif
                      	    16: 	.if \arg1 = w
                      	    17: 		.set val_size,2
                      	    18: 		.set val_mask,0x0000ffff
                      	    19: 	.endif
                      	    20: 	.if \arg1 = d
                      	    21: 		.set val_size,4
                      	    22: 		.set val_mask,0xffffffff
                      	    23: 	.endif
                      	    24: 
                      	    25: 	.if \arg2 == 0
                      	    26: 		cld
                      	    27: 		.set off_value,0x0001ffff-(val_size-1)
                      	    28: 		.if \arg3 = 16
                      	    29: 			# 16-bit addressing
                      	    30: 			.set off_cmp,0x00010000
                      	    31: 		.else
                      	    32: 			# 32-bit addressing
                      	    33: 			.set off_cmp,0x00020000
                      	    34: 		.endif
                      	    35: 	.else
                      	    36: 		std
                      	    37: 		.set off_value,0x00010000
                      	    38: 		.if \arg3 = 16
                      	    39: 			# 16-bit addressing
                      	    40: 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    41: 		.else
                      	    42: 			# 32-bit addressing
                      	    43: 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    44: 		.endif
                      	    45: 	.endif
                      	    46: 
                      	    47: 	.if \arg3 = 16
                      	    48: 		.set off_mask,0x0000ffff
                      	    49: 	.else
                      	    50: 		.set off_mask,0xffffffff
                      	    51: 	.endif
                      	    52: 
                      	    53: 	# VERIFY string operands
                      	    54: 	.if \arg1 = b
                      	    55: 		mov $off_value,%edi
                      	    56: 		mov $off_value & off_mask,%ebx
                      	    57: 		mov $0,%al
                      	    58: 		mov %al,%es:(%ebx)
                      	    59: 		mov $value,%al
                      	    60: #		addr\arg3
                      	    61: 		stosb		 	# STORE EAX in ES:EDI
                      	    62: 		.if \arg3 = 16
                      	    63: 			cmp %al,%es:(%ebx)
                      	    64: 		.else
                      	    65: 			cmp %al,%es:(%ebx)
                      	    66: 		.endif
                      	    67: 		jne error
                      	    68: 		cmp $off_cmp,%edi
                      	    69: 		jne error
                      	    70: 
                      	    71: 		mov $off_value,%esi
                      	    72: 		mov $off_value,%edi
                      	    73: 		mov $off_value & off_mask,%ebx
                      	    74: 		mov %al,%ds:(%ebx)
                      	    75: 		mov %al,%es:(%ebx)
                      	    76: 		cmp $0,%al
                      	    77: 		je error
                      	    78: #		addr\arg3
                      	    79: 		cmpsb     # COMPARE ES:EDI with DS:ESI
                      	    80: 		jne error
                      	    81: 		cmp $off_cmp,%edi
                      	    82: 		jne error
                      	    83: 		cmp $off_cmp,%esi
                      	    84: 		jne error
                      	    85: 
                      	    86: 		mov $off_value,%edi
                      	    87: 		mov $value,%al
                      	    88: 		mov %al,%es:(%ebx)
                      	    89: 		cmp $0,%al
                      	    90: #		addr\arg3
                      	    91: 		scasb     # SCAN/COMPARE ES:EDI with EAX
                      	    92: 		jne error
                      	    93: 		cmp $off_cmp,%edi
                      	    94: 		jne error
                      	    95: 
                      	    96: 		mov $off_value,%esi
                      	    97: 		mov $off_value,%edi
                      	    98: 		mov $value,%al
                      	    99: 		mov %al,%ds:(%ebx)
                      	   100: 		mov $0,%al
                      	   101: 		mov %al,%es:(%ebx)
                      	   102: #		addr\arg3
                      	   103: 		movsb        # MOVE data from DS:ESI to ES:EDI
                      	   104: 		mov $value,%al
                      	   105: 		.if \arg3 = 16
                      	   106: 			cmp %al,%es:(%ebx)
                      	   107: 		.else
                      	   108: 			cmp %al,%es:(%ebx)
                      	   109: 		.endif
                      	   110: 		jne error
                      	   111: 		cmp $off_cmp,%edi
                      	   112: 		jne error
                      	   113: 		cmp $off_cmp,%esi
                      	   114: 		jne error
                      	   115: 
                      	   116: 		mov $off_value,%esi
                      	   117: 		mov $value,%al
                      	   118: 		mov %al,%es:(%ebx)
                      	   119: 		xor %eax,%eax
                      	   120: #		addr\arg3
                      	   121: 		lodsb       # LOAD data from DS:ESI into EAX
                      	   122: 		cmp $value & val_mask,%al
                      	   123: 		jne error
                      	   124: 		cmp $off_cmp,%esi
                      	   125: 		jne error
                      	   126: 	.endif
                      	   127: 
                      	   128: 	.if \arg1 = w
                      	   129: 		mov $off_value,%edi
                      	   130: 		mov $off_value & off_mask,%ebx
                      	   131: 		mov $0,%ax
                      	   132: 		mov %ax,%es:(%ebx)
                      	   133: 		mov $value,%ax
                      	   134: #		addr\arg3
                      	   135: 		stosw     # STORE EAX in ES:EDI
                      	   136: 		.if \arg3 = 16
                      	   137: 			cmp %ax,%es:(%ebx)
                      	   138: 		.else
                      	   139: 			cmp %ax,%es:(%ebx)
                      	   140: 		.endif
                      	   141: 		jne error
                      	   142: 		cmp $off_cmp,%edi
                      	   143: 		jne error
                      	   144: 
                      	   145: 		mov $off_value,%esi
                      	   146: 		mov $off_value,%edi
                      	   147: 		mov $off_value & off_mask,%ebx
                      	   148: 		mov %ax,%ds:(%ebx)
                      	   149: 		mov %ax,%es:(%ebx)
                      	   150: 		cmp $0,%ax
                      	   151: 		je error
                      	   152: #		addr\arg3
                      	   153: 		cmpsw     # COMPARE ES:EDI with DS:ESI
                      	   154: 		jne error
                      	   155: 		cmp $off_cmp,%edi
                      	   156: 		jne error
                      	   157: 		cmp $off_cmp,%esi
                      	   158: 		jne error
                      	   159: 
                      	   160: 		mov $off_value,%edi
                      	   161: 		mov $value,%ax
                      	   162: 		mov %ax,%es:(%ebx)
                      	   163: 		cmp $0,%ax
                      	   164: #		addr\arg3
                      	   165: 		scasw     # SCAN/COMPARE ES:EDI with EAX
                      	   166: 		jne error
                      	   167: 		cmp $off_cmp,%edi
                      	   168: 		jne error
                      	   169: 
                      	   170: 		mov $off_value,%esi
                      	   171: 		mov $off_value,%edi
                      	   172: 		mov $value,%ax
                      	   173: 		mov %ax,%ds:(%ebx)
                      	   174: 		mov $0,%ax
                      	   175: 		mov %ax,%es:(%ebx)
                      	   176: #		addr\arg3
                      	   177: 		movsw 					# MOVE data from DS:ESI to ES:EDI
                      	   178: 		mov $value,%ax
                      	   179: 		.if \arg3 = 16
                      	   180: 			cmp %ax,%es:(%ebx)
                      	   181: 		.else
                      	   182: 			cmp %ax,%es:(%ebx)
                      	   183: 		.endif
                      	   184: 		jne error
                      	   185: 		cmp $off_cmp,%edi
                      	   186: 		jne error
                      	   187: 		cmp $off_cmp,%esi
                      	   188: 		jne error
                      	   189: 
                      	   190: 		mov $off_value,%esi
                      	   191: 		mov $value,%ax
                      	   192: 		mov %ax,%es:(%ebx)
                      	   193: 		xor %eax,%eax
                      	   194: #		addr\arg3
                      	   195: 		lodsw       # LOAD data from DS:ESI into EAX
                      	   196: 		cmp $value & val_mask,%ax
                      	   197: 		jne error
                      	   198: 		cmp $off_cmp,%esi
                      	   199: 		jne error
                      	   200: 	.endif
                      	   201: 
                      	   202: 	.if \arg1 = d
                      	   203: 		mov $off_value,%edi
                      	   204: 		mov $off_value & off_mask,%ebx
                      	   205: 		mov $0,%eax
                      	   206: 		mov %eax,%es:(%ebx)
                      	   207: 		mov $value,%eax
                      	   208: #		addr\arg3
                      	   209: 		stosl     # STORE EAX in ES:EDI
                      	   210: 		.if \arg3 = 16
                      	   211: 			cmp %eax,%es:(%ebx)
                      	   212: 		.else
                      	   213: 			cmp %eax,%es:(%ebx)
                      	   214: 		.endif
                      	   215: 		jne error
                      	   216: 		cmp $off_cmp,%edi
                      	   217: 		jne error
                      	   218: 
                      	   219: 		mov $off_value,%esi
                      	   220: 		mov $off_value,%edi
                      	   221: 		mov $off_value & off_mask,%ebx
                      	   222: 		mov %eax,%ds:(%ebx)
                      	   223: 		mov %eax,%es:(%ebx)
                      	   224: 		cmp $0,%eax
                      	   225: 		je error
                      	   226: #		addr\arg3
                      	   227: 		cmpsl     # COMPARE ES:EDI with DS:ESI
                      	   228: 		jne error
                      	   229: 		cmp $off_cmp,%edi
                      	   230: 		jne error
                      	   231: 		cmp $off_cmp,%esi
                      	   232: 		jne error
                      	   233: 
                      	   234: 		mov $off_value,%edi
                      	   235: 		mov $value,%eax
                      	   236: 		mov %eax,%es:(%ebx)
                      	   237: 		cmp $0,%eax
                      	   238: #		addr\arg3
                      	   239: 		scasl     # SCAN/COMPARE ES:EDI with EAX
                      	   240: 		jne error
                      	   241: 		cmp $off_cmp,%edi
                      	   242: 		jne error
                      	   243: 
                      	   244: 		mov $off_value,%esi
                      	   245: 		mov $off_value,%edi
                      	   246: 		mov $value,%eax
                      	   247: 		mov %eax,%ds:(%ebx)
                      	   248: 		mov $0,%eax
                      	   249: 		mov %eax,%es:(%ebx)
                      	   250: #		addr\arg3
                      	   251: 		movsl        # MOVE data from DS:ESI to ES:EDI
                      	   252: 		mov $value,%eax
                      	   253: 		.if \arg3 = 16
                      	   254: 			cmp %eax,%es:(%ebx)
                      	   255: 		.else
                      	   256: 			cmp %eax,%es:(%ebx)
                      	   257: 		.endif
                      	   258: 		jne error
                      	   259: 		cmp $off_cmp,%edi
                      	   260: 		jne error
                      	   261: 		cmp $off_cmp,%esi
                      	   262: 		jne error
                      	   263: 
                      	   264: 		mov $off_value,%esi
                      	   265: 		mov $value,%eax
                      	   266: 		mov %eax,%es:(%ebx)
                      	   267: 		xor %eax,%eax
                      	   268: #		addr\arg3
                      	   269: 		lodsl       # LOAD data from DS:ESI into EAX
                      	   270: 		cmp $value & val_mask,%eax
                      	   271: 		jne error
                      	   272: 		cmp $off_cmp,%esi
                      	   273: 		jne error
                      	   274: 	.endif
                      	   275: 
                      	   276: .endm
                      	   277: 
                      	   278: #
                      	   279: #   Tests store, compare, scan, and move string operands with repetitions
                      	   280: #   %1 element size b=byte, w=word, d=dword
                      	   281: #   %2 direction 0=increment, 1=decrement
                      	   282: #   %3 addressing a16=16-bit, a32=32-bit
                      	   283: #   DS test segment 1
                      	   284: #   ES test segment 2
                      	   285: #
                      	   286: .macro testStringReps arg1,arg2,arg3
                      	   287: 
                      	   288: 	.set bytes,0x100
                      	   289: 
                      	   290: 	.if \arg1 = b
                      	   291: 		.set items,bytes
                      	   292: 	.endif
                      	   293: 	.if \arg1 = w
                      	   294: 		.set items,bytes/2
                      	   295: 	.endif
                      	   296: 	.if \arg1 = d
                      	   297: 		.set items,bytes/4
                      	   298: 	.endif
                      	   299: 
                      	   300: 	.if \arg2 == 0
                      	   301: 		cld
                      	   302: 		.set off_value,0x0001ff00
                      	   303: 		.if \arg3 = 16
                      	   304: 			# 16-bit addressing
                      	   305: 			.set off_cmp,0x00010000
                      	   306: 		.else
                      	   307: 			# 32-bit addressing
                      	   308: 			.set off_cmp,0x00020000
                      	   309: 		.endif
                      	   310: 	.else
                      	   311: 		std
                      	   312: 		.set off_value,0x000100ff
                      	   313: 		.if \arg3 = 16
                      	   314: 			# 16-bit addressing
                      	   315: 			.set off_cmp,0x0001ffff
                      	   316: 		.else
                      	   317: 			# 32-bit addressing
                      	   318: 			.set off_cmp,0x0000ffff
                      	   319: 		.endif
                      	   320: 	.endif
                      	   321: 
                      	   322: 	mov $0x12345678,%eax
                      	   323: 	mov $off_value,%esi
                      	   324: 	mov $off_value,%edi
                      	   325: 
                      	   326: 	# VERIFY REPs on memory buffers
                      	   327: 
                      	   328: 	# STORE buffers with pattern in EAX
                      	   329: 	mov $0x12345678,%eax
                      	   330: 	mov $off_value,%esi
                      	   331: 	mov $off_value,%edi
                      	   332: 	mov $items,%ecx
                      	   333: 	.if \arg1 = b
                      	   334: #		addr\arg3
                      	   335: 		rep
                      	   336: 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	   337: 	.endif
                      	   338: 	.if \arg1 = w
                      	   339: #		addr\arg3
                      	   340: 		rep
                      	   341: 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	   342: 	.endif
                      	   343: 	.if \arg1 = d
                      	   344: #		addr\arg3
                      	   345: 		rep
                      	   346: 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	   347: 	.endif
                      	   348: 	cmp $0,%ecx
                      	   349: 	jnz error           		# ECX must be 0
                      	   350: 	cmp $off_cmp,%edi
                      	   351: 	jnz error
                      	   352: 	mov $off_value,%edi  # reset EDI
                      	   353: 	# now switch ES:EDI with DS:ESI
                      	   354: 	mov %es,%dx
                      	   355: 	mov %ds,%cx
                      	   356: 	xchg %cx,%dx
                      	   357: 	mov %dx,%es
                      	   358: 	mov %cx,%ds
                      	   359: 	xchg %esi,%edi
                      	   360: 	# store again ES:EDI with pattern in EAX
                      	   361: 	mov $items,%ecx      	# reset ECX
                      	   362: 	.if \arg1 = b
                      	   363: #		addr\arg3
                      	   364: 		rep
                      	   365: 		stosb
                      	   366: 	.endif
                      	   367: 	.if \arg1 = w
                      	   368: #		addr\arg3
                      	   369: 		rep
                      	   370: 		stosw
                      	   371: 	.endif
                      	   372: 	.if \arg1 = d
                      	   373: #		addr\arg3
                      	   374: 		rep
                      	   375: 		stosl
                      	   376: 	.endif
                      	   377: 	mov $off_value,%edi  	# reset EDI
                      	   378: 
                      	   379: 	# COMPARE two buffers
                      	   380: 	mov $items,%ecx      # reset ECX
                      	   381: 	.if \arg1 = b
                      	   382: #		addr\arg3
                      	   383: 		repe
                      	   384: 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	   385: 	.endif
                      	   386: 	.if \arg1 = w
                      	   387: #		addr\arg3
                      	   388: 		repe
                      	   389: 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   390: 	.endif
                      	   391: 	.if \arg1 = d
                      	   392: #		addr\arg3
                      	   393: 		repe
                      	   394: 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   395: 	.endif
                      	   396: 	cmp $0,%ecx
                      	   397: 	jnz error           		# ECX must be 0
                      	   398: 	cmp $off_cmp,%esi
                      	   399: 	jne error
                      	   400: 	cmp $off_cmp,%edi
                      	   401: 	jne error
                      	   402: 	mov $off_value,%edi  # reset EDI
                      	   403: 	mov $off_value,%esi  # reset ESI
                      	   404: 
                      	   405: 	# SCAN buffer for pattern
                      	   406: 	mov $items,%ecx      # reset ECX
                      	   407: 	.if \arg1 = b
                      	   408: #		addr\arg3
                      	   409: 		repe
                      	   410: 		scasb         # SCAN first dword not equal to EAX
                      	   411: 	.endif
                      	   412: 	.if \arg1 = w
                      	   413: #		addr\arg3
                      	   414: 		repe
                      	   415: 		scasw         # SCAN first dword not equal to EAX
                      	   416: 	.endif
                      	   417: 	.if \arg1 = d
                      	   418: #		addr\arg3
                      	   419: 		repe
                      	   420: 		scasl         # SCAN first dword not equal to EAX
                      	   421: 	.endif
                      	   422: 	cmp $0,%ecx
                      	   423: 	jne error           		# ECX must be 0
                      	   424: 	cmp $off_cmp,%edi
                      	   425: 	jne error
                      	   426: 	mov $off_value,%edi  		# rewind EDI
                      	   427: 
                      	   428: 	# MOVE and COMPARE data between buffers
                      	   429: 	# first zero-fill ES:EDI so that we can compare the moved data later
                      	   430: 	mov $0,%eax
                      	   431: 	mov $items,%ecx      # reset ECX
                      	   432: 	.if \arg1 = b
                      	   433: #		addr\arg3
                      	   434: 		rep
                      	   435: 		stosb          # zero fill ES:EDI
                      	   436: 	.endif
                      	   437: 	.if \arg1 = w
                      	   438: #		addr\arg3
                      	   439: 		rep
                      	   440: 		stosw          # zero fill ES:EDI
                      	   441: 	.endif
                      	   442: 	.if \arg1 = d
                      	   443: #		addr\arg3
                      	   444: 		rep
                      	   445: 		stosl          # zero fill ES:EDI
                      	   446: 	.endif
                      	   447: 	mov $off_value,%edi  # reset EDI
                      	   448: 	mov $items,%ecx      # reset ECX
                      	   449: 	.if \arg1 = b
                      	   450: #		addr\arg3
                      	   451: 		rep
                      	   452: 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   453: 	.endif
                      	   454: 	.if \arg1 = w
                      	   455: #		addr\arg3
                      	   456: 		rep
                      	   457: 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   458: 	.endif
                      	   459: 	.if \arg1 = d
                      	   460: #		addr\arg3
                      	   461: 		rep
                      	   462: 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   463: 	.endif
                      	   464: 	cmp $0,%ecx
                      	   465: 	jne error           	# ECX must be 0
                      	   466: 	cmp $off_cmp,%esi
                      	   467: 	jne error
                      	   468: 	cmp $off_cmp,%edi
                      	   469: 	jne error
                      	   470: 	mov $items,%ecx      	# reset ECX
                      	   471: 	mov $off_value,%edi  	# reset EDI
                      	   472: 	mov $off_value,%esi  	# reset ESI
                      	   473: 	.if \arg1 = b
                      	   474: #		addr\arg3
                      	   475: 		repe
                      	   476: 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   477: 	.endif
                      	   478: 	.if \arg1 = w
                      	   479: #		addr\arg3
                      	   480: 		repe
                      	   481: 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   482: 	.endif
                      	   483: 	.if \arg1 = d
                      	   484: #		addr\arg3
                      	   485: 		repe
                      	   486: 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   487: 	.endif
                      	   488: 	cmp $0,%ecx
                      	   489: 	jne error           # ECX must be 0
                      	   490: 	cmp $off_cmp,%esi
                      	   491: 	jne error
                      	   492: 	cmp $off_cmp,%edi
                      	   493: 	jne error
                      	   494: .endm
                      	   495: 

Source: "t386.asm"
                      	   227: #-------------------------------------------------------------------------------
                      	   228: 	POST $0x04
04:00000602 B004      	     1M 	movb $0x04,%al
04:00000604 BA9001    	     2M 	movw $POST_PORT,%dx
04:00000607 EE        	     3M 	out %al,%dx
                      	   229: #-------------------------------------------------------------------------------
                      	   230: #
                      	   231: #   Test store, move, scan, and compare string data
                      	   232: #
                      	   233: .set b,0
                      	   234: .set w,1
                      	   235: .set d,2
                      	   236: 
                      	   237: 	testStringOps b,0,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if b = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if b = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if b = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 0 == 0
04:00000608 FC        	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
                      	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if b = b
04:00000609 66BFFFFF01	    46M 		mov $off_value,%edi
04:0000060E 00
04:0000060F 66BBFFFF00	    47M 		mov $off_value & off_mask,%ebx
04:00000614 00
04:00000615 B000      	    48M 		mov $0,%al
04:00000617 67268803  	    49M 		mov %al,%es:(%ebx)
04:0000061B C6C078    	    50M 		mov $value,%al
                      	    51M #		addr16
04:0000061E AA        	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
04:0000061F 67263803  	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
04:00000623 0F85861E  	    58M 		jne error
04:00000627 6681FF0000	    59M 		cmp $off_cmp,%edi
04:0000062C 0100
04:0000062E 0F857B1E  	    60M 		jne error
                      	    61M 
04:00000632 66BEFFFF01	    62M 		mov $off_value,%esi
04:00000637 00
04:00000638 66BFFFFF01	    63M 		mov $off_value,%edi
04:0000063D 00
04:0000063E 66BBFFFF00	    64M 		mov $off_value & off_mask,%ebx
04:00000643 00
04:00000644 678803    	    65M 		mov %al,%ds:(%ebx)
04:00000647 67268803  	    66M 		mov %al,%es:(%ebx)
04:0000064B 3C00      	    67M 		cmp $0,%al
04:0000064D 0F845C1E  	    68M 		je error
                      	    69M #		addr16
04:00000651 A6        	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
04:00000652 0F85571E  	    71M 		jne error
04:00000656 6681FF0000	    72M 		cmp $off_cmp,%edi
04:0000065B 0100
04:0000065D 0F854C1E  	    73M 		jne error
04:00000661 6681FE0000	    74M 		cmp $off_cmp,%esi
04:00000666 0100
04:00000668 0F85411E  	    75M 		jne error
                      	    76M 
04:0000066C 66BFFFFF01	    77M 		mov $off_value,%edi
04:00000671 00
04:00000672 C6C078    	    78M 		mov $value,%al
04:00000675 67268803  	    79M 		mov %al,%es:(%ebx)
04:00000679 3C00      	    80M 		cmp $0,%al
                      	    81M #		addr16
04:0000067B AE        	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
04:0000067C 0F852D1E  	    83M 		jne error
04:00000680 6681FF0000	    84M 		cmp $off_cmp,%edi
04:00000685 0100
04:00000687 0F85221E  	    85M 		jne error
                      	    86M 
04:0000068B 66BEFFFF01	    87M 		mov $off_value,%esi
04:00000690 00
04:00000691 66BFFFFF01	    88M 		mov $off_value,%edi
04:00000696 00
04:00000697 C6C078    	    89M 		mov $value,%al
04:0000069A 678803    	    90M 		mov %al,%ds:(%ebx)
04:0000069D B000      	    91M 		mov $0,%al
04:0000069F 67268803  	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
04:000006A3 A4        	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
04:000006A4 C6C078    	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
04:000006A7 67263803  	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
04:000006AB 0F85FE1D  	   101M 		jne error
04:000006AF 6681FF0000	   102M 		cmp $off_cmp,%edi
04:000006B4 0100
04:000006B6 0F85F31D  	   103M 		jne error
04:000006BA 6681FE0000	   104M 		cmp $off_cmp,%esi
04:000006BF 0100
04:000006C1 0F85E81D  	   105M 		jne error
                      	   106M 
04:000006C5 66BEFFFF01	   107M 		mov $off_value,%esi
04:000006CA 00
04:000006CB C6C078    	   108M 		mov $value,%al
04:000006CE 67268803  	   109M 		mov %al,%es:(%ebx)
04:000006D2 6631C0    	   110M 		xor %eax,%eax
                      	   111M #		addr16
04:000006D5 AC        	   112M 		lodsb       # LOAD data from DS:ESI into EAX
04:000006D6 3C78      	   113M 		cmp $value & val_mask,%al
04:000006D8 0F85D11D  	   114M 		jne error
04:000006DC 6681FE0000	   115M 		cmp $off_cmp,%esi
04:000006E1 0100
04:000006E3 0F85C61D  	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if b = w
                      	   120M 		mov $off_value,%edi
                      	   121M 		mov $off_value & off_mask,%ebx
                      	   122M 		mov $0,%ax
                      	   123M 		mov %ax,%es:(%ebx)
                      	   124M 		mov $value,%ax
                      	   125M #		addr16
                      	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
                      	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
                      	   132M 		jne error
                      	   133M 		cmp $off_cmp,%edi
                      	   134M 		jne error
                      	   135M 
                      	   136M 		mov $off_value,%esi
                      	   137M 		mov $off_value,%edi
                      	   138M 		mov $off_value & off_mask,%ebx
                      	   139M 		mov %ax,%ds:(%ebx)
                      	   140M 		mov %ax,%es:(%ebx)
                      	   141M 		cmp $0,%ax
                      	   142M 		je error
                      	   143M #		addr16
                      	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
                      	   145M 		jne error
                      	   146M 		cmp $off_cmp,%edi
                      	   147M 		jne error
                      	   148M 		cmp $off_cmp,%esi
                      	   149M 		jne error
                      	   150M 
                      	   151M 		mov $off_value,%edi
                      	   152M 		mov $value,%ax
                      	   153M 		mov %ax,%es:(%ebx)
                      	   154M 		cmp $0,%ax
                      	   155M #		addr16
                      	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
                      	   157M 		jne error
                      	   158M 		cmp $off_cmp,%edi
                      	   159M 		jne error
                      	   160M 
                      	   161M 		mov $off_value,%esi
                      	   162M 		mov $off_value,%edi
                      	   163M 		mov $value,%ax
                      	   164M 		mov %ax,%ds:(%ebx)
                      	   165M 		mov $0,%ax
                      	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
                      	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
                      	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
                      	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
                      	   175M 		jne error
                      	   176M 		cmp $off_cmp,%edi
                      	   177M 		jne error
                      	   178M 		cmp $off_cmp,%esi
                      	   179M 		jne error
                      	   180M 
                      	   181M 		mov $off_value,%esi
                      	   182M 		mov $value,%ax
                      	   183M 		mov %ax,%es:(%ebx)
                      	   184M 		xor %eax,%eax
                      	   185M #		addr16
                      	   186M 		lodsw       # LOAD data from DS:ESI into EAX
                      	   187M 		cmp $value & val_mask,%ax
                      	   188M 		jne error
                      	   189M 		cmp $off_cmp,%esi
                      	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if b = d
                      	   194M 		mov $off_value,%edi
                      	   195M 		mov $off_value & off_mask,%ebx
                      	   196M 		mov $0,%eax
                      	   197M 		mov %eax,%es:(%ebx)
                      	   198M 		mov $value,%eax
                      	   199M #		addr16
                      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
                      	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
                      	   206M 		jne error
                      	   207M 		cmp $off_cmp,%edi
                      	   208M 		jne error
                      	   209M 
                      	   210M 		mov $off_value,%esi
                      	   211M 		mov $off_value,%edi
                      	   212M 		mov $off_value & off_mask,%ebx
                      	   213M 		mov %eax,%ds:(%ebx)
                      	   214M 		mov %eax,%es:(%ebx)
                      	   215M 		cmp $0,%eax
                      	   216M 		je error
                      	   217M #		addr16
                      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
                      	   219M 		jne error
                      	   220M 		cmp $off_cmp,%edi
                      	   221M 		jne error
                      	   222M 		cmp $off_cmp,%esi
                      	   223M 		jne error
                      	   224M 
                      	   225M 		mov $off_value,%edi
                      	   226M 		mov $value,%eax
                      	   227M 		mov %eax,%es:(%ebx)
                      	   228M 		cmp $0,%eax
                      	   229M #		addr16
                      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
                      	   231M 		jne error
                      	   232M 		cmp $off_cmp,%edi
                      	   233M 		jne error
                      	   234M 
                      	   235M 		mov $off_value,%esi
                      	   236M 		mov $off_value,%edi
                      	   237M 		mov $value,%eax
                      	   238M 		mov %eax,%ds:(%ebx)
                      	   239M 		mov $0,%eax
                      	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
                      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
                      	   243M 		mov $value,%eax
                      	   244M 		.if 16 = 16
                      	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
                      	   249M 		jne error
                      	   250M 		cmp $off_cmp,%edi
                      	   251M 		jne error
                      	   252M 		cmp $off_cmp,%esi
                      	   253M 		jne error
                      	   254M 
                      	   255M 		mov $off_value,%esi
                      	   256M 		mov $value,%eax
                      	   257M 		mov %eax,%es:(%ebx)
                      	   258M 		xor %eax,%eax
                      	   259M #		addr16
                      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
                      	   261M 		cmp $value & val_mask,%eax
                      	   262M 		jne error
                      	   263M 		cmp $off_cmp,%esi
                      	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   238: 	testStringOps w,0,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if w = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if w = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if w = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 0 == 0
04:000006E7 FC        	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
                      	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if w = b
                      	    46M 		mov $off_value,%edi
                      	    47M 		mov $off_value & off_mask,%ebx
                      	    48M 		mov $0,%al
                      	    49M 		mov %al,%es:(%ebx)
                      	    50M 		mov $value,%al
                      	    51M #		addr16
                      	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
                      	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
                      	    58M 		jne error
                      	    59M 		cmp $off_cmp,%edi
                      	    60M 		jne error
                      	    61M 
                      	    62M 		mov $off_value,%esi
                      	    63M 		mov $off_value,%edi
                      	    64M 		mov $off_value & off_mask,%ebx
                      	    65M 		mov %al,%ds:(%ebx)
                      	    66M 		mov %al,%es:(%ebx)
                      	    67M 		cmp $0,%al
                      	    68M 		je error
                      	    69M #		addr16
                      	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
                      	    71M 		jne error
                      	    72M 		cmp $off_cmp,%edi
                      	    73M 		jne error
                      	    74M 		cmp $off_cmp,%esi
                      	    75M 		jne error
                      	    76M 
                      	    77M 		mov $off_value,%edi
                      	    78M 		mov $value,%al
                      	    79M 		mov %al,%es:(%ebx)
                      	    80M 		cmp $0,%al
                      	    81M #		addr16
                      	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
                      	    83M 		jne error
                      	    84M 		cmp $off_cmp,%edi
                      	    85M 		jne error
                      	    86M 
                      	    87M 		mov $off_value,%esi
                      	    88M 		mov $off_value,%edi
                      	    89M 		mov $value,%al
                      	    90M 		mov %al,%ds:(%ebx)
                      	    91M 		mov $0,%al
                      	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
                      	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
                      	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
                      	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
                      	   101M 		jne error
                      	   102M 		cmp $off_cmp,%edi
                      	   103M 		jne error
                      	   104M 		cmp $off_cmp,%esi
                      	   105M 		jne error
                      	   106M 
                      	   107M 		mov $off_value,%esi
                      	   108M 		mov $value,%al
                      	   109M 		mov %al,%es:(%ebx)
                      	   110M 		xor %eax,%eax
                      	   111M #		addr16
                      	   112M 		lodsb       # LOAD data from DS:ESI into EAX
                      	   113M 		cmp $value & val_mask,%al
                      	   114M 		jne error
                      	   115M 		cmp $off_cmp,%esi
                      	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if w = w
04:000006E8 66BFFEFF01	   120M 		mov $off_value,%edi
04:000006ED 00
04:000006EE 66BBFEFF00	   121M 		mov $off_value & off_mask,%ebx
04:000006F3 00
04:000006F4 B80000    	   122M 		mov $0,%ax
04:000006F7 67268903  	   123M 		mov %ax,%es:(%ebx)
04:000006FB C7C07856  	   124M 		mov $value,%ax
                      	   125M #		addr16
04:000006FF AB        	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
04:00000700 67263903  	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
04:00000704 0F85A51D  	   132M 		jne error
04:00000708 6681FF0000	   133M 		cmp $off_cmp,%edi
04:0000070D 0100
04:0000070F 0F859A1D  	   134M 		jne error
                      	   135M 
04:00000713 66BEFEFF01	   136M 		mov $off_value,%esi
04:00000718 00
04:00000719 66BFFEFF01	   137M 		mov $off_value,%edi
04:0000071E 00
04:0000071F 66BBFEFF00	   138M 		mov $off_value & off_mask,%ebx
04:00000724 00
04:00000725 678903    	   139M 		mov %ax,%ds:(%ebx)
04:00000728 67268903  	   140M 		mov %ax,%es:(%ebx)
04:0000072C 83F800    	   141M 		cmp $0,%ax
04:0000072F 0F847A1D  	   142M 		je error
                      	   143M #		addr16
04:00000733 A7        	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
04:00000734 0F85751D  	   145M 		jne error
04:00000738 6681FF0000	   146M 		cmp $off_cmp,%edi
04:0000073D 0100
04:0000073F 0F856A1D  	   147M 		jne error
04:00000743 6681FE0000	   148M 		cmp $off_cmp,%esi
04:00000748 0100
04:0000074A 0F855F1D  	   149M 		jne error
                      	   150M 
04:0000074E 66BFFEFF01	   151M 		mov $off_value,%edi
04:00000753 00
04:00000754 C7C07856  	   152M 		mov $value,%ax
04:00000758 67268903  	   153M 		mov %ax,%es:(%ebx)
04:0000075C 83F800    	   154M 		cmp $0,%ax
                      	   155M #		addr16
04:0000075F AF        	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
04:00000760 0F85491D  	   157M 		jne error
04:00000764 6681FF0000	   158M 		cmp $off_cmp,%edi
04:00000769 0100
04:0000076B 0F853E1D  	   159M 		jne error
                      	   160M 
04:0000076F 66BEFEFF01	   161M 		mov $off_value,%esi
04:00000774 00
04:00000775 66BFFEFF01	   162M 		mov $off_value,%edi
04:0000077A 00
04:0000077B C7C07856  	   163M 		mov $value,%ax
04:0000077F 678903    	   164M 		mov %ax,%ds:(%ebx)
04:00000782 B80000    	   165M 		mov $0,%ax
04:00000785 67268903  	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
04:00000789 A5        	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
04:0000078A C7C07856  	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
04:0000078E 67263903  	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
04:00000792 0F85171D  	   175M 		jne error
04:00000796 6681FF0000	   176M 		cmp $off_cmp,%edi
04:0000079B 0100
04:0000079D 0F850C1D  	   177M 		jne error
04:000007A1 6681FE0000	   178M 		cmp $off_cmp,%esi
04:000007A6 0100
04:000007A8 0F85011D  	   179M 		jne error
                      	   180M 
04:000007AC 66BEFEFF01	   181M 		mov $off_value,%esi
04:000007B1 00
04:000007B2 C7C07856  	   182M 		mov $value,%ax
04:000007B6 67268903  	   183M 		mov %ax,%es:(%ebx)
04:000007BA 6631C0    	   184M 		xor %eax,%eax
                      	   185M #		addr16
04:000007BD AD        	   186M 		lodsw       # LOAD data from DS:ESI into EAX
04:000007BE 3D7856    	   187M 		cmp $value & val_mask,%ax
04:000007C1 0F85E81C  	   188M 		jne error
04:000007C5 6681FE0000	   189M 		cmp $off_cmp,%esi
04:000007CA 0100
04:000007CC 0F85DD1C  	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if w = d
                      	   194M 		mov $off_value,%edi
                      	   195M 		mov $off_value & off_mask,%ebx
                      	   196M 		mov $0,%eax
                      	   197M 		mov %eax,%es:(%ebx)
                      	   198M 		mov $value,%eax
                      	   199M #		addr16
                      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
                      	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
                      	   206M 		jne error
                      	   207M 		cmp $off_cmp,%edi
                      	   208M 		jne error
                      	   209M 
                      	   210M 		mov $off_value,%esi
                      	   211M 		mov $off_value,%edi
                      	   212M 		mov $off_value & off_mask,%ebx
                      	   213M 		mov %eax,%ds:(%ebx)
                      	   214M 		mov %eax,%es:(%ebx)
                      	   215M 		cmp $0,%eax
                      	   216M 		je error
                      	   217M #		addr16
                      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
                      	   219M 		jne error
                      	   220M 		cmp $off_cmp,%edi
                      	   221M 		jne error
                      	   222M 		cmp $off_cmp,%esi
                      	   223M 		jne error
                      	   224M 
                      	   225M 		mov $off_value,%edi
                      	   226M 		mov $value,%eax
                      	   227M 		mov %eax,%es:(%ebx)
                      	   228M 		cmp $0,%eax
                      	   229M #		addr16
                      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
                      	   231M 		jne error
                      	   232M 		cmp $off_cmp,%edi
                      	   233M 		jne error
                      	   234M 
                      	   235M 		mov $off_value,%esi
                      	   236M 		mov $off_value,%edi
                      	   237M 		mov $value,%eax
                      	   238M 		mov %eax,%ds:(%ebx)
                      	   239M 		mov $0,%eax
                      	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
                      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
                      	   243M 		mov $value,%eax
                      	   244M 		.if 16 = 16
                      	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
                      	   249M 		jne error
                      	   250M 		cmp $off_cmp,%edi
                      	   251M 		jne error
                      	   252M 		cmp $off_cmp,%esi
                      	   253M 		jne error
                      	   254M 
                      	   255M 		mov $off_value,%esi
                      	   256M 		mov $value,%eax
                      	   257M 		mov %eax,%es:(%ebx)
                      	   258M 		xor %eax,%eax
                      	   259M #		addr16
                      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
                      	   261M 		cmp $value & val_mask,%eax
                      	   262M 		jne error
                      	   263M 		cmp $off_cmp,%esi
                      	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   239: 	testStringOps d,0,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if d = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if d = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if d = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 0 == 0
04:000007D0 FC        	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
                      	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if d = b
                      	    46M 		mov $off_value,%edi
                      	    47M 		mov $off_value & off_mask,%ebx
                      	    48M 		mov $0,%al
                      	    49M 		mov %al,%es:(%ebx)
                      	    50M 		mov $value,%al
                      	    51M #		addr16
                      	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
                      	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
                      	    58M 		jne error
                      	    59M 		cmp $off_cmp,%edi
                      	    60M 		jne error
                      	    61M 
                      	    62M 		mov $off_value,%esi
                      	    63M 		mov $off_value,%edi
                      	    64M 		mov $off_value & off_mask,%ebx
                      	    65M 		mov %al,%ds:(%ebx)
                      	    66M 		mov %al,%es:(%ebx)
                      	    67M 		cmp $0,%al
                      	    68M 		je error
                      	    69M #		addr16
                      	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
                      	    71M 		jne error
                      	    72M 		cmp $off_cmp,%edi
                      	    73M 		jne error
                      	    74M 		cmp $off_cmp,%esi
                      	    75M 		jne error
                      	    76M 
                      	    77M 		mov $off_value,%edi
                      	    78M 		mov $value,%al
                      	    79M 		mov %al,%es:(%ebx)
                      	    80M 		cmp $0,%al
                      	    81M #		addr16
                      	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
                      	    83M 		jne error
                      	    84M 		cmp $off_cmp,%edi
                      	    85M 		jne error
                      	    86M 
                      	    87M 		mov $off_value,%esi
                      	    88M 		mov $off_value,%edi
                      	    89M 		mov $value,%al
                      	    90M 		mov %al,%ds:(%ebx)
                      	    91M 		mov $0,%al
                      	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
                      	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
                      	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
                      	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
                      	   101M 		jne error
                      	   102M 		cmp $off_cmp,%edi
                      	   103M 		jne error
                      	   104M 		cmp $off_cmp,%esi
                      	   105M 		jne error
                      	   106M 
                      	   107M 		mov $off_value,%esi
                      	   108M 		mov $value,%al
                      	   109M 		mov %al,%es:(%ebx)
                      	   110M 		xor %eax,%eax
                      	   111M #		addr16
                      	   112M 		lodsb       # LOAD data from DS:ESI into EAX
                      	   113M 		cmp $value & val_mask,%al
                      	   114M 		jne error
                      	   115M 		cmp $off_cmp,%esi
                      	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if d = w
                      	   120M 		mov $off_value,%edi
                      	   121M 		mov $off_value & off_mask,%ebx
                      	   122M 		mov $0,%ax
                      	   123M 		mov %ax,%es:(%ebx)
                      	   124M 		mov $value,%ax
                      	   125M #		addr16
                      	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
                      	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
                      	   132M 		jne error
                      	   133M 		cmp $off_cmp,%edi
                      	   134M 		jne error
                      	   135M 
                      	   136M 		mov $off_value,%esi
                      	   137M 		mov $off_value,%edi
                      	   138M 		mov $off_value & off_mask,%ebx
                      	   139M 		mov %ax,%ds:(%ebx)
                      	   140M 		mov %ax,%es:(%ebx)
                      	   141M 		cmp $0,%ax
                      	   142M 		je error
                      	   143M #		addr16
                      	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
                      	   145M 		jne error
                      	   146M 		cmp $off_cmp,%edi
                      	   147M 		jne error
                      	   148M 		cmp $off_cmp,%esi
                      	   149M 		jne error
                      	   150M 
                      	   151M 		mov $off_value,%edi
                      	   152M 		mov $value,%ax
                      	   153M 		mov %ax,%es:(%ebx)
                      	   154M 		cmp $0,%ax
                      	   155M #		addr16
                      	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
                      	   157M 		jne error
                      	   158M 		cmp $off_cmp,%edi
                      	   159M 		jne error
                      	   160M 
                      	   161M 		mov $off_value,%esi
                      	   162M 		mov $off_value,%edi
                      	   163M 		mov $value,%ax
                      	   164M 		mov %ax,%ds:(%ebx)
                      	   165M 		mov $0,%ax
                      	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
                      	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
                      	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
                      	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
                      	   175M 		jne error
                      	   176M 		cmp $off_cmp,%edi
                      	   177M 		jne error
                      	   178M 		cmp $off_cmp,%esi
                      	   179M 		jne error
                      	   180M 
                      	   181M 		mov $off_value,%esi
                      	   182M 		mov $value,%ax
                      	   183M 		mov %ax,%es:(%ebx)
                      	   184M 		xor %eax,%eax
                      	   185M #		addr16
                      	   186M 		lodsw       # LOAD data from DS:ESI into EAX
                      	   187M 		cmp $value & val_mask,%ax
                      	   188M 		jne error
                      	   189M 		cmp $off_cmp,%esi
                      	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if d = d
04:000007D1 66BFFCFF01	   194M 		mov $off_value,%edi
04:000007D6 00
04:000007D7 66BBFCFF00	   195M 		mov $off_value & off_mask,%ebx
04:000007DC 00
04:000007DD 66B8000000	   196M 		mov $0,%eax
04:000007E2 00
04:000007E3 6766268903	   197M 		mov %eax,%es:(%ebx)
04:000007E8 66B8785634	   198M 		mov $value,%eax
04:000007ED 12
                      	   199M #		addr16
04:000007EE 66AB      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
04:000007F0 6766263903	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
04:000007F5 0F85B41C  	   206M 		jne error
04:000007F9 6681FF0000	   207M 		cmp $off_cmp,%edi
04:000007FE 0100
04:00000800 0F85A91C  	   208M 		jne error
                      	   209M 
04:00000804 66BEFCFF01	   210M 		mov $off_value,%esi
04:00000809 00
04:0000080A 66BFFCFF01	   211M 		mov $off_value,%edi
04:0000080F 00
04:00000810 66BBFCFF00	   212M 		mov $off_value & off_mask,%ebx
04:00000815 00
04:00000816 67668903  	   213M 		mov %eax,%ds:(%ebx)
04:0000081A 6766268903	   214M 		mov %eax,%es:(%ebx)
04:0000081F 6683F800  	   215M 		cmp $0,%eax
04:00000823 0F84861C  	   216M 		je error
                      	   217M #		addr16
04:00000827 66A7      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
04:00000829 0F85801C  	   219M 		jne error
04:0000082D 6681FF0000	   220M 		cmp $off_cmp,%edi
04:00000832 0100
04:00000834 0F85751C  	   221M 		jne error
04:00000838 6681FE0000	   222M 		cmp $off_cmp,%esi
04:0000083D 0100
04:0000083F 0F856A1C  	   223M 		jne error
                      	   224M 
04:00000843 66BFFCFF01	   225M 		mov $off_value,%edi
04:00000848 00
04:00000849 66B8785634	   226M 		mov $value,%eax
04:0000084E 12
04:0000084F 6766268903	   227M 		mov %eax,%es:(%ebx)
04:00000854 6683F800  	   228M 		cmp $0,%eax
                      	   229M #		addr16
04:00000858 66AF      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
04:0000085A 0F854F1C  	   231M 		jne error
04:0000085E 6681FF0000	   232M 		cmp $off_cmp,%edi
04:00000863 0100
04:00000865 0F85441C  	   233M 		jne error
                      	   234M 
04:00000869 66BEFCFF01	   235M 		mov $off_value,%esi
04:0000086E 00
04:0000086F 66BFFCFF01	   236M 		mov $off_value,%edi
04:00000874 00
04:00000875 66B8785634	   237M 		mov $value,%eax
04:0000087A 12
04:0000087B 67668903  	   238M 		mov %eax,%ds:(%ebx)
04:0000087F 66B8000000	   239M 		mov $0,%eax
04:00000884 00
04:00000885 6766268903	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
04:0000088A 66A5      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
04:0000088C 66B8785634	   243M 		mov $value,%eax
04:00000891 12
                      	   244M 		.if 16 = 16
04:00000892 6766263903	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
04:00000897 0F85121C  	   249M 		jne error
04:0000089B 6681FF0000	   250M 		cmp $off_cmp,%edi
04:000008A0 0100
04:000008A2 0F85071C  	   251M 		jne error
04:000008A6 6681FE0000	   252M 		cmp $off_cmp,%esi
04:000008AB 0100
04:000008AD 0F85FC1B  	   253M 		jne error
                      	   254M 
04:000008B1 66BEFCFF01	   255M 		mov $off_value,%esi
04:000008B6 00
04:000008B7 66B8785634	   256M 		mov $value,%eax
04:000008BC 12
04:000008BD 6766268903	   257M 		mov %eax,%es:(%ebx)
04:000008C2 6631C0    	   258M 		xor %eax,%eax
                      	   259M #		addr16
04:000008C5 66AD      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
04:000008C7 663D785634	   261M 		cmp $value & val_mask,%eax
04:000008CC 12
04:000008CD 0F85DC1B  	   262M 		jne error
04:000008D1 6681FE0000	   263M 		cmp $off_cmp,%esi
04:000008D6 0100
04:000008D8 0F85D11B  	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   240: 	testStringOps b,1,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if b = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if b = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if b = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 1 == 0
                      	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
04:000008DC FD        	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if b = b
04:000008DD 66BF000001	    46M 		mov $off_value,%edi
04:000008E2 00
04:000008E3 66BB000000	    47M 		mov $off_value & off_mask,%ebx
04:000008E8 00
04:000008E9 B000      	    48M 		mov $0,%al
04:000008EB 67268803  	    49M 		mov %al,%es:(%ebx)
04:000008EF C6C078    	    50M 		mov $value,%al
                      	    51M #		addr16
04:000008F2 AA        	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
04:000008F3 67263803  	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
04:000008F7 0F85B21B  	    58M 		jne error
04:000008FB 6681FFFFFF	    59M 		cmp $off_cmp,%edi
04:00000900 0100
04:00000902 0F85A71B  	    60M 		jne error
                      	    61M 
04:00000906 66BE000001	    62M 		mov $off_value,%esi
04:0000090B 00
04:0000090C 66BF000001	    63M 		mov $off_value,%edi
04:00000911 00
04:00000912 66BB000000	    64M 		mov $off_value & off_mask,%ebx
04:00000917 00
04:00000918 678803    	    65M 		mov %al,%ds:(%ebx)
04:0000091B 67268803  	    66M 		mov %al,%es:(%ebx)
04:0000091F 3C00      	    67M 		cmp $0,%al
04:00000921 0F84881B  	    68M 		je error
                      	    69M #		addr16
04:00000925 A6        	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
04:00000926 0F85831B  	    71M 		jne error
04:0000092A 6681FFFFFF	    72M 		cmp $off_cmp,%edi
04:0000092F 0100
04:00000931 0F85781B  	    73M 		jne error
04:00000935 6681FEFFFF	    74M 		cmp $off_cmp,%esi
04:0000093A 0100
04:0000093C 0F856D1B  	    75M 		jne error
                      	    76M 
04:00000940 66BF000001	    77M 		mov $off_value,%edi
04:00000945 00
04:00000946 C6C078    	    78M 		mov $value,%al
04:00000949 67268803  	    79M 		mov %al,%es:(%ebx)
04:0000094D 3C00      	    80M 		cmp $0,%al
                      	    81M #		addr16
04:0000094F AE        	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
04:00000950 0F85591B  	    83M 		jne error
04:00000954 6681FFFFFF	    84M 		cmp $off_cmp,%edi
04:00000959 0100
04:0000095B 0F854E1B  	    85M 		jne error
                      	    86M 
04:0000095F 66BE000001	    87M 		mov $off_value,%esi
04:00000964 00
04:00000965 66BF000001	    88M 		mov $off_value,%edi
04:0000096A 00
04:0000096B C6C078    	    89M 		mov $value,%al
04:0000096E 678803    	    90M 		mov %al,%ds:(%ebx)
04:00000971 B000      	    91M 		mov $0,%al
04:00000973 67268803  	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
04:00000977 A4        	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
04:00000978 C6C078    	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
04:0000097B 67263803  	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
04:0000097F 0F852A1B  	   101M 		jne error
04:00000983 6681FFFFFF	   102M 		cmp $off_cmp,%edi
04:00000988 0100
04:0000098A 0F851F1B  	   103M 		jne error
04:0000098E 6681FEFFFF	   104M 		cmp $off_cmp,%esi
04:00000993 0100
04:00000995 0F85141B  	   105M 		jne error
                      	   106M 
04:00000999 66BE000001	   107M 		mov $off_value,%esi
04:0000099E 00
04:0000099F C6C078    	   108M 		mov $value,%al
04:000009A2 67268803  	   109M 		mov %al,%es:(%ebx)
04:000009A6 6631C0    	   110M 		xor %eax,%eax
                      	   111M #		addr16
04:000009A9 AC        	   112M 		lodsb       # LOAD data from DS:ESI into EAX
04:000009AA 3C78      	   113M 		cmp $value & val_mask,%al
04:000009AC 0F85FD1A  	   114M 		jne error
04:000009B0 6681FEFFFF	   115M 		cmp $off_cmp,%esi
04:000009B5 0100
04:000009B7 0F85F21A  	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if b = w
                      	   120M 		mov $off_value,%edi
                      	   121M 		mov $off_value & off_mask,%ebx
                      	   122M 		mov $0,%ax
                      	   123M 		mov %ax,%es:(%ebx)
                      	   124M 		mov $value,%ax
                      	   125M #		addr16
                      	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
                      	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
                      	   132M 		jne error
                      	   133M 		cmp $off_cmp,%edi
                      	   134M 		jne error
                      	   135M 
                      	   136M 		mov $off_value,%esi
                      	   137M 		mov $off_value,%edi
                      	   138M 		mov $off_value & off_mask,%ebx
                      	   139M 		mov %ax,%ds:(%ebx)
                      	   140M 		mov %ax,%es:(%ebx)
                      	   141M 		cmp $0,%ax
                      	   142M 		je error
                      	   143M #		addr16
                      	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
                      	   145M 		jne error
                      	   146M 		cmp $off_cmp,%edi
                      	   147M 		jne error
                      	   148M 		cmp $off_cmp,%esi
                      	   149M 		jne error
                      	   150M 
                      	   151M 		mov $off_value,%edi
                      	   152M 		mov $value,%ax
                      	   153M 		mov %ax,%es:(%ebx)
                      	   154M 		cmp $0,%ax
                      	   155M #		addr16
                      	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
                      	   157M 		jne error
                      	   158M 		cmp $off_cmp,%edi
                      	   159M 		jne error
                      	   160M 
                      	   161M 		mov $off_value,%esi
                      	   162M 		mov $off_value,%edi
                      	   163M 		mov $value,%ax
                      	   164M 		mov %ax,%ds:(%ebx)
                      	   165M 		mov $0,%ax
                      	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
                      	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
                      	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
                      	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
                      	   175M 		jne error
                      	   176M 		cmp $off_cmp,%edi
                      	   177M 		jne error
                      	   178M 		cmp $off_cmp,%esi
                      	   179M 		jne error
                      	   180M 
                      	   181M 		mov $off_value,%esi
                      	   182M 		mov $value,%ax
                      	   183M 		mov %ax,%es:(%ebx)
                      	   184M 		xor %eax,%eax
                      	   185M #		addr16
                      	   186M 		lodsw       # LOAD data from DS:ESI into EAX
                      	   187M 		cmp $value & val_mask,%ax
                      	   188M 		jne error
                      	   189M 		cmp $off_cmp,%esi
                      	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if b = d
                      	   194M 		mov $off_value,%edi
                      	   195M 		mov $off_value & off_mask,%ebx
                      	   196M 		mov $0,%eax
                      	   197M 		mov %eax,%es:(%ebx)
                      	   198M 		mov $value,%eax
                      	   199M #		addr16
                      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
                      	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
                      	   206M 		jne error
                      	   207M 		cmp $off_cmp,%edi
                      	   208M 		jne error
                      	   209M 
                      	   210M 		mov $off_value,%esi
                      	   211M 		mov $off_value,%edi
                      	   212M 		mov $off_value & off_mask,%ebx
                      	   213M 		mov %eax,%ds:(%ebx)
                      	   214M 		mov %eax,%es:(%ebx)
                      	   215M 		cmp $0,%eax
                      	   216M 		je error
                      	   217M #		addr16
                      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
                      	   219M 		jne error
                      	   220M 		cmp $off_cmp,%edi
                      	   221M 		jne error
                      	   222M 		cmp $off_cmp,%esi
                      	   223M 		jne error
                      	   224M 
                      	   225M 		mov $off_value,%edi
                      	   226M 		mov $value,%eax
                      	   227M 		mov %eax,%es:(%ebx)
                      	   228M 		cmp $0,%eax
                      	   229M #		addr16
                      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
                      	   231M 		jne error
                      	   232M 		cmp $off_cmp,%edi
                      	   233M 		jne error
                      	   234M 
                      	   235M 		mov $off_value,%esi
                      	   236M 		mov $off_value,%edi
                      	   237M 		mov $value,%eax
                      	   238M 		mov %eax,%ds:(%ebx)
                      	   239M 		mov $0,%eax
                      	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
                      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
                      	   243M 		mov $value,%eax
                      	   244M 		.if 16 = 16
                      	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
                      	   249M 		jne error
                      	   250M 		cmp $off_cmp,%edi
                      	   251M 		jne error
                      	   252M 		cmp $off_cmp,%esi
                      	   253M 		jne error
                      	   254M 
                      	   255M 		mov $off_value,%esi
                      	   256M 		mov $value,%eax
                      	   257M 		mov %eax,%es:(%ebx)
                      	   258M 		xor %eax,%eax
                      	   259M #		addr16
                      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
                      	   261M 		cmp $value & val_mask,%eax
                      	   262M 		jne error
                      	   263M 		cmp $off_cmp,%esi
                      	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   241: 	testStringOps w,1,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if w = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if w = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if w = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 1 == 0
                      	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
04:000009BB FD        	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if w = b
                      	    46M 		mov $off_value,%edi
                      	    47M 		mov $off_value & off_mask,%ebx
                      	    48M 		mov $0,%al
                      	    49M 		mov %al,%es:(%ebx)
                      	    50M 		mov $value,%al
                      	    51M #		addr16
                      	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
                      	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
                      	    58M 		jne error
                      	    59M 		cmp $off_cmp,%edi
                      	    60M 		jne error
                      	    61M 
                      	    62M 		mov $off_value,%esi
                      	    63M 		mov $off_value,%edi
                      	    64M 		mov $off_value & off_mask,%ebx
                      	    65M 		mov %al,%ds:(%ebx)
                      	    66M 		mov %al,%es:(%ebx)
                      	    67M 		cmp $0,%al
                      	    68M 		je error
                      	    69M #		addr16
                      	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
                      	    71M 		jne error
                      	    72M 		cmp $off_cmp,%edi
                      	    73M 		jne error
                      	    74M 		cmp $off_cmp,%esi
                      	    75M 		jne error
                      	    76M 
                      	    77M 		mov $off_value,%edi
                      	    78M 		mov $value,%al
                      	    79M 		mov %al,%es:(%ebx)
                      	    80M 		cmp $0,%al
                      	    81M #		addr16
                      	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
                      	    83M 		jne error
                      	    84M 		cmp $off_cmp,%edi
                      	    85M 		jne error
                      	    86M 
                      	    87M 		mov $off_value,%esi
                      	    88M 		mov $off_value,%edi
                      	    89M 		mov $value,%al
                      	    90M 		mov %al,%ds:(%ebx)
                      	    91M 		mov $0,%al
                      	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
                      	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
                      	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
                      	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
                      	   101M 		jne error
                      	   102M 		cmp $off_cmp,%edi
                      	   103M 		jne error
                      	   104M 		cmp $off_cmp,%esi
                      	   105M 		jne error
                      	   106M 
                      	   107M 		mov $off_value,%esi
                      	   108M 		mov $value,%al
                      	   109M 		mov %al,%es:(%ebx)
                      	   110M 		xor %eax,%eax
                      	   111M #		addr16
                      	   112M 		lodsb       # LOAD data from DS:ESI into EAX
                      	   113M 		cmp $value & val_mask,%al
                      	   114M 		jne error
                      	   115M 		cmp $off_cmp,%esi
                      	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if w = w
04:000009BC 66BF000001	   120M 		mov $off_value,%edi
04:000009C1 00
04:000009C2 66BB000000	   121M 		mov $off_value & off_mask,%ebx
04:000009C7 00
04:000009C8 B80000    	   122M 		mov $0,%ax
04:000009CB 67268903  	   123M 		mov %ax,%es:(%ebx)
04:000009CF C7C07856  	   124M 		mov $value,%ax
                      	   125M #		addr16
04:000009D3 AB        	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
04:000009D4 67263903  	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
04:000009D8 0F85D11A  	   132M 		jne error
04:000009DC 6681FFFEFF	   133M 		cmp $off_cmp,%edi
04:000009E1 0100
04:000009E3 0F85C61A  	   134M 		jne error
                      	   135M 
04:000009E7 66BE000001	   136M 		mov $off_value,%esi
04:000009EC 00
04:000009ED 66BF000001	   137M 		mov $off_value,%edi
04:000009F2 00
04:000009F3 66BB000000	   138M 		mov $off_value & off_mask,%ebx
04:000009F8 00
04:000009F9 678903    	   139M 		mov %ax,%ds:(%ebx)
04:000009FC 67268903  	   140M 		mov %ax,%es:(%ebx)
04:00000A00 83F800    	   141M 		cmp $0,%ax
04:00000A03 0F84A61A  	   142M 		je error
                      	   143M #		addr16
04:00000A07 A7        	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
04:00000A08 0F85A11A  	   145M 		jne error
04:00000A0C 6681FFFEFF	   146M 		cmp $off_cmp,%edi
04:00000A11 0100
04:00000A13 0F85961A  	   147M 		jne error
04:00000A17 6681FEFEFF	   148M 		cmp $off_cmp,%esi
04:00000A1C 0100
04:00000A1E 0F858B1A  	   149M 		jne error
                      	   150M 
04:00000A22 66BF000001	   151M 		mov $off_value,%edi
04:00000A27 00
04:00000A28 C7C07856  	   152M 		mov $value,%ax
04:00000A2C 67268903  	   153M 		mov %ax,%es:(%ebx)
04:00000A30 83F800    	   154M 		cmp $0,%ax
                      	   155M #		addr16
04:00000A33 AF        	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
04:00000A34 0F85751A  	   157M 		jne error
04:00000A38 6681FFFEFF	   158M 		cmp $off_cmp,%edi
04:00000A3D 0100
04:00000A3F 0F856A1A  	   159M 		jne error
                      	   160M 
04:00000A43 66BE000001	   161M 		mov $off_value,%esi
04:00000A48 00
04:00000A49 66BF000001	   162M 		mov $off_value,%edi
04:00000A4E 00
04:00000A4F C7C07856  	   163M 		mov $value,%ax
04:00000A53 678903    	   164M 		mov %ax,%ds:(%ebx)
04:00000A56 B80000    	   165M 		mov $0,%ax
04:00000A59 67268903  	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
04:00000A5D A5        	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
04:00000A5E C7C07856  	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
04:00000A62 67263903  	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
04:00000A66 0F85431A  	   175M 		jne error
04:00000A6A 6681FFFEFF	   176M 		cmp $off_cmp,%edi
04:00000A6F 0100
04:00000A71 0F85381A  	   177M 		jne error
04:00000A75 6681FEFEFF	   178M 		cmp $off_cmp,%esi
04:00000A7A 0100
04:00000A7C 0F852D1A  	   179M 		jne error
                      	   180M 
04:00000A80 66BE000001	   181M 		mov $off_value,%esi
04:00000A85 00
04:00000A86 C7C07856  	   182M 		mov $value,%ax
04:00000A8A 67268903  	   183M 		mov %ax,%es:(%ebx)
04:00000A8E 6631C0    	   184M 		xor %eax,%eax
                      	   185M #		addr16
04:00000A91 AD        	   186M 		lodsw       # LOAD data from DS:ESI into EAX
04:00000A92 3D7856    	   187M 		cmp $value & val_mask,%ax
04:00000A95 0F85141A  	   188M 		jne error
04:00000A99 6681FEFEFF	   189M 		cmp $off_cmp,%esi
04:00000A9E 0100
04:00000AA0 0F85091A  	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if w = d
                      	   194M 		mov $off_value,%edi
                      	   195M 		mov $off_value & off_mask,%ebx
                      	   196M 		mov $0,%eax
                      	   197M 		mov %eax,%es:(%ebx)
                      	   198M 		mov $value,%eax
                      	   199M #		addr16
                      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
                      	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
                      	   206M 		jne error
                      	   207M 		cmp $off_cmp,%edi
                      	   208M 		jne error
                      	   209M 
                      	   210M 		mov $off_value,%esi
                      	   211M 		mov $off_value,%edi
                      	   212M 		mov $off_value & off_mask,%ebx
                      	   213M 		mov %eax,%ds:(%ebx)
                      	   214M 		mov %eax,%es:(%ebx)
                      	   215M 		cmp $0,%eax
                      	   216M 		je error
                      	   217M #		addr16
                      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
                      	   219M 		jne error
                      	   220M 		cmp $off_cmp,%edi
                      	   221M 		jne error
                      	   222M 		cmp $off_cmp,%esi
                      	   223M 		jne error
                      	   224M 
                      	   225M 		mov $off_value,%edi
                      	   226M 		mov $value,%eax
                      	   227M 		mov %eax,%es:(%ebx)
                      	   228M 		cmp $0,%eax
                      	   229M #		addr16
                      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
                      	   231M 		jne error
                      	   232M 		cmp $off_cmp,%edi
                      	   233M 		jne error
                      	   234M 
                      	   235M 		mov $off_value,%esi
                      	   236M 		mov $off_value,%edi
                      	   237M 		mov $value,%eax
                      	   238M 		mov %eax,%ds:(%ebx)
                      	   239M 		mov $0,%eax
                      	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
                      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
                      	   243M 		mov $value,%eax
                      	   244M 		.if 16 = 16
                      	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
                      	   249M 		jne error
                      	   250M 		cmp $off_cmp,%edi
                      	   251M 		jne error
                      	   252M 		cmp $off_cmp,%esi
                      	   253M 		jne error
                      	   254M 
                      	   255M 		mov $off_value,%esi
                      	   256M 		mov $value,%eax
                      	   257M 		mov %eax,%es:(%ebx)
                      	   258M 		xor %eax,%eax
                      	   259M #		addr16
                      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
                      	   261M 		cmp $value & val_mask,%eax
                      	   262M 		jne error
                      	   263M 		cmp $off_cmp,%esi
                      	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   242: 	testStringOps d,1,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if d = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if d = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if d = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 1 == 0
                      	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
04:00000AA4 FD        	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if d = b
                      	    46M 		mov $off_value,%edi
                      	    47M 		mov $off_value & off_mask,%ebx
                      	    48M 		mov $0,%al
                      	    49M 		mov %al,%es:(%ebx)
                      	    50M 		mov $value,%al
                      	    51M #		addr16
                      	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
                      	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
                      	    58M 		jne error
                      	    59M 		cmp $off_cmp,%edi
                      	    60M 		jne error
                      	    61M 
                      	    62M 		mov $off_value,%esi
                      	    63M 		mov $off_value,%edi
                      	    64M 		mov $off_value & off_mask,%ebx
                      	    65M 		mov %al,%ds:(%ebx)
                      	    66M 		mov %al,%es:(%ebx)
                      	    67M 		cmp $0,%al
                      	    68M 		je error
                      	    69M #		addr16
                      	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
                      	    71M 		jne error
                      	    72M 		cmp $off_cmp,%edi
                      	    73M 		jne error
                      	    74M 		cmp $off_cmp,%esi
                      	    75M 		jne error
                      	    76M 
                      	    77M 		mov $off_value,%edi
                      	    78M 		mov $value,%al
                      	    79M 		mov %al,%es:(%ebx)
                      	    80M 		cmp $0,%al
                      	    81M #		addr16
                      	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
                      	    83M 		jne error
                      	    84M 		cmp $off_cmp,%edi
                      	    85M 		jne error
                      	    86M 
                      	    87M 		mov $off_value,%esi
                      	    88M 		mov $off_value,%edi
                      	    89M 		mov $value,%al
                      	    90M 		mov %al,%ds:(%ebx)
                      	    91M 		mov $0,%al
                      	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
                      	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
                      	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
                      	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
                      	   101M 		jne error
                      	   102M 		cmp $off_cmp,%edi
                      	   103M 		jne error
                      	   104M 		cmp $off_cmp,%esi
                      	   105M 		jne error
                      	   106M 
                      	   107M 		mov $off_value,%esi
                      	   108M 		mov $value,%al
                      	   109M 		mov %al,%es:(%ebx)
                      	   110M 		xor %eax,%eax
                      	   111M #		addr16
                      	   112M 		lodsb       # LOAD data from DS:ESI into EAX
                      	   113M 		cmp $value & val_mask,%al
                      	   114M 		jne error
                      	   115M 		cmp $off_cmp,%esi
                      	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if d = w
                      	   120M 		mov $off_value,%edi
                      	   121M 		mov $off_value & off_mask,%ebx
                      	   122M 		mov $0,%ax
                      	   123M 		mov %ax,%es:(%ebx)
                      	   124M 		mov $value,%ax
                      	   125M #		addr16
                      	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
                      	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
                      	   132M 		jne error
                      	   133M 		cmp $off_cmp,%edi
                      	   134M 		jne error
                      	   135M 
                      	   136M 		mov $off_value,%esi
                      	   137M 		mov $off_value,%edi
                      	   138M 		mov $off_value & off_mask,%ebx
                      	   139M 		mov %ax,%ds:(%ebx)
                      	   140M 		mov %ax,%es:(%ebx)
                      	   141M 		cmp $0,%ax
                      	   142M 		je error
                      	   143M #		addr16
                      	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
                      	   145M 		jne error
                      	   146M 		cmp $off_cmp,%edi
                      	   147M 		jne error
                      	   148M 		cmp $off_cmp,%esi
                      	   149M 		jne error
                      	   150M 
                      	   151M 		mov $off_value,%edi
                      	   152M 		mov $value,%ax
                      	   153M 		mov %ax,%es:(%ebx)
                      	   154M 		cmp $0,%ax
                      	   155M #		addr16
                      	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
                      	   157M 		jne error
                      	   158M 		cmp $off_cmp,%edi
                      	   159M 		jne error
                      	   160M 
                      	   161M 		mov $off_value,%esi
                      	   162M 		mov $off_value,%edi
                      	   163M 		mov $value,%ax
                      	   164M 		mov %ax,%ds:(%ebx)
                      	   165M 		mov $0,%ax
                      	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
                      	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
                      	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
                      	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
                      	   175M 		jne error
                      	   176M 		cmp $off_cmp,%edi
                      	   177M 		jne error
                      	   178M 		cmp $off_cmp,%esi
                      	   179M 		jne error
                      	   180M 
                      	   181M 		mov $off_value,%esi
                      	   182M 		mov $value,%ax
                      	   183M 		mov %ax,%es:(%ebx)
                      	   184M 		xor %eax,%eax
                      	   185M #		addr16
                      	   186M 		lodsw       # LOAD data from DS:ESI into EAX
                      	   187M 		cmp $value & val_mask,%ax
                      	   188M 		jne error
                      	   189M 		cmp $off_cmp,%esi
                      	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if d = d
04:00000AA5 66BF000001	   194M 		mov $off_value,%edi
04:00000AAA 00
04:00000AAB 66BB000000	   195M 		mov $off_value & off_mask,%ebx
04:00000AB0 00
04:00000AB1 66B8000000	   196M 		mov $0,%eax
04:00000AB6 00
04:00000AB7 6766268903	   197M 		mov %eax,%es:(%ebx)
04:00000ABC 66B8785634	   198M 		mov $value,%eax
04:00000AC1 12
                      	   199M #		addr16
04:00000AC2 66AB      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
04:00000AC4 6766263903	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
04:00000AC9 0F85E019  	   206M 		jne error
04:00000ACD 6681FFFCFF	   207M 		cmp $off_cmp,%edi
04:00000AD2 0100
04:00000AD4 0F85D519  	   208M 		jne error
                      	   209M 
04:00000AD8 66BE000001	   210M 		mov $off_value,%esi
04:00000ADD 00
04:00000ADE 66BF000001	   211M 		mov $off_value,%edi
04:00000AE3 00
04:00000AE4 66BB000000	   212M 		mov $off_value & off_mask,%ebx
04:00000AE9 00
04:00000AEA 67668903  	   213M 		mov %eax,%ds:(%ebx)
04:00000AEE 6766268903	   214M 		mov %eax,%es:(%ebx)
04:00000AF3 6683F800  	   215M 		cmp $0,%eax
04:00000AF7 0F84B219  	   216M 		je error
                      	   217M #		addr16
04:00000AFB 66A7      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
04:00000AFD 0F85AC19  	   219M 		jne error
04:00000B01 6681FFFCFF	   220M 		cmp $off_cmp,%edi
04:00000B06 0100
04:00000B08 0F85A119  	   221M 		jne error
04:00000B0C 6681FEFCFF	   222M 		cmp $off_cmp,%esi
04:00000B11 0100
04:00000B13 0F859619  	   223M 		jne error
                      	   224M 
04:00000B17 66BF000001	   225M 		mov $off_value,%edi
04:00000B1C 00
04:00000B1D 66B8785634	   226M 		mov $value,%eax
04:00000B22 12
04:00000B23 6766268903	   227M 		mov %eax,%es:(%ebx)
04:00000B28 6683F800  	   228M 		cmp $0,%eax
                      	   229M #		addr16
04:00000B2C 66AF      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
04:00000B2E 0F857B19  	   231M 		jne error
04:00000B32 6681FFFCFF	   232M 		cmp $off_cmp,%edi
04:00000B37 0100
04:00000B39 0F857019  	   233M 		jne error
                      	   234M 
04:00000B3D 66BE000001	   235M 		mov $off_value,%esi
04:00000B42 00
04:00000B43 66BF000001	   236M 		mov $off_value,%edi
04:00000B48 00
04:00000B49 66B8785634	   237M 		mov $value,%eax
04:00000B4E 12
04:00000B4F 67668903  	   238M 		mov %eax,%ds:(%ebx)
04:00000B53 66B8000000	   239M 		mov $0,%eax
04:00000B58 00
04:00000B59 6766268903	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
04:00000B5E 66A5      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
04:00000B60 66B8785634	   243M 		mov $value,%eax
04:00000B65 12
                      	   244M 		.if 16 = 16
04:00000B66 6766263903	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
04:00000B6B 0F853E19  	   249M 		jne error
04:00000B6F 6681FFFCFF	   250M 		cmp $off_cmp,%edi
04:00000B74 0100
04:00000B76 0F853319  	   251M 		jne error
04:00000B7A 6681FEFCFF	   252M 		cmp $off_cmp,%esi
04:00000B7F 0100
04:00000B81 0F852819  	   253M 		jne error
                      	   254M 
04:00000B85 66BE000001	   255M 		mov $off_value,%esi
04:00000B8A 00
04:00000B8B 66B8785634	   256M 		mov $value,%eax
04:00000B90 12
04:00000B91 6766268903	   257M 		mov %eax,%es:(%ebx)
04:00000B96 6631C0    	   258M 		xor %eax,%eax
                      	   259M #		addr16
04:00000B99 66AD      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
04:00000B9B 663D785634	   261M 		cmp $value & val_mask,%eax
04:00000BA0 12
04:00000BA1 0F850819  	   262M 		jne error
04:00000BA5 6681FEFCFF	   263M 		cmp $off_cmp,%esi
04:00000BAA 0100
04:00000BAC 0F85FD18  	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   243: 	testStringReps b,0,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if b = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if b = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if b = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 0 == 0
04:00000BB0 FC        	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
                      	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00000BB1 66B8785634	    36M 	mov $0x12345678,%eax
04:00000BB6 12
04:00000BB7 66BE00FF01	    37M 	mov $off_value,%esi
04:00000BBC 00
04:00000BBD 66BF00FF01	    38M 	mov $off_value,%edi
04:00000BC2 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:00000BC3 66B8785634	    43M 	mov $0x12345678,%eax
04:00000BC8 12
04:00000BC9 66BE00FF01	    44M 	mov $off_value,%esi
04:00000BCE 00
04:00000BCF 66BF00FF01	    45M 	mov $off_value,%edi
04:00000BD4 00
04:00000BD5 66B9000100	    46M 	mov $items,%ecx
04:00000BDA 00
                      	    47M 	.if b = b
                      	    48M #		addr16
04:00000BDB F3        	    49M 		rep
04:00000BDC AA        	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if b = w
                      	    53M #		addr16
                      	    54M 		rep
                      	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if b = d
                      	    58M #		addr16
                      	    59M 		rep
                      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00000BDD 6683F900  	    62M 	cmp $0,%ecx
04:00000BE1 0F85C818  	    63M 	jnz error           		# ECX must be 0
04:00000BE5 6681FF0000	    64M 	cmp $off_cmp,%edi
04:00000BEA 0100
04:00000BEC 0F85BD18  	    65M 	jnz error
04:00000BF0 66BF00FF01	    66M 	mov $off_value,%edi  # reset EDI
04:00000BF5 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:00000BF6 8CC2      	    68M 	mov %es,%dx
04:00000BF8 8CD9      	    69M 	mov %ds,%cx
04:00000BFA 87CA      	    70M 	xchg %cx,%dx
04:00000BFC 8EC2      	    71M 	mov %dx,%es
04:00000BFE 8ED9      	    72M 	mov %cx,%ds
04:00000C00 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:00000C03 66B9000100	    75M 	mov $items,%ecx      	# reset ECX
04:00000C08 00
                      	    76M 	.if b = b
                      	    77M #		addr16
04:00000C09 F3        	    78M 		rep
04:00000C0A AA        	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if b = w
                      	    82M #		addr16
                      	    83M 		rep
                      	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if b = d
                      	    87M #		addr16
                      	    88M 		rep
                      	    89M 		stosl
                      	    90M 	.endif
04:00000C0B 66BF00FF01	    91M 	mov $off_value,%edi  	# reset EDI
04:00000C10 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:00000C11 66B9000100	    94M 	mov $items,%ecx      # reset ECX
04:00000C16 00
                      	    95M 	.if b = b
                      	    96M #		addr16
04:00000C17 F3        	    97M 		repe
04:00000C18 A6        	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if b = w
                      	   101M #		addr16
                      	   102M 		repe
                      	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if b = d
                      	   106M #		addr16
                      	   107M 		repe
                      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:00000C19 6683F900  	   110M 	cmp $0,%ecx
04:00000C1D 0F858C18  	   111M 	jnz error           		# ECX must be 0
04:00000C21 6681FE0000	   112M 	cmp $off_cmp,%esi
04:00000C26 0100
04:00000C28 0F858118  	   113M 	jne error
04:00000C2C 6681FF0000	   114M 	cmp $off_cmp,%edi
04:00000C31 0100
04:00000C33 0F857618  	   115M 	jne error
04:00000C37 66BF00FF01	   116M 	mov $off_value,%edi  # reset EDI
04:00000C3C 00
04:00000C3D 66BE00FF01	   117M 	mov $off_value,%esi  # reset ESI
04:00000C42 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:00000C43 66B9000100	   120M 	mov $items,%ecx      # reset ECX
04:00000C48 00
                      	   121M 	.if b = b
                      	   122M #		addr16
04:00000C49 F3        	   123M 		repe
04:00000C4A AE        	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if b = w
                      	   127M #		addr16
                      	   128M 		repe
                      	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if b = d
                      	   132M #		addr16
                      	   133M 		repe
                      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:00000C4B 6683F900  	   136M 	cmp $0,%ecx
04:00000C4F 0F855A18  	   137M 	jne error           		# ECX must be 0
04:00000C53 6681FF0000	   138M 	cmp $off_cmp,%edi
04:00000C58 0100
04:00000C5A 0F854F18  	   139M 	jne error
04:00000C5E 66BF00FF01	   140M 	mov $off_value,%edi  		# rewind EDI
04:00000C63 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:00000C64 66B8000000	   144M 	mov $0,%eax
04:00000C69 00
04:00000C6A 66B9000100	   145M 	mov $items,%ecx      # reset ECX
04:00000C6F 00
                      	   146M 	.if b = b
                      	   147M #		addr16
04:00000C70 F3        	   148M 		rep
04:00000C71 AA        	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if b = w
                      	   152M #		addr16
                      	   153M 		rep
                      	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if b = d
                      	   157M #		addr16
                      	   158M 		rep
                      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:00000C72 66BF00FF01	   161M 	mov $off_value,%edi  # reset EDI
04:00000C77 00
04:00000C78 66B9000100	   162M 	mov $items,%ecx      # reset ECX
04:00000C7D 00
                      	   163M 	.if b = b
                      	   164M #		addr16
04:00000C7E F3        	   165M 		rep
04:00000C7F A4        	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if b = w
                      	   169M #		addr16
                      	   170M 		rep
                      	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if b = d
                      	   174M #		addr16
                      	   175M 		rep
                      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:00000C80 6683F900  	   178M 	cmp $0,%ecx
04:00000C84 0F852518  	   179M 	jne error           	# ECX must be 0
04:00000C88 6681FE0000	   180M 	cmp $off_cmp,%esi
04:00000C8D 0100
04:00000C8F 0F851A18  	   181M 	jne error
04:00000C93 6681FF0000	   182M 	cmp $off_cmp,%edi
04:00000C98 0100
04:00000C9A 0F850F18  	   183M 	jne error
04:00000C9E 66B9000100	   184M 	mov $items,%ecx      	# reset ECX
04:00000CA3 00
04:00000CA4 66BF00FF01	   185M 	mov $off_value,%edi  	# reset EDI
04:00000CA9 00
04:00000CAA 66BE00FF01	   186M 	mov $off_value,%esi  	# reset ESI
04:00000CAF 00
                      	   187M 	.if b = b
                      	   188M #		addr16
04:00000CB0 F3        	   189M 		repe
04:00000CB1 A6        	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if b = w
                      	   193M #		addr16
                      	   194M 		repe
                      	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if b = d
                      	   198M #		addr16
                      	   199M 		repe
                      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00000CB2 6683F900  	   202M 	cmp $0,%ecx
04:00000CB6 0F85F317  	   203M 	jne error           # ECX must be 0
04:00000CBA 6681FE0000	   204M 	cmp $off_cmp,%esi
04:00000CBF 0100
04:00000CC1 0F85E817  	   205M 	jne error
04:00000CC5 6681FF0000	   206M 	cmp $off_cmp,%edi
04:00000CCA 0100
04:00000CCC 0F85DD17  	   207M 	jne error
                      	   244: 	testStringReps w,0,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if w = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if w = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if w = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 0 == 0
04:00000CD0 FC        	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
                      	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00000CD1 66B8785634	    36M 	mov $0x12345678,%eax
04:00000CD6 12
04:00000CD7 66BE00FF01	    37M 	mov $off_value,%esi
04:00000CDC 00
04:00000CDD 66BF00FF01	    38M 	mov $off_value,%edi
04:00000CE2 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:00000CE3 66B8785634	    43M 	mov $0x12345678,%eax
04:00000CE8 12
04:00000CE9 66BE00FF01	    44M 	mov $off_value,%esi
04:00000CEE 00
04:00000CEF 66BF00FF01	    45M 	mov $off_value,%edi
04:00000CF4 00
04:00000CF5 66B9800000	    46M 	mov $items,%ecx
04:00000CFA 00
                      	    47M 	.if w = b
                      	    48M #		addr16
                      	    49M 		rep
                      	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if w = w
                      	    53M #		addr16
04:00000CFB F3        	    54M 		rep
04:00000CFC AB        	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if w = d
                      	    58M #		addr16
                      	    59M 		rep
                      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00000CFD 6683F900  	    62M 	cmp $0,%ecx
04:00000D01 0F85A817  	    63M 	jnz error           		# ECX must be 0
04:00000D05 6681FF0000	    64M 	cmp $off_cmp,%edi
04:00000D0A 0100
04:00000D0C 0F859D17  	    65M 	jnz error
04:00000D10 66BF00FF01	    66M 	mov $off_value,%edi  # reset EDI
04:00000D15 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:00000D16 8CC2      	    68M 	mov %es,%dx
04:00000D18 8CD9      	    69M 	mov %ds,%cx
04:00000D1A 87CA      	    70M 	xchg %cx,%dx
04:00000D1C 8EC2      	    71M 	mov %dx,%es
04:00000D1E 8ED9      	    72M 	mov %cx,%ds
04:00000D20 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:00000D23 66B9800000	    75M 	mov $items,%ecx      	# reset ECX
04:00000D28 00
                      	    76M 	.if w = b
                      	    77M #		addr16
                      	    78M 		rep
                      	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if w = w
                      	    82M #		addr16
04:00000D29 F3        	    83M 		rep
04:00000D2A AB        	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if w = d
                      	    87M #		addr16
                      	    88M 		rep
                      	    89M 		stosl
                      	    90M 	.endif
04:00000D2B 66BF00FF01	    91M 	mov $off_value,%edi  	# reset EDI
04:00000D30 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:00000D31 66B9800000	    94M 	mov $items,%ecx      # reset ECX
04:00000D36 00
                      	    95M 	.if w = b
                      	    96M #		addr16
                      	    97M 		repe
                      	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if w = w
                      	   101M #		addr16
04:00000D37 F3        	   102M 		repe
04:00000D38 A7        	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if w = d
                      	   106M #		addr16
                      	   107M 		repe
                      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:00000D39 6683F900  	   110M 	cmp $0,%ecx
04:00000D3D 0F856C17  	   111M 	jnz error           		# ECX must be 0
04:00000D41 6681FE0000	   112M 	cmp $off_cmp,%esi
04:00000D46 0100
04:00000D48 0F856117  	   113M 	jne error
04:00000D4C 6681FF0000	   114M 	cmp $off_cmp,%edi
04:00000D51 0100
04:00000D53 0F855617  	   115M 	jne error
04:00000D57 66BF00FF01	   116M 	mov $off_value,%edi  # reset EDI
04:00000D5C 00
04:00000D5D 66BE00FF01	   117M 	mov $off_value,%esi  # reset ESI
04:00000D62 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:00000D63 66B9800000	   120M 	mov $items,%ecx      # reset ECX
04:00000D68 00
                      	   121M 	.if w = b
                      	   122M #		addr16
                      	   123M 		repe
                      	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if w = w
                      	   127M #		addr16
04:00000D69 F3        	   128M 		repe
04:00000D6A AF        	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if w = d
                      	   132M #		addr16
                      	   133M 		repe
                      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:00000D6B 6683F900  	   136M 	cmp $0,%ecx
04:00000D6F 0F853A17  	   137M 	jne error           		# ECX must be 0
04:00000D73 6681FF0000	   138M 	cmp $off_cmp,%edi
04:00000D78 0100
04:00000D7A 0F852F17  	   139M 	jne error
04:00000D7E 66BF00FF01	   140M 	mov $off_value,%edi  		# rewind EDI
04:00000D83 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:00000D84 66B8000000	   144M 	mov $0,%eax
04:00000D89 00
04:00000D8A 66B9800000	   145M 	mov $items,%ecx      # reset ECX
04:00000D8F 00
                      	   146M 	.if w = b
                      	   147M #		addr16
                      	   148M 		rep
                      	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if w = w
                      	   152M #		addr16
04:00000D90 F3        	   153M 		rep
04:00000D91 AB        	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if w = d
                      	   157M #		addr16
                      	   158M 		rep
                      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:00000D92 66BF00FF01	   161M 	mov $off_value,%edi  # reset EDI
04:00000D97 00
04:00000D98 66B9800000	   162M 	mov $items,%ecx      # reset ECX
04:00000D9D 00
                      	   163M 	.if w = b
                      	   164M #		addr16
                      	   165M 		rep
                      	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if w = w
                      	   169M #		addr16
04:00000D9E F3        	   170M 		rep
04:00000D9F A5        	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if w = d
                      	   174M #		addr16
                      	   175M 		rep
                      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:00000DA0 6683F900  	   178M 	cmp $0,%ecx
04:00000DA4 0F850517  	   179M 	jne error           	# ECX must be 0
04:00000DA8 6681FE0000	   180M 	cmp $off_cmp,%esi
04:00000DAD 0100
04:00000DAF 0F85FA16  	   181M 	jne error
04:00000DB3 6681FF0000	   182M 	cmp $off_cmp,%edi
04:00000DB8 0100
04:00000DBA 0F85EF16  	   183M 	jne error
04:00000DBE 66B9800000	   184M 	mov $items,%ecx      	# reset ECX
04:00000DC3 00
04:00000DC4 66BF00FF01	   185M 	mov $off_value,%edi  	# reset EDI
04:00000DC9 00
04:00000DCA 66BE00FF01	   186M 	mov $off_value,%esi  	# reset ESI
04:00000DCF 00
                      	   187M 	.if w = b
                      	   188M #		addr16
                      	   189M 		repe
                      	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if w = w
                      	   193M #		addr16
04:00000DD0 F3        	   194M 		repe
04:00000DD1 A7        	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if w = d
                      	   198M #		addr16
                      	   199M 		repe
                      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00000DD2 6683F900  	   202M 	cmp $0,%ecx
04:00000DD6 0F85D316  	   203M 	jne error           # ECX must be 0
04:00000DDA 6681FE0000	   204M 	cmp $off_cmp,%esi
04:00000DDF 0100
04:00000DE1 0F85C816  	   205M 	jne error
04:00000DE5 6681FF0000	   206M 	cmp $off_cmp,%edi
04:00000DEA 0100
04:00000DEC 0F85BD16  	   207M 	jne error
                      	   245: 	testStringReps d,0,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if d = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if d = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if d = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 0 == 0
04:00000DF0 FC        	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
                      	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00000DF1 66B8785634	    36M 	mov $0x12345678,%eax
04:00000DF6 12
04:00000DF7 66BE00FF01	    37M 	mov $off_value,%esi
04:00000DFC 00
04:00000DFD 66BF00FF01	    38M 	mov $off_value,%edi
04:00000E02 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:00000E03 66B8785634	    43M 	mov $0x12345678,%eax
04:00000E08 12
04:00000E09 66BE00FF01	    44M 	mov $off_value,%esi
04:00000E0E 00
04:00000E0F 66BF00FF01	    45M 	mov $off_value,%edi
04:00000E14 00
04:00000E15 66B9400000	    46M 	mov $items,%ecx
04:00000E1A 00
                      	    47M 	.if d = b
                      	    48M #		addr16
                      	    49M 		rep
                      	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if d = w
                      	    53M #		addr16
                      	    54M 		rep
                      	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if d = d
                      	    58M #		addr16
04:00000E1B F3        	    59M 		rep
04:00000E1C 66AB      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00000E1E 6683F900  	    62M 	cmp $0,%ecx
04:00000E22 0F858716  	    63M 	jnz error           		# ECX must be 0
04:00000E26 6681FF0000	    64M 	cmp $off_cmp,%edi
04:00000E2B 0100
04:00000E2D 0F857C16  	    65M 	jnz error
04:00000E31 66BF00FF01	    66M 	mov $off_value,%edi  # reset EDI
04:00000E36 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:00000E37 8CC2      	    68M 	mov %es,%dx
04:00000E39 8CD9      	    69M 	mov %ds,%cx
04:00000E3B 87CA      	    70M 	xchg %cx,%dx
04:00000E3D 8EC2      	    71M 	mov %dx,%es
04:00000E3F 8ED9      	    72M 	mov %cx,%ds
04:00000E41 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:00000E44 66B9400000	    75M 	mov $items,%ecx      	# reset ECX
04:00000E49 00
                      	    76M 	.if d = b
                      	    77M #		addr16
                      	    78M 		rep
                      	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if d = w
                      	    82M #		addr16
                      	    83M 		rep
                      	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if d = d
                      	    87M #		addr16
04:00000E4A F3        	    88M 		rep
04:00000E4B 66AB      	    89M 		stosl
                      	    90M 	.endif
04:00000E4D 66BF00FF01	    91M 	mov $off_value,%edi  	# reset EDI
04:00000E52 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:00000E53 66B9400000	    94M 	mov $items,%ecx      # reset ECX
04:00000E58 00
                      	    95M 	.if d = b
                      	    96M #		addr16
                      	    97M 		repe
                      	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if d = w
                      	   101M #		addr16
                      	   102M 		repe
                      	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if d = d
                      	   106M #		addr16
04:00000E59 F3        	   107M 		repe
04:00000E5A 66A7      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:00000E5C 6683F900  	   110M 	cmp $0,%ecx
04:00000E60 0F854916  	   111M 	jnz error           		# ECX must be 0
04:00000E64 6681FE0000	   112M 	cmp $off_cmp,%esi
04:00000E69 0100
04:00000E6B 0F853E16  	   113M 	jne error
04:00000E6F 6681FF0000	   114M 	cmp $off_cmp,%edi
04:00000E74 0100
04:00000E76 0F853316  	   115M 	jne error
04:00000E7A 66BF00FF01	   116M 	mov $off_value,%edi  # reset EDI
04:00000E7F 00
04:00000E80 66BE00FF01	   117M 	mov $off_value,%esi  # reset ESI
04:00000E85 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:00000E86 66B9400000	   120M 	mov $items,%ecx      # reset ECX
04:00000E8B 00
                      	   121M 	.if d = b
                      	   122M #		addr16
                      	   123M 		repe
                      	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if d = w
                      	   127M #		addr16
                      	   128M 		repe
                      	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if d = d
                      	   132M #		addr16
04:00000E8C F3        	   133M 		repe
04:00000E8D 66AF      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:00000E8F 6683F900  	   136M 	cmp $0,%ecx
04:00000E93 0F851616  	   137M 	jne error           		# ECX must be 0
04:00000E97 6681FF0000	   138M 	cmp $off_cmp,%edi
04:00000E9C 0100
04:00000E9E 0F850B16  	   139M 	jne error
04:00000EA2 66BF00FF01	   140M 	mov $off_value,%edi  		# rewind EDI
04:00000EA7 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:00000EA8 66B8000000	   144M 	mov $0,%eax
04:00000EAD 00
04:00000EAE 66B9400000	   145M 	mov $items,%ecx      # reset ECX
04:00000EB3 00
                      	   146M 	.if d = b
                      	   147M #		addr16
                      	   148M 		rep
                      	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if d = w
                      	   152M #		addr16
                      	   153M 		rep
                      	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if d = d
                      	   157M #		addr16
04:00000EB4 F3        	   158M 		rep
04:00000EB5 66AB      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:00000EB7 66BF00FF01	   161M 	mov $off_value,%edi  # reset EDI
04:00000EBC 00
04:00000EBD 66B9400000	   162M 	mov $items,%ecx      # reset ECX
04:00000EC2 00
                      	   163M 	.if d = b
                      	   164M #		addr16
                      	   165M 		rep
                      	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if d = w
                      	   169M #		addr16
                      	   170M 		rep
                      	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if d = d
                      	   174M #		addr16
04:00000EC3 F3        	   175M 		rep
04:00000EC4 66A5      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:00000EC6 6683F900  	   178M 	cmp $0,%ecx
04:00000ECA 0F85DF15  	   179M 	jne error           	# ECX must be 0
04:00000ECE 6681FE0000	   180M 	cmp $off_cmp,%esi
04:00000ED3 0100
04:00000ED5 0F85D415  	   181M 	jne error
04:00000ED9 6681FF0000	   182M 	cmp $off_cmp,%edi
04:00000EDE 0100
04:00000EE0 0F85C915  	   183M 	jne error
04:00000EE4 66B9400000	   184M 	mov $items,%ecx      	# reset ECX
04:00000EE9 00
04:00000EEA 66BF00FF01	   185M 	mov $off_value,%edi  	# reset EDI
04:00000EEF 00
04:00000EF0 66BE00FF01	   186M 	mov $off_value,%esi  	# reset ESI
04:00000EF5 00
                      	   187M 	.if d = b
                      	   188M #		addr16
                      	   189M 		repe
                      	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if d = w
                      	   193M #		addr16
                      	   194M 		repe
                      	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if d = d
                      	   198M #		addr16
04:00000EF6 F3        	   199M 		repe
04:00000EF7 66A7      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00000EF9 6683F900  	   202M 	cmp $0,%ecx
04:00000EFD 0F85AC15  	   203M 	jne error           # ECX must be 0
04:00000F01 6681FE0000	   204M 	cmp $off_cmp,%esi
04:00000F06 0100
04:00000F08 0F85A115  	   205M 	jne error
04:00000F0C 6681FF0000	   206M 	cmp $off_cmp,%edi
04:00000F11 0100
04:00000F13 0F859615  	   207M 	jne error
                      	   246: 	testStringReps b,1,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if b = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if b = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if b = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 1 == 0
                      	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
04:00000F17 FD        	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00000F18 66B8785634	    36M 	mov $0x12345678,%eax
04:00000F1D 12
04:00000F1E 66BEFF0001	    37M 	mov $off_value,%esi
04:00000F23 00
04:00000F24 66BFFF0001	    38M 	mov $off_value,%edi
04:00000F29 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:00000F2A 66B8785634	    43M 	mov $0x12345678,%eax
04:00000F2F 12
04:00000F30 66BEFF0001	    44M 	mov $off_value,%esi
04:00000F35 00
04:00000F36 66BFFF0001	    45M 	mov $off_value,%edi
04:00000F3B 00
04:00000F3C 66B9000100	    46M 	mov $items,%ecx
04:00000F41 00
                      	    47M 	.if b = b
                      	    48M #		addr16
04:00000F42 F3        	    49M 		rep
04:00000F43 AA        	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if b = w
                      	    53M #		addr16
                      	    54M 		rep
                      	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if b = d
                      	    58M #		addr16
                      	    59M 		rep
                      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00000F44 6683F900  	    62M 	cmp $0,%ecx
04:00000F48 0F856115  	    63M 	jnz error           		# ECX must be 0
04:00000F4C 6681FFFFFF	    64M 	cmp $off_cmp,%edi
04:00000F51 0100
04:00000F53 0F855615  	    65M 	jnz error
04:00000F57 66BFFF0001	    66M 	mov $off_value,%edi  # reset EDI
04:00000F5C 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:00000F5D 8CC2      	    68M 	mov %es,%dx
04:00000F5F 8CD9      	    69M 	mov %ds,%cx
04:00000F61 87CA      	    70M 	xchg %cx,%dx
04:00000F63 8EC2      	    71M 	mov %dx,%es
04:00000F65 8ED9      	    72M 	mov %cx,%ds
04:00000F67 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:00000F6A 66B9000100	    75M 	mov $items,%ecx      	# reset ECX
04:00000F6F 00
                      	    76M 	.if b = b
                      	    77M #		addr16
04:00000F70 F3        	    78M 		rep
04:00000F71 AA        	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if b = w
                      	    82M #		addr16
                      	    83M 		rep
                      	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if b = d
                      	    87M #		addr16
                      	    88M 		rep
                      	    89M 		stosl
                      	    90M 	.endif
04:00000F72 66BFFF0001	    91M 	mov $off_value,%edi  	# reset EDI
04:00000F77 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:00000F78 66B9000100	    94M 	mov $items,%ecx      # reset ECX
04:00000F7D 00
                      	    95M 	.if b = b
                      	    96M #		addr16
04:00000F7E F3        	    97M 		repe
04:00000F7F A6        	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if b = w
                      	   101M #		addr16
                      	   102M 		repe
                      	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if b = d
                      	   106M #		addr16
                      	   107M 		repe
                      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:00000F80 6683F900  	   110M 	cmp $0,%ecx
04:00000F84 0F852515  	   111M 	jnz error           		# ECX must be 0
04:00000F88 6681FEFFFF	   112M 	cmp $off_cmp,%esi
04:00000F8D 0100
04:00000F8F 0F851A15  	   113M 	jne error
04:00000F93 6681FFFFFF	   114M 	cmp $off_cmp,%edi
04:00000F98 0100
04:00000F9A 0F850F15  	   115M 	jne error
04:00000F9E 66BFFF0001	   116M 	mov $off_value,%edi  # reset EDI
04:00000FA3 00
04:00000FA4 66BEFF0001	   117M 	mov $off_value,%esi  # reset ESI
04:00000FA9 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:00000FAA 66B9000100	   120M 	mov $items,%ecx      # reset ECX
04:00000FAF 00
                      	   121M 	.if b = b
                      	   122M #		addr16
04:00000FB0 F3        	   123M 		repe
04:00000FB1 AE        	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if b = w
                      	   127M #		addr16
                      	   128M 		repe
                      	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if b = d
                      	   132M #		addr16
                      	   133M 		repe
                      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:00000FB2 6683F900  	   136M 	cmp $0,%ecx
04:00000FB6 0F85F314  	   137M 	jne error           		# ECX must be 0
04:00000FBA 6681FFFFFF	   138M 	cmp $off_cmp,%edi
04:00000FBF 0100
04:00000FC1 0F85E814  	   139M 	jne error
04:00000FC5 66BFFF0001	   140M 	mov $off_value,%edi  		# rewind EDI
04:00000FCA 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:00000FCB 66B8000000	   144M 	mov $0,%eax
04:00000FD0 00
04:00000FD1 66B9000100	   145M 	mov $items,%ecx      # reset ECX
04:00000FD6 00
                      	   146M 	.if b = b
                      	   147M #		addr16
04:00000FD7 F3        	   148M 		rep
04:00000FD8 AA        	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if b = w
                      	   152M #		addr16
                      	   153M 		rep
                      	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if b = d
                      	   157M #		addr16
                      	   158M 		rep
                      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:00000FD9 66BFFF0001	   161M 	mov $off_value,%edi  # reset EDI
04:00000FDE 00
04:00000FDF 66B9000100	   162M 	mov $items,%ecx      # reset ECX
04:00000FE4 00
                      	   163M 	.if b = b
                      	   164M #		addr16
04:00000FE5 F3        	   165M 		rep
04:00000FE6 A4        	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if b = w
                      	   169M #		addr16
                      	   170M 		rep
                      	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if b = d
                      	   174M #		addr16
                      	   175M 		rep
                      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:00000FE7 6683F900  	   178M 	cmp $0,%ecx
04:00000FEB 0F85BE14  	   179M 	jne error           	# ECX must be 0
04:00000FEF 6681FEFFFF	   180M 	cmp $off_cmp,%esi
04:00000FF4 0100
04:00000FF6 0F85B314  	   181M 	jne error
04:00000FFA 6681FFFFFF	   182M 	cmp $off_cmp,%edi
04:00000FFF 0100
04:00001001 0F85A814  	   183M 	jne error
04:00001005 66B9000100	   184M 	mov $items,%ecx      	# reset ECX
04:0000100A 00
04:0000100B 66BFFF0001	   185M 	mov $off_value,%edi  	# reset EDI
04:00001010 00
04:00001011 66BEFF0001	   186M 	mov $off_value,%esi  	# reset ESI
04:00001016 00
                      	   187M 	.if b = b
                      	   188M #		addr16
04:00001017 F3        	   189M 		repe
04:00001018 A6        	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if b = w
                      	   193M #		addr16
                      	   194M 		repe
                      	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if b = d
                      	   198M #		addr16
                      	   199M 		repe
                      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00001019 6683F900  	   202M 	cmp $0,%ecx
04:0000101D 0F858C14  	   203M 	jne error           # ECX must be 0
04:00001021 6681FEFFFF	   204M 	cmp $off_cmp,%esi
04:00001026 0100
04:00001028 0F858114  	   205M 	jne error
04:0000102C 6681FFFFFF	   206M 	cmp $off_cmp,%edi
04:00001031 0100
04:00001033 0F857614  	   207M 	jne error
                      	   247: 	testStringReps w,1,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if w = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if w = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if w = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 1 == 0
                      	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
04:00001037 FD        	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00001038 66B8785634	    36M 	mov $0x12345678,%eax
04:0000103D 12
04:0000103E 66BEFF0001	    37M 	mov $off_value,%esi
04:00001043 00
04:00001044 66BFFF0001	    38M 	mov $off_value,%edi
04:00001049 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:0000104A 66B8785634	    43M 	mov $0x12345678,%eax
04:0000104F 12
04:00001050 66BEFF0001	    44M 	mov $off_value,%esi
04:00001055 00
04:00001056 66BFFF0001	    45M 	mov $off_value,%edi
04:0000105B 00
04:0000105C 66B9800000	    46M 	mov $items,%ecx
04:00001061 00
                      	    47M 	.if w = b
                      	    48M #		addr16
                      	    49M 		rep
                      	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if w = w
                      	    53M #		addr16
04:00001062 F3        	    54M 		rep
04:00001063 AB        	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if w = d
                      	    58M #		addr16
                      	    59M 		rep
                      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00001064 6683F900  	    62M 	cmp $0,%ecx
04:00001068 0F854114  	    63M 	jnz error           		# ECX must be 0
04:0000106C 6681FFFFFF	    64M 	cmp $off_cmp,%edi
04:00001071 0100
04:00001073 0F853614  	    65M 	jnz error
04:00001077 66BFFF0001	    66M 	mov $off_value,%edi  # reset EDI
04:0000107C 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:0000107D 8CC2      	    68M 	mov %es,%dx
04:0000107F 8CD9      	    69M 	mov %ds,%cx
04:00001081 87CA      	    70M 	xchg %cx,%dx
04:00001083 8EC2      	    71M 	mov %dx,%es
04:00001085 8ED9      	    72M 	mov %cx,%ds
04:00001087 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:0000108A 66B9800000	    75M 	mov $items,%ecx      	# reset ECX
04:0000108F 00
                      	    76M 	.if w = b
                      	    77M #		addr16
                      	    78M 		rep
                      	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if w = w
                      	    82M #		addr16
04:00001090 F3        	    83M 		rep
04:00001091 AB        	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if w = d
                      	    87M #		addr16
                      	    88M 		rep
                      	    89M 		stosl
                      	    90M 	.endif
04:00001092 66BFFF0001	    91M 	mov $off_value,%edi  	# reset EDI
04:00001097 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:00001098 66B9800000	    94M 	mov $items,%ecx      # reset ECX
04:0000109D 00
                      	    95M 	.if w = b
                      	    96M #		addr16
                      	    97M 		repe
                      	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if w = w
                      	   101M #		addr16
04:0000109E F3        	   102M 		repe
04:0000109F A7        	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if w = d
                      	   106M #		addr16
                      	   107M 		repe
                      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:000010A0 6683F900  	   110M 	cmp $0,%ecx
04:000010A4 0F850514  	   111M 	jnz error           		# ECX must be 0
04:000010A8 6681FEFFFF	   112M 	cmp $off_cmp,%esi
04:000010AD 0100
04:000010AF 0F85FA13  	   113M 	jne error
04:000010B3 6681FFFFFF	   114M 	cmp $off_cmp,%edi
04:000010B8 0100
04:000010BA 0F85EF13  	   115M 	jne error
04:000010BE 66BFFF0001	   116M 	mov $off_value,%edi  # reset EDI
04:000010C3 00
04:000010C4 66BEFF0001	   117M 	mov $off_value,%esi  # reset ESI
04:000010C9 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:000010CA 66B9800000	   120M 	mov $items,%ecx      # reset ECX
04:000010CF 00
                      	   121M 	.if w = b
                      	   122M #		addr16
                      	   123M 		repe
                      	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if w = w
                      	   127M #		addr16
04:000010D0 F3        	   128M 		repe
04:000010D1 AF        	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if w = d
                      	   132M #		addr16
                      	   133M 		repe
                      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:000010D2 6683F900  	   136M 	cmp $0,%ecx
04:000010D6 0F85D313  	   137M 	jne error           		# ECX must be 0
04:000010DA 6681FFFFFF	   138M 	cmp $off_cmp,%edi
04:000010DF 0100
04:000010E1 0F85C813  	   139M 	jne error
04:000010E5 66BFFF0001	   140M 	mov $off_value,%edi  		# rewind EDI
04:000010EA 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:000010EB 66B8000000	   144M 	mov $0,%eax
04:000010F0 00
04:000010F1 66B9800000	   145M 	mov $items,%ecx      # reset ECX
04:000010F6 00
                      	   146M 	.if w = b
                      	   147M #		addr16
                      	   148M 		rep
                      	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if w = w
                      	   152M #		addr16
04:000010F7 F3        	   153M 		rep
04:000010F8 AB        	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if w = d
                      	   157M #		addr16
                      	   158M 		rep
                      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:000010F9 66BFFF0001	   161M 	mov $off_value,%edi  # reset EDI
04:000010FE 00
04:000010FF 66B9800000	   162M 	mov $items,%ecx      # reset ECX
04:00001104 00
                      	   163M 	.if w = b
                      	   164M #		addr16
                      	   165M 		rep
                      	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if w = w
                      	   169M #		addr16
04:00001105 F3        	   170M 		rep
04:00001106 A5        	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if w = d
                      	   174M #		addr16
                      	   175M 		rep
                      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:00001107 6683F900  	   178M 	cmp $0,%ecx
04:0000110B 0F859E13  	   179M 	jne error           	# ECX must be 0
04:0000110F 6681FEFFFF	   180M 	cmp $off_cmp,%esi
04:00001114 0100
04:00001116 0F859313  	   181M 	jne error
04:0000111A 6681FFFFFF	   182M 	cmp $off_cmp,%edi
04:0000111F 0100
04:00001121 0F858813  	   183M 	jne error
04:00001125 66B9800000	   184M 	mov $items,%ecx      	# reset ECX
04:0000112A 00
04:0000112B 66BFFF0001	   185M 	mov $off_value,%edi  	# reset EDI
04:00001130 00
04:00001131 66BEFF0001	   186M 	mov $off_value,%esi  	# reset ESI
04:00001136 00
                      	   187M 	.if w = b
                      	   188M #		addr16
                      	   189M 		repe
                      	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if w = w
                      	   193M #		addr16
04:00001137 F3        	   194M 		repe
04:00001138 A7        	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if w = d
                      	   198M #		addr16
                      	   199M 		repe
                      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00001139 6683F900  	   202M 	cmp $0,%ecx
04:0000113D 0F856C13  	   203M 	jne error           # ECX must be 0
04:00001141 6681FEFFFF	   204M 	cmp $off_cmp,%esi
04:00001146 0100
04:00001148 0F856113  	   205M 	jne error
04:0000114C 6681FFFFFF	   206M 	cmp $off_cmp,%edi
04:00001151 0100
04:00001153 0F855613  	   207M 	jne error
                      	   248: 	testStringReps d,1,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if d = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if d = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if d = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 1 == 0
                      	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
04:00001157 FD        	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00001158 66B8785634	    36M 	mov $0x12345678,%eax
04:0000115D 12
04:0000115E 66BEFF0001	    37M 	mov $off_value,%esi
04:00001163 00
04:00001164 66BFFF0001	    38M 	mov $off_value,%edi
04:00001169 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:0000116A 66B8785634	    43M 	mov $0x12345678,%eax
04:0000116F 12
04:00001170 66BEFF0001	    44M 	mov $off_value,%esi
04:00001175 00
04:00001176 66BFFF0001	    45M 	mov $off_value,%edi
04:0000117B 00
04:0000117C 66B9400000	    46M 	mov $items,%ecx
04:00001181 00
                      	    47M 	.if d = b
                      	    48M #		addr16
                      	    49M 		rep
                      	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if d = w
                      	    53M #		addr16
                      	    54M 		rep
                      	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if d = d
                      	    58M #		addr16
04:00001182 F3        	    59M 		rep
04:00001183 66AB      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00001185 6683F900  	    62M 	cmp $0,%ecx
04:00001189 0F852013  	    63M 	jnz error           		# ECX must be 0
04:0000118D 6681FFFFFF	    64M 	cmp $off_cmp,%edi
04:00001192 0100
04:00001194 0F851513  	    65M 	jnz error
04:00001198 66BFFF0001	    66M 	mov $off_value,%edi  # reset EDI
04:0000119D 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:0000119E 8CC2      	    68M 	mov %es,%dx
04:000011A0 8CD9      	    69M 	mov %ds,%cx
04:000011A2 87CA      	    70M 	xchg %cx,%dx
04:000011A4 8EC2      	    71M 	mov %dx,%es
04:000011A6 8ED9      	    72M 	mov %cx,%ds
04:000011A8 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:000011AB 66B9400000	    75M 	mov $items,%ecx      	# reset ECX
04:000011B0 00
                      	    76M 	.if d = b
                      	    77M #		addr16
                      	    78M 		rep
                      	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if d = w
                      	    82M #		addr16
                      	    83M 		rep
                      	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if d = d
                      	    87M #		addr16
04:000011B1 F3        	    88M 		rep
04:000011B2 66AB      	    89M 		stosl
                      	    90M 	.endif
04:000011B4 66BFFF0001	    91M 	mov $off_value,%edi  	# reset EDI
04:000011B9 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:000011BA 66B9400000	    94M 	mov $items,%ecx      # reset ECX
04:000011BF 00
                      	    95M 	.if d = b
                      	    96M #		addr16
                      	    97M 		repe
                      	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if d = w
                      	   101M #		addr16
                      	   102M 		repe
                      	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if d = d
                      	   106M #		addr16
04:000011C0 F3        	   107M 		repe
04:000011C1 66A7      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:000011C3 6683F900  	   110M 	cmp $0,%ecx
04:000011C7 0F85E212  	   111M 	jnz error           		# ECX must be 0
04:000011CB 6681FEFFFF	   112M 	cmp $off_cmp,%esi
04:000011D0 0100
04:000011D2 0F85D712  	   113M 	jne error
04:000011D6 6681FFFFFF	   114M 	cmp $off_cmp,%edi
04:000011DB 0100
04:000011DD 0F85CC12  	   115M 	jne error
04:000011E1 66BFFF0001	   116M 	mov $off_value,%edi  # reset EDI
04:000011E6 00
04:000011E7 66BEFF0001	   117M 	mov $off_value,%esi  # reset ESI
04:000011EC 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:000011ED 66B9400000	   120M 	mov $items,%ecx      # reset ECX
04:000011F2 00
                      	   121M 	.if d = b
                      	   122M #		addr16
                      	   123M 		repe
                      	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if d = w
                      	   127M #		addr16
                      	   128M 		repe
                      	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if d = d
                      	   132M #		addr16
04:000011F3 F3        	   133M 		repe
04:000011F4 66AF      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:000011F6 6683F900  	   136M 	cmp $0,%ecx
04:000011FA 0F85AF12  	   137M 	jne error           		# ECX must be 0
04:000011FE 6681FFFFFF	   138M 	cmp $off_cmp,%edi
04:00001203 0100
04:00001205 0F85A412  	   139M 	jne error
04:00001209 66BFFF0001	   140M 	mov $off_value,%edi  		# rewind EDI
04:0000120E 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:0000120F 66B8000000	   144M 	mov $0,%eax
04:00001214 00
04:00001215 66B9400000	   145M 	mov $items,%ecx      # reset ECX
04:0000121A 00
                      	   146M 	.if d = b
                      	   147M #		addr16
                      	   148M 		rep
                      	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if d = w
                      	   152M #		addr16
                      	   153M 		rep
                      	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if d = d
                      	   157M #		addr16
04:0000121B F3        	   158M 		rep
04:0000121C 66AB      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:0000121E 66BFFF0001	   161M 	mov $off_value,%edi  # reset EDI
04:00001223 00
04:00001224 66B9400000	   162M 	mov $items,%ecx      # reset ECX
04:00001229 00
                      	   163M 	.if d = b
                      	   164M #		addr16
                      	   165M 		rep
                      	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if d = w
                      	   169M #		addr16
                      	   170M 		rep
                      	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if d = d
                      	   174M #		addr16
04:0000122A F3        	   175M 		rep
04:0000122B 66A5      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:0000122D 6683F900  	   178M 	cmp $0,%ecx
04:00001231 0F857812  	   179M 	jne error           	# ECX must be 0
04:00001235 6681FEFFFF	   180M 	cmp $off_cmp,%esi
04:0000123A 0100
04:0000123C 0F856D12  	   181M 	jne error
04:00001240 6681FFFFFF	   182M 	cmp $off_cmp,%edi
04:00001245 0100
04:00001247 0F856212  	   183M 	jne error
04:0000124B 66B9400000	   184M 	mov $items,%ecx      	# reset ECX
04:00001250 00
04:00001251 66BFFF0001	   185M 	mov $off_value,%edi  	# reset EDI
04:00001256 00
04:00001257 66BEFF0001	   186M 	mov $off_value,%esi  	# reset ESI
04:0000125C 00
                      	   187M 	.if d = b
                      	   188M #		addr16
                      	   189M 		repe
                      	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if d = w
                      	   193M #		addr16
                      	   194M 		repe
                      	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if d = d
                      	   198M #		addr16
04:0000125D F3        	   199M 		repe
04:0000125E 66A7      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00001260 6683F900  	   202M 	cmp $0,%ecx
04:00001264 0F854512  	   203M 	jne error           # ECX must be 0
04:00001268 6681FEFFFF	   204M 	cmp $off_cmp,%esi
04:0000126D 0100
04:0000126F 0F853A12  	   205M 	jne error
04:00001273 6681FFFFFF	   206M 	cmp $off_cmp,%edi
04:00001278 0100
04:0000127A 0F852F12  	   207M 	jne error
                      	   249: 
                      	   250: 	advTestSegReal
                      	     1M 	advTestBase
                      	     1M 	.set TEST_BASE1,TEST_BASE1+0x1000
                      	     2M 	.set TEST_BASE2,TEST_BASE2+0x1000
                      	     2M 	.set D1_SEG_REAL,TEST_BASE1 >> 4
                      	     3M 	.set D2_SEG_REAL,TEST_BASE2 >> 4
04:0000127E C7C200C2  	     4M 	mov $D1_SEG_REAL,%dx
04:00001282 8EDA      	     5M 	mov %dx,%ds
04:00001284 C7C200C4  	     6M 	mov $D2_SEG_REAL,%dx
04:00001288 8EC2      	     7M 	mov %dx,%es
                      	   251: 
                      	   252: .include "call_m.asm"

Source: "call_m.asm"
                      	     1: #
                      	     2: #   Tests Call near by displacement and register indirect
                      	     3: #   Stack must be initilized.
                      	     4: #   %1: stack pointer register
                      	     5: #   Uses: AX, EBX, Flags
                      	     6: #
                      	     7: .macro testCallNear arg1
                      	     8: 
                      	     9: 	.ifc \arg1, sp
                      	    10: 		mov %\arg1,%ax
                      	    11: rel16\@:
                      	    12: 		clc
                      	    13: #		data16
                      	    14: 		callw nearfn16\@
                      	    15: 		jnc error
                      	    16: 		jmp rel32\@
                      	    17: nearfn16\@:
                      	    18: 		sub $2,%ax
                      	    19: 		cmp %ax,%\arg1
                      	    20: 		jne error
                      	    21: 		add $2,%ax
                      	    22: 		stc
                      	    23: #		data16
                      	    24: 		ret
                      	    25: 		jmp error
                      	    26: 
                      	    27: rel32\@:
                      	    28: 		clc
                      	    29: 		data32
                      	    30: 		call nearfn32\@
                      	    31: 		jnc error
                      	    32: 		jmp rm16\@
                      	    33: nearfn32\@:
                      	    34: 		sub $4,%ax
                      	    35: 		cmp %ax,%\arg1
                      	    36: 		jne error
                      	    37: 		add $4,%ax
                      	    38: 		stc
                      	    39: 		data32
                      	    40: 		ret
                      	    41: 		jmp error
                      	    42: 
                      	    43: rm16\@:
                      	    44: 		clc
                      	    45: 		mov $nearfn16\@,%bx
                      	    46: #		data16
                      	    47: 		call %bx
                      	    48: 		jnc error
                      	    49: rm32\@:
                      	    50: 		clc
                      	    51: 		mov $nearfn32\@-TEST_CODE,%ebx
                      	    52: 		call %ebx
                      	    53: 		jnc error
                      	    54: 	.else
                      	    55: 		mov %\arg1,%eax
                      	    56: rel16\@:
                      	    57: 		clc
                      	    58: #		data16
                      	    59: 		callw nearfn16\@
                      	    60: 		jnc error
                      	    61: 		jmp rel32\@
                      	    62: nearfn16\@:
                      	    63: 		sub $2,%eax
                      	    64: 		cmp %eax,%\arg1
                      	    65: 		jne error
                      	    66: 		add $2,%eax
                      	    67: 		stc
                      	    68: #		data16
                      	    69: 		ret
                      	    70: 		jmp error
                      	    71: 
                      	    72: rel32\@:
                      	    73: 		clc
                      	    74: #		data32
                      	    75: 		calll nearfn32\@
                      	    76: 		jnc error
                      	    77: 		jmp rm16\@
                      	    78: nearfn32\@:
                      	    79: 		sub $4,%eax
                      	    80: 		cmp %eax,%\arg1
                      	    81: 		jne error
                      	    82: 		add $4,%eax
                      	    83: 		stc
                      	    84: 		data32
                      	    85: 		ret
                      	    86: 		jmp error
                      	    87: 
                      	    88: rm16\@:
                      	    89: 		clc
                      	    90: 		mov $nearfn16\@,%bx
                      	    91: #		data16
                      	    92: 		call %bx
                      	    93: 		jnc error
                      	    94: rm32\@:
                      	    95: 		clc
                      	    96: 		mov $nearfn32\@-TEST_CODE,%ebx
                      	    97: #		data32
                      	    98: 		call %ebx
                      	    99: 		jnc error
                      	   100: 	.endif
                      	   101: .endm
                      	   102: 
                      	   103: #
                      	   104: #   Tests Call far by immediate and memory pointers
                      	   105: #   Stack must be initilized
                      	   106: #   %1: code segment
                      	   107: #   Uses: AX, Flags, DS:SI as scratch memory
                      	   108: #
                      	   109: .macro testCallFar arg1
                      	   110: 	mov %sp,%ax
                      	   111: 
                      	   112: 	clc
                      	   113: #	data16
                      	   114: 	lcall $\arg1,$farfn16\@
                      	   115: 	jnc error
                      	   116: 	jmp o32\@
                      	   117: farfn16\@:
                      	   118: 	sub $4,%ax
                      	   119: 	cmp %ax,%sp
                      	   120: 	jne error
                      	   121: 	add $4,%ax
                      	   122: 	stc
                      	   123: #	data16
                      	   124: 	lret
                      	   125: 	jmp error
                      	   126: 
                      	   127: o32\@:
                      	   128: 	clc
                      	   129: 	lcalll $\arg1,$farfn32\@-TEST_CODE
                      	   130: 	jnc error
                      	   131: 	jmp m1616\@
                      	   132: farfn32\@:
                      	   133: 	sub $8,%ax
                      	   134: 	cmp %ax,%sp
                      	   135: 	jne error
                      	   136: 	add $8,%ax
                      	   137: 	stc
                      	   138: 	lretl
                      	   139: 	jmp error
                      	   140: 
                      	   141: m1616\@:
                      	   142: 	clc
                      	   143: 	movw $farfn16\@,(%si)
                      	   144: 	movw $\arg1,2(%si)
                      	   145: #	data16
                      	   146: 	lcall (%si)
                      	   147: 	jnc error
                      	   148: m1632\@:
                      	   149: 	clc
                      	   150: 	movl $farfn32\@-TEST_CODE,(%si)
                      	   151: 	movw $\arg1,4(%si)
                      	   152: #	data32
                      	   153: 	lcalll (%si)
                      	   154: 	jnc error
                      	   155: exit\@:
                      	   156: .endm
                      	   157: 

Source: "t386.asm"
                      	   253: #-------------------------------------------------------------------------------
                      	   254: 	POST $0x05
04:0000128A B005      	     1M 	movb $0x05,%al
04:0000128C BA9001    	     2M 	movw $POST_PORT,%dx
04:0000128F EE        	     3M 	out %al,%dx
                      	   255: #-------------------------------------------------------------------------------
                      	   256: #
                      	   257: #   Calls in real mode
                      	   258: #
04:00001290 BE0000    	   259: 	mov $0,%si
                      	   260: 	testCallNear sp
                      	     1M 
                      	     2M 	.ifc sp, sp
04:00001293 89E0      	     3M 		mov %sp,%ax
                      	     4M rel1651:
04:00001295 F8        	     5M 		clc
                      	     6M #		data16
04:00001296 E80600    	     7M 		callw nearfn1651
04:00001299 0F831012  	     8M 		jnc error
04:0000129D EB11      	     9M 		jmp rel3251
                      	    10M nearfn1651:
04:0000129F 83E802    	    11M 		sub $2,%ax
04:000012A2 39C4      	    12M 		cmp %ax,%sp
04:000012A4 0F850512  	    13M 		jne error
04:000012A8 83C002    	    14M 		add $2,%ax
04:000012AB F9        	    15M 		stc
                      	    16M #		data16
04:000012AC C3        	    17M 		ret
04:000012AD E9FD11    	    18M 		jmp error
                      	    19M 
                      	    20M rel3251:
04:000012B0 F8        	    21M 		clc
04:000012B1 66        	    22M 		data32
04:000012B2 E80600    	    23M 		call nearfn3251
04:000012B5 0F83F411  	    24M 		jnc error
04:000012B9 EB12      	    25M 		jmp rm1651
                      	    26M nearfn3251:
04:000012BB 83E804    	    27M 		sub $4,%ax
04:000012BE 39C4      	    28M 		cmp %ax,%sp
04:000012C0 0F85E911  	    29M 		jne error
04:000012C4 83C004    	    30M 		add $4,%ax
04:000012C7 F9        	    31M 		stc
04:000012C8 66        	    32M 		data32
04:000012C9 C3        	    33M 		ret
04:000012CA E9E011    	    34M 		jmp error
                      	    35M 
                      	    36M rm1651:
04:000012CD F8        	    37M 		clc
04:000012CE BB9F12    	    38M 		mov $nearfn1651,%bx
                      	    39M #		data16
04:000012D1 FFD3      	    40M 		call %bx
04:000012D3 0F83D611  	    41M 		jnc error
                      	    42M rm3251:
04:000012D7 F8        	    43M 		clc
04:000012D8 66BBBB1201	    44M 		mov $nearfn3251-TEST_CODE,%ebx
04:000012DD 00
04:000012DE 66FFD3    	    45M 		call %ebx
04:000012E1 0F83C811  	    46M 		jnc error
                      	    47M 	.else
                      	    48M 		mov %sp,%eax
                      	    49M rel1651:
                      	    50M 		clc
                      	    51M #		data16
                      	    52M 		callw nearfn1651
                      	    53M 		jnc error
                      	    54M 		jmp rel3251
                      	    55M nearfn1651:
                      	    56M 		sub $2,%eax
                      	    57M 		cmp %eax,%sp
                      	    58M 		jne error
                      	    59M 		add $2,%eax
                      	    60M 		stc
                      	    61M #		data16
                      	    62M 		ret
                      	    63M 		jmp error
                      	    64M 
                      	    65M rel3251:
                      	    66M 		clc
                      	    67M #		data32
                      	    68M 		calll nearfn3251
                      	    69M 		jnc error
                      	    70M 		jmp rm1651
                      	    71M nearfn3251:
                      	    72M 		sub $4,%eax
                      	    73M 		cmp %eax,%sp
                      	    74M 		jne error
                      	    75M 		add $4,%eax
                      	    76M 		stc
                      	    77M 		data32
                      	    78M 		ret
                      	    79M 		jmp error
                      	    80M 
                      	    81M rm1651:
                      	    82M 		clc
                      	    83M 		mov $nearfn1651,%bx
                      	    84M #		data16
                      	    85M 		call %bx
                      	    86M 		jnc error
                      	    87M rm3251:
                      	    88M 		clc
                      	    89M 		mov $nearfn3251-TEST_CODE,%ebx
                      	    90M #		data32
                      	    91M 		call %ebx
                      	    92M 		jnc error
                      	    93M 	.endif
                      	   261: 	testCallFar C_SEG_REAL
04:000012E5 89E0      	     1M 	mov %sp,%ax
                      	     2M 
04:000012E7 F8        	     3M 	clc
                      	     4M #	data16
04:000012E8 9A00F0F312	     5M 	lcall $C_SEG_REAL,$farfn1652
04:000012ED 0F83BC11  	     6M 	jnc error
04:000012F1 EB11      	     7M 	jmp o3252
                      	     8M farfn1652:
04:000012F3 83E804    	     9M 	sub $4,%ax
04:000012F6 39C4      	    10M 	cmp %ax,%sp
04:000012F8 0F85B111  	    11M 	jne error
04:000012FC 83C004    	    12M 	add $4,%ax
04:000012FF F9        	    13M 	stc
                      	    14M #	data16
04:00001300 CB        	    15M 	lret
04:00001301 E9A911    	    16M 	jmp error
                      	    17M 
                      	    18M o3252:
04:00001304 F8        	    19M 	clc
04:00001305 669A00F013	    20M 	lcalll $C_SEG_REAL,$farfn3252-TEST_CODE
04:0000130A 130100
04:0000130D 0F839C11  	    21M 	jnc error
04:00001311 EB12      	    22M 	jmp m161652
                      	    23M farfn3252:
04:00001313 83E808    	    24M 	sub $8,%ax
04:00001316 39C4      	    25M 	cmp %ax,%sp
04:00001318 0F859111  	    26M 	jne error
04:0000131C 83C008    	    27M 	add $8,%ax
04:0000131F F9        	    28M 	stc
04:00001320 66CB      	    29M 	lretl
04:00001322 E98811    	    30M 	jmp error
                      	    31M 
                      	    32M m161652:
04:00001325 F8        	    33M 	clc
04:00001326 C704F312  	    34M 	movw $farfn1652,(%si)
04:0000132A C7440200F0	    35M 	movw $C_SEG_REAL,2(%si)
                      	    36M #	data16
04:0000132F FF1C      	    37M 	lcall (%si)
04:00001331 0F837811  	    38M 	jnc error
                      	    39M m163252:
04:00001335 F8        	    40M 	clc
04:00001336 66C7041313	    41M 	movl $farfn3252-TEST_CODE,(%si)
04:0000133B 0100
04:0000133D C7440400F0	    42M 	movw $C_SEG_REAL,4(%si)
                      	    43M #	data32
04:00001342 66FF1C    	    44M 	lcalll (%si)
04:00001345 0F836411  	    45M 	jnc error
                      	    46M exit52:
                      	   262: 
                      	   263: 	advTestSegReal
                      	     1M 	advTestBase
                      	     1M 	.set TEST_BASE1,TEST_BASE1+0x1000
                      	     2M 	.set TEST_BASE2,TEST_BASE2+0x1000
                      	     2M 	.set D1_SEG_REAL,TEST_BASE1 >> 4
                      	     3M 	.set D2_SEG_REAL,TEST_BASE2 >> 4
04:00001349 C7C200C3  	     4M 	mov $D1_SEG_REAL,%dx
04:0000134D 8EDA      	     5M 	mov %dx,%ds
04:0000134F C7C200C5  	     6M 	mov $D2_SEG_REAL,%dx
04:00001353 8EC2      	     7M 	mov %dx,%es
                      	   264: 
                      	   265: 
                      	   266: .include "load_ptr_m.asm"

Source: "load_ptr_m.asm"
                      	     1: #
                      	     2: #   Tests LSS,LDS,LES,LFS,LGS in 16 and 32 bit mode
                      	     3: #   %1 segment register name, one of ss,ds,es,fs,gs
                      	     4: #   [ed:di] memory address to use for the pointer
                      	     5: #   Uses: nothing
                      	     6: #
                      	     7: 
                      	     8: .macro testLoadPtr arg1
                      	     9: 	mov %\arg1,%cx
                      	    10: 	mov %es,%dx
                      	    11: 
                      	    12: 	movw $0x1234,%es:(%di)
                      	    13: 	movw $0xabcd,%es:2(%di)
                      	    14: 	l\arg1 %es:(%di),%bx
                      	    15: 	mov %\arg1,%ax
                      	    16: 	cmp $0xabcd,%ax
                      	    17: 	jne error
                      	    18: 	cmp $0x1234,%bx
                      	    19: 	jne error
                      	    20: 
                      	    21: 	mov %dx,%es
                      	    22: 
                      	    23: 	movl $0x12345678,%es:(%di)
                      	    24: 	movw $0xbcde,%es:4(%di)
                      	    25: 	l\arg1 %es:(%di),%ebx
                      	    26: 	mov %\arg1,%ax
                      	    27: 	cmp $0xbcde,%ax
                      	    28: 	jne error
                      	    29: 	cmp $0x12345678,%ebx
                      	    30: 	jne error
                      	    31: 
                      	    32: 	mov %dx,%es
                      	    33: 	mov %cx,%\arg1
                      	    34: .endm
                      	    35: 

Source: "t386.asm"
                      	   267: #-------------------------------------------------------------------------------
                      	   268: 	POST $0x06
04:00001355 B006      	     1M 	movb $0x06,%al
04:00001357 BA9001    	     2M 	movw $POST_PORT,%dx
04:0000135A EE        	     3M 	out %al,%dx
                      	   269: #-------------------------------------------------------------------------------
                      	   270: #
                      	   271: #   Load full pointer in real mode
                      	   272: #
04:0000135B BF0000    	   273: 	mov $0,%di
                      	   274: 	testLoadPtr ss
04:0000135E 8CD1      	     1M 	mov %ss,%cx
04:00001360 8CC2      	     2M 	mov %es,%dx
                      	     3M 
04:00001362 26C7053412	     4M 	movw $0x1234,%es:(%di)
04:00001367 26C74502CD	     5M 	movw $0xabcd,%es:2(%di)
04:0000136C AB
04:0000136D 260FB21D  	     6M 	lss %es:(%di),%bx
04:00001371 8CD0      	     7M 	mov %ss,%ax
04:00001373 3DCDAB    	     8M 	cmp $0xabcd,%ax
04:00001376 0F853311  	     9M 	jne error
04:0000137A 81FB3412  	    10M 	cmp $0x1234,%bx
04:0000137E 0F852B11  	    11M 	jne error
                      	    12M 
04:00001382 8EC2      	    13M 	mov %dx,%es
                      	    14M 
04:00001384 6626C70578	    15M 	movl $0x12345678,%es:(%di)
04:00001389 563412
04:0000138C 26C74504DE	    16M 	movw $0xbcde,%es:4(%di)
04:00001391 BC
04:00001392 66260FB21D	    17M 	lss %es:(%di),%ebx
04:00001397 8CD0      	    18M 	mov %ss,%ax
04:00001399 3DDEBC    	    19M 	cmp $0xbcde,%ax
04:0000139C 0F850D11  	    20M 	jne error
04:000013A0 6681FB7856	    21M 	cmp $0x12345678,%ebx
04:000013A5 3412
04:000013A7 0F850211  	    22M 	jne error
                      	    23M 
04:000013AB 8EC2      	    24M 	mov %dx,%es
04:000013AD 8ED1      	    25M 	mov %cx,%ss
                      	   275: 	testLoadPtr ds
04:000013AF 8CD9      	     1M 	mov %ds,%cx
04:000013B1 8CC2      	     2M 	mov %es,%dx
                      	     3M 
04:000013B3 26C7053412	     4M 	movw $0x1234,%es:(%di)
04:000013B8 26C74502CD	     5M 	movw $0xabcd,%es:2(%di)
04:000013BD AB
04:000013BE 26C51D    	     6M 	lds %es:(%di),%bx
04:000013C1 8CD8      	     7M 	mov %ds,%ax
04:000013C3 3DCDAB    	     8M 	cmp $0xabcd,%ax
04:000013C6 0F85E310  	     9M 	jne error
04:000013CA 81FB3412  	    10M 	cmp $0x1234,%bx
04:000013CE 0F85DB10  	    11M 	jne error
                      	    12M 
04:000013D2 8EC2      	    13M 	mov %dx,%es
                      	    14M 
04:000013D4 6626C70578	    15M 	movl $0x12345678,%es:(%di)
04:000013D9 563412
04:000013DC 26C74504DE	    16M 	movw $0xbcde,%es:4(%di)
04:000013E1 BC
04:000013E2 6626C51D  	    17M 	lds %es:(%di),%ebx
04:000013E6 8CD8      	    18M 	mov %ds,%ax
04:000013E8 3DDEBC    	    19M 	cmp $0xbcde,%ax
04:000013EB 0F85BE10  	    20M 	jne error
04:000013EF 6681FB7856	    21M 	cmp $0x12345678,%ebx
04:000013F4 3412
04:000013F6 0F85B310  	    22M 	jne error
                      	    23M 
04:000013FA 8EC2      	    24M 	mov %dx,%es
04:000013FC 8ED9      	    25M 	mov %cx,%ds
                      	   276: 	testLoadPtr es
04:000013FE 8CC1      	     1M 	mov %es,%cx
04:00001400 8CC2      	     2M 	mov %es,%dx
                      	     3M 
04:00001402 26C7053412	     4M 	movw $0x1234,%es:(%di)
04:00001407 26C74502CD	     5M 	movw $0xabcd,%es:2(%di)
04:0000140C AB
04:0000140D 26C41D    	     6M 	les %es:(%di),%bx
04:00001410 8CC0      	     7M 	mov %es,%ax
04:00001412 3DCDAB    	     8M 	cmp $0xabcd,%ax
04:00001415 0F859410  	     9M 	jne error
04:00001419 81FB3412  	    10M 	cmp $0x1234,%bx
04:0000141D 0F858C10  	    11M 	jne error
                      	    12M 
04:00001421 8EC2      	    13M 	mov %dx,%es
                      	    14M 
04:00001423 6626C70578	    15M 	movl $0x12345678,%es:(%di)
04:00001428 563412
04:0000142B 26C74504DE	    16M 	movw $0xbcde,%es:4(%di)
04:00001430 BC
04:00001431 6626C41D  	    17M 	les %es:(%di),%ebx
04:00001435 8CC0      	    18M 	mov %es,%ax
04:00001437 3DDEBC    	    19M 	cmp $0xbcde,%ax
04:0000143A 0F856F10  	    20M 	jne error
04:0000143E 6681FB7856	    21M 	cmp $0x12345678,%ebx
04:00001443 3412
04:00001445 0F856410  	    22M 	jne error
                      	    23M 
04:00001449 8EC2      	    24M 	mov %dx,%es
04:0000144B 8EC1      	    25M 	mov %cx,%es
                      	   277: 	testLoadPtr fs
04:0000144D 8CE1      	     1M 	mov %fs,%cx
04:0000144F 8CC2      	     2M 	mov %es,%dx
                      	     3M 
04:00001451 26C7053412	     4M 	movw $0x1234,%es:(%di)
04:00001456 26C74502CD	     5M 	movw $0xabcd,%es:2(%di)
04:0000145B AB
04:0000145C 260FB41D  	     6M 	lfs %es:(%di),%bx
04:00001460 8CE0      	     7M 	mov %fs,%ax
04:00001462 3DCDAB    	     8M 	cmp $0xabcd,%ax
04:00001465 0F854410  	     9M 	jne error
04:00001469 81FB3412  	    10M 	cmp $0x1234,%bx
04:0000146D 0F853C10  	    11M 	jne error
                      	    12M 
04:00001471 8EC2      	    13M 	mov %dx,%es
                      	    14M 
04:00001473 6626C70578	    15M 	movl $0x12345678,%es:(%di)
04:00001478 563412
04:0000147B 26C74504DE	    16M 	movw $0xbcde,%es:4(%di)
04:00001480 BC
04:00001481 66260FB41D	    17M 	lfs %es:(%di),%ebx
04:00001486 8CE0      	    18M 	mov %fs,%ax
04:00001488 3DDEBC    	    19M 	cmp $0xbcde,%ax
04:0000148B 0F851E10  	    20M 	jne error
04:0000148F 6681FB7856	    21M 	cmp $0x12345678,%ebx
04:00001494 3412
04:00001496 0F851310  	    22M 	jne error
                      	    23M 
04:0000149A 8EC2      	    24M 	mov %dx,%es
04:0000149C 8EE1      	    25M 	mov %cx,%fs
                      	   278: 	testLoadPtr gs
04:0000149E 8CE9      	     1M 	mov %gs,%cx
04:000014A0 8CC2      	     2M 	mov %es,%dx
                      	     3M 
04:000014A2 26C7053412	     4M 	movw $0x1234,%es:(%di)
04:000014A7 26C74502CD	     5M 	movw $0xabcd,%es:2(%di)
04:000014AC AB
04:000014AD 260FB51D  	     6M 	lgs %es:(%di),%bx
04:000014B1 8CE8      	     7M 	mov %gs,%ax
04:000014B3 3DCDAB    	     8M 	cmp $0xabcd,%ax
04:000014B6 0F85F30F  	     9M 	jne error
04:000014BA 81FB3412  	    10M 	cmp $0x1234,%bx
04:000014BE 0F85EB0F  	    11M 	jne error
                      	    12M 
04:000014C2 8EC2      	    13M 	mov %dx,%es
                      	    14M 
04:000014C4 6626C70578	    15M 	movl $0x12345678,%es:(%di)
04:000014C9 563412
04:000014CC 26C74504DE	    16M 	movw $0xbcde,%es:4(%di)
04:000014D1 BC
04:000014D2 66260FB51D	    17M 	lgs %es:(%di),%ebx
04:000014D7 8CE8      	    18M 	mov %gs,%ax
04:000014D9 3DDEBC    	    19M 	cmp $0xbcde,%ax
04:000014DC 0F85CD0F  	    20M 	jne error
04:000014E0 6681FB7856	    21M 	cmp $0x12345678,%ebx
04:000014E5 3412
04:000014E7 0F85C20F  	    22M 	jne error
                      	    23M 
04:000014EB 8EC2      	    24M 	mov %dx,%es
04:000014ED 8EE9      	    25M 	mov %cx,%gs
                      	   279: 
                      	   280: 	advTestSegReal
                      	     1M 	advTestBase
                      	     1M 	.set TEST_BASE1,TEST_BASE1+0x1000
                      	     2M 	.set TEST_BASE2,TEST_BASE2+0x1000
                      	     2M 	.set D1_SEG_REAL,TEST_BASE1 >> 4
                      	     3M 	.set D2_SEG_REAL,TEST_BASE2 >> 4
04:000014EF C7C200C4  	     4M 	mov $D1_SEG_REAL,%dx
04:000014F3 8EDA      	     5M 	mov %dx,%ds
04:000014F5 C7C200C6  	     6M 	mov $D2_SEG_REAL,%dx
04:000014F9 8EC2      	     7M 	mov %dx,%es
                      	   281: 
                      	   282: # ==============================================================================
                      	   283: #	Protected mode tests
                      	   284: # ==============================================================================
                      	   285: 
                      	   286: #-------------------------------------------------------------------------------
                      	   287: 	POST $0x08
04:000014FB B008      	     1M 	movb $0x08,%al
04:000014FD BA9001    	     2M 	movw $POST_PORT,%dx
04:00001500 EE        	     3M 	out %al,%dx
                      	   288: #-------------------------------------------------------------------------------
                      	   289: #
                      	   290: #   GDT, LDT, PDT, and PT setup, enter protected mode
                      	   291: #
04:00001501 EB12      	   292: 	jmp initGDT
                      	   293: 
                      	   294: .set ESP_R0_PROT,0x0000FFFF
                      	   295: .set ESP_R3_PROT,0x00007FFF
                      	   296: 
                      	   297: .include "protected_m.asm"

Source: "protected_m.asm"
                      	     1: #
                      	     2: # Advances the base address of data segments used by tests, D1_SEG_PROT and
                      	     3: # D2_SEG_PROT.
                      	     4: #
                      	     5: # Loads DS with D1_SEG_PROT and ES with D2_SEG_PROT.
                      	     6: #
                      	     7: .macro advTestSegProt
                      	     8: 	advTestBase
                      	     9: 	updLDTDescBase D1_SEG_PROT,TEST_BASE1
                      	    10: 	updLDTDescBase D2_SEG_PROT,TEST_BASE2
                      	    11: 	mov $D1_SEG_PROT,%dx
                      	    12: 	mov %dx,%ds
                      	    13: 	mov $D2_SEG_PROT,%dx
                      	    14: 	mov %dx,%es
                      	    15: .endm
                      	    16: 
                      	    17: 
                      	    18: #
                      	    19: #   Defines an interrupt gate in ROM, given a selector (%1) and an offset (%2)
                      	    20: #
                      	    21: .macro defIntGate arg1,arg2
                      	    22: 	.2byte (\arg2 & 0xffff) # OFFSET 15-0
                      	    23: 	.2byte \arg1 	# SELECTOR
                      	    24: 	.2byte ACC_TYPE_GATE386_INT | ACC_PRESENT # acc byte
                      	    25: 	.2byte (\arg2 >> 16) & 0xffff # OFFSET 31-16
                      	    26: .endm
                      	    27: 
                      	    28: .set GDTSelDesc,0
                      	    29: #
                      	    30: #   Defines a GDT descriptor in ROM, given a name (%1), base (%2), limit (%3),
                      	    31: #   acc byte (%4), and ext nibble (%5)
                      	    32: #
                      	    33: .macro defGDTDescROM arg1,arg2,arg3,arg4,arg5
                      	    34: 	.ifnc \arg1, 0
                      	    35: 	.set \arg1,GDTSelDesc
                      	    36: 	.endif
                      	    37: 	.2byte (\arg3 & 0x0000ffff) # LIMIT 15-0
                      	    38: 	.2byte (\arg2 & 0x0000ffff) # BASE 15-0
                      	    39: 	.2byte ((\arg2 & 0x00ff0000) >> 16) | \arg4 # BASE 23-16 | acc byte
                      	    40: 	.2byte ((\arg3 & 0x000f0000) >> 16) | \arg5 | ((\arg2 & 0xff000000) >> 16) # LIMIT 19-16 | ext nibble | BASE 31-24
                      	    41: 	.ifnc \arg1, 0
                      	    42: 	.set GDTSelDesc,GDTSelDesc+8
                      	    43: 	.endif
                      	    44: .endm
                      	    45: #
                      	    46: #   Defines a GDT descriptor in RAM, given a name (%1), base (%2), limit (%3),
                      	    47: #   acc byte (%4), and ext nibble (%5)
                      	    48: #
                      	    49: .macro defGDTDesc arg1,arg2=0,arg3=0,arg4=0,arg5=0
                      	    50: 	.ifnc \arg1, 0
                      	    51: 	.set \arg1,GDTSelDesc
                      	    52: 	.endif
                      	    53: 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
                      	    54: 	mov $\arg1,%eax
                      	    55: 	mov $\arg2,%esi
                      	    56: 	mov $\arg3,%edi
                      	    57: 	mov $\arg4|\arg5,%dx
                      	    58: 	initDescriptor
                      	    59: 	.ifnc \arg1, 0
                      	    60: 	.set GDTSelDesc,GDTSelDesc+8
                      	    61: 	.endif
                      	    62: .endm
                      	    63: 
                      	    64: #
                      	    65: #   Defines a LDT descriptor, given a name (%1), base (%2), limit (%3), type (%4), and ext (%5)
                      	    66: #
                      	    67: .set LDTSelDesc,4
                      	    68: .macro defLDTDesc arg1,arg2,arg3,arg4,arg5=0
                      	    69: 	.set \arg1,LDTSelDesc
                      	    70: 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
                      	    71: 	mov $\arg1,%eax
                      	    72: 	mov $\arg2,%esi
                      	    73: 	mov $\arg3,%edi
                      	    74: 	mov $\arg4|\arg5,%dx
                      	    75: 	initDescriptor
                      	    76: 	.set LDTSelDesc,LDTSelDesc+8
                      	    77: .endm
                      	    78: 
                      	    79: #
                      	    80: #   Updates a LDT descriptor, given a name (%1), base (%2), limit (%3), type (%4), and ext (%5)
                      	    81: #
                      	    82: .macro updLDTDesc arg1,arg2,arg3,arg4,arg5
                      	    83: 	pushad
                      	    84: 	mov %ds,%ax
                      	    85: 	push %ax
                      	    86: 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
                      	    87: 	mov $\arg1,%eax
                      	    88: 	mov $\arg2,%esi
                      	    89: 	mov $\arg3,%edi
                      	    90: 	mov $\arg4|\arg5,%dx
                      	    91: 	call initDescriptorProt
                      	    92: 	pop %ax
                      	    93: 	mov %ax,%ds
                      	    94: 	popad
                      	    95: .endm
                      	    96: 
                      	    97: #
                      	    98: # Updates the access byte of a descriptor in the LDT
                      	    99: # %1 LDT selector
                      	   100: # %2 access byte new value (ACC_* or'd equs)
                      	   101: # Uses DS
                      	   102: 
                      	   103: .macro updLDTDescAcc arg1,arg2
                      	   104: 	pushad
                      	   105: 	pushf
                      	   106: 	lds %cs:ptrLDTprot,%ebx
                      	   107: 	add $(\arg1) & 0xFFF8,%ebx
                      	   108: 	movb $(\arg2)>>8,5(%ebx) # acc byte
                      	   109: 	popf
                      	   110: 	popad
                      	   111: .endm
                      	   112: 
                      	   113: #
                      	   114: # Updates the base of a descriptor in the LDT
                      	   115: # %1 LDT selector
                      	   116: # %2 new base
                      	   117: # Uses DS,EBX,flags
                      	   118: 
                      	   119: .macro updLDTDescBase arg1,arg2
                      	   120: 	lds %cs:ptrLDTprot,%ebx
                      	   121: 	add $(\arg1) & 0xFFF8,%ebx
                      	   122: 	movw $(\arg2)&0xFFFF,2(%ebx)      # BASE 15-0
                      	   123: 	movb $((\arg2)>>16)&0xFF,4(%ebx) 	# BASE 23-16
                      	   124: 	movb $((\arg2)>>24)&0xFF,7(%ebx) 	# BASE 31-24
                      	   125: .endm
                      	   126: 
                      	   127: #
                      	   128: # Updates the values of a GDT's entry with a Call Gate
                      	   129: # %1 GDT selector
                      	   130: # %2 destination selector
                      	   131: # %3 destination offset
                      	   132: # %4 word count
                      	   133: # %5 DPL
                      	   134: #
                      	   135: .macro updCallGate arg1,arg2,arg3,arg4,arg5
                      	   136: 	lfs %cs:ptrGDTprot,%ebx
                      	   137: 	mov $\arg1,%eax
                      	   138: 	mov $\arg2,%esi
                      	   139: 	mov $\arg3,%edi
                      	   140: 	mov $\arg4|\arg5,%dx
                      	   141: 	call initCallGate
                      	   142: .endm
                      	   143: 
                      	   144: 
                      	   145: 
                      	   146: 
                      	   147: #
                      	   148: # Loads SS:ESP with a pointer to the prot mode stack
                      	   149: #
                      	   150: .macro loadProtModeStack
                      	   151: 	lss %cs:ptrSSprot,%esp
                      	   152: .endm
                      	   153: 
                      	   154: 
                      	   155: #
                      	   156: # Set a int gate on the IDT in protected mode
                      	   157: #
                      	   158: # %1: vector
                      	   159: # %2: offset
                      	   160: # %3: DPL, use ACC_DPL_* equs (optional)
                      	   161: #
                      	   162: # the stack must be initialized
                      	   163: #
                      	   164: .macro setProtModeIntGate arg1,arg2,arg3
                      	   165: 	pushad
                      	   166: 	pushf
                      	   167: 	mov %ds,%ax  	# save ds
                      	   168: 	push %ax
                      	   169: 	mov $\arg1,%eax
                      	   170: 	mov $\arg2,%edi
                      	   171: 	.if \arg3 != -1
                      	   172: 	mov $\arg3,%dx
                      	   173: 	.else
                      	   174: 	mov %cs,%dx
                      	   175: 	and $7,%dx
                      	   176: 	shl $13,%dx
                      	   177: 	.endif
                      	   178: 	cmp $ACC_DPL_0,%dx
                      	   179: 	jne dpl3\@
                      	   180: dpl0\@:
                      	   181: 	mov $C_SEG_PROT32,%esi
                      	   182: 	jmp cont\@
                      	   183: dpl3\@:
                      	   184: 	mov $CU_SEG_PROT32,%esi
                      	   185: cont\@:
                      	   186: 	mov %cs,%cx
                      	   187: 	test $7,%cx
                      	   188: 	jnz ring3\@
                      	   189: ring0\@:
                      	   190: 	lds (%cs:ptrIDTprot),%ebx
                      	   191: 	jmp call\@
                      	   192: ring3\@:
                      	   193: 	lds (%cs:ptrIDTUprot),%ebx
                      	   194: call\@:
                      	   195: 	call initIntGateProt
                      	   196: 	pop %ax
                      	   197: 	mov %ax,%ds  # restore ds
                      	   198: 	popf
                      	   199: 	popad
                      	   200: .endm
                      	   201: 
                      	   202: #
                      	   203: # Tests a fault
                      	   204: #
                      	   205: # %1: vector
                      	   206: # %2: expected error code
                      	   207: # %3: fault causing instruction (can't be a call unless the call is the faulting instruction)
                      	   208: #
                      	   209: # the stack must be initialized
                      	   210: #
                      	   211: .macro protModeFaultTest arg1,arg2,arg3
                      	   212: 	setProtModeIntGate \arg1, continue\@
                      	   213: test\@:
                      	   214: 	\arg3
                      	   215: 	jmp error
                      	   216: continue\@:
                      	   217: 	protModeExcCheck \arg1, \arg2, test\@
                      	   218: 	setProtModeIntGate \arg1, DefaultExcHandler, ACC_DPL_0
                      	   219: .endm
                      	   220: 
                      	   221: # %1: vector
                      	   222: # %2: expected error code
                      	   223: # %3: the provilege level the test code will run in
                      	   224: # %4: the expected value of pushed EIP (specify if %5 is a call, otherwise use -1)
                      	   225: # %5: fault causing code (can be a call to procedure)
                      	   226: #
                      	   227: # The fault handler is executed in ring 0. The caller must reset the data segments.
                      	   228: #
                      	   229: .macro protModeFaultTestEx arg1,arg2,arg3,arg4,arg5
                      	   230: 	setProtModeIntGate \arg1, continue\@, ACC_DPL_0
                      	   231: test\@:
                      	   232: 	\arg5
                      	   233: 	jmp error
                      	   234: continue\@:
                      	   235: 	.if \arg3 = 0
                      	   236: 		.set expectedCS,C_SEG_PROT32
                      	   237: 	.else
                      	   238: 		.set expectedCS,CU_SEG_PROT32|3
                      	   239: 	.endif
                      	   240: 	.if \arg4 = -1
                      	   241: 		protModeExcCheck \arg1, \arg2, test\@, expectedCS
                      	   242: 	.else
                      	   243: 		protModeExcCheck \arg1, \arg2, \arg4, expectedCS
                      	   244: 	.endif
                      	   245: 	setProtModeIntGate \arg1, DefaultExcHandler, ACC_DPL_0
                      	   246: .endm
                      	   247: 
                      	   248: #
                      	   249: # Checks exception result and restores the previous handler
                      	   250: #
                      	   251: # %1: vector
                      	   252: # %2: expected error code
                      	   253: # %3: expected pushed value of EIP
                      	   254: # %4: expected pushed value of CS (optional)
                      	   255: #
                      	   256: .macro protModeExcCheck arg1,arg2,arg3,arg4
                      	   257: 	.if \arg1 == 8 || (\arg1 > 10 && \arg1 <= 14)
                      	   258: 	.set exc_errcode,4
                      	   259: 	cmpl $\arg2,(%ss:%esp)
                      	   260: 	jne error
                      	   261: 	.else
                      	   262: 	.set exc_errcode,0
                      	   263: 	.endif
                      	   264: 	.if \arg4 != -1
                      	   265: 		cmpl $\arg4,exc_errcode+4(%ss:esp)
                      	   266: 		jne error
                      	   267: 	.else
                      	   268: 		mov %cs,%bx
                      	   269: 		test $7,%bx
                      	   270: 		jnz ring3\@
                      	   271: 		ring0\@:
                      	   272: 		cmpl $C_SEG_PROT32,exc_errcode+4(%ss:%esp) 
                      	   273: 		jne error
                      	   274: 		jmp continue\@
                      	   275: 		ring3\@:
                      	   276: 		cmpl $CU_SEG_PROT32|3,exc_errcode+4(%ss:%esp)
                      	   277: 		jne error
                      	   278: 		continue\@:
                      	   279: 	.endif
                      	   280: 	cmpl $\arg3,exc_errcode(%ss:%esp)
                      	   281: 	jne error
                      	   282: 	add $12+exc_errcode,%esp
                      	   283: .endm
                      	   284: 

Source: "t386.asm"
                      	   298: 
                      	   299: 
                      	   300: #;; support for ROM based GDT (currently unused)
                      	   301: romGDT:
                      	   302: romGDTEnd:
                      	   303: romGDTaddr:
04:00001503 FFFF      	   304: 	.2byte romGDTEnd - romGDT - 1 	# 16-bit limit
04:00001505 03150000  	   305: 	.4byte romGDT  									# 32-bit base address
                      	   306: #;;
                      	   307: 
                      	   308: ptrGDTreal: # pointer to the pmode GDT for real mode code
04:00001509 00000000  	   309: 	.4byte 0         			# 32-bit offset
04:0000150D 5090      	   310: 	.2byte GDT_SEG_REAL  	# 16-bit segment selector
                      	   311: ptrIDTreal: # pointer to the pmode IDT for real mode code
04:0000150F 00000000  	   312: 	.4byte 0
04:00001513 0090      	   313: 	.2byte IDT_SEG_REAL
                      	   314: 
                      	   315: initGDT:
                      	   316: 	# the first descriptor in the GDT is always a dud (the null selector)
                      	   317: 	defGDTDesc 0,0,0,0,0
                      	     1M 	.ifnc 0, 0
                      	     2M 	.set 0,GDTSelDesc
                      	     3M 	.endif
04:00001515 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:0000151A 15
04:0000151B 66B8000000	     5M 	mov $0,%eax
04:00001520 00
04:00001521 66BE000000	     6M 	mov $0,%esi
04:00001526 00
04:00001527 66BF000000	     7M 	mov $0,%edi
04:0000152C 00
04:0000152D BA0000    	     8M 	mov $0|0,%dx
                      	     9M 	initDescriptor
04:00001530 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001535 00
04:00001536 6601C3    	     2M 	add %eax,%ebx
04:00001539 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:0000153C 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001540 66C1EE10  	     5M 	shr $16,%esi
04:00001544 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001546 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:0000154A 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:0000154E 66C1EF10  	     9M 	shr $16,%edi
04:00001552 89F9      	    10M 	mov %di,%cx
04:00001554 80E10F    	    11M 	and $0x0f,%cl
04:00001557 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:0000155B 80E2F0    	    13M 	and $0xf0,%dl
04:0000155E 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001562 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc 0, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   318: 	defGDTDesc C_SEG_PROT16,  0xffff0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_PRESENT
                      	     1M 	.ifnc C_SEG_PROT16, 0
                      	     2M 	.set C_SEG_PROT16,GDTSelDesc
                      	     3M 	.endif
04:00001566 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:0000156B 15
04:0000156C 66B8000000	     5M 	mov $C_SEG_PROT16,%eax
04:00001571 00
04:00001572 66BE0000FF	     6M 	mov $0xffff0000,%esi
04:00001577 FF
04:00001578 66BFFFFF00	     7M 	mov $0x0000ffff,%edi
04:0000157D 00
04:0000157E BA009A    	     8M 	mov $ACC_TYPE_CODE_R|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:00001581 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001586 00
04:00001587 6601C3    	     2M 	add %eax,%ebx
04:0000158A 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:0000158D 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001591 66C1EE10  	     5M 	shr $16,%esi
04:00001595 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001597 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:0000159B 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:0000159F 66C1EF10  	     9M 	shr $16,%edi
04:000015A3 89F9      	    10M 	mov %di,%cx
04:000015A5 80E10F    	    11M 	and $0x0f,%cl
04:000015A8 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000015AC 80E2F0    	    13M 	and $0xf0,%dl
04:000015AF 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000015B3 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc C_SEG_PROT16, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   319: 	defGDTDesc C_SEG_PROT32,  0xffff0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_PRESENT,EXT_32BIT
                      	     1M 	.ifnc C_SEG_PROT32, 0
                      	     2M 	.set C_SEG_PROT32,GDTSelDesc
                      	     3M 	.endif
04:000015B7 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000015BC 15
04:000015BD 66B8080000	     5M 	mov $C_SEG_PROT32,%eax
04:000015C2 00
04:000015C3 66BE0000FF	     6M 	mov $0xffff0000,%esi
04:000015C8 FF
04:000015C9 66BFFFFF00	     7M 	mov $0x0000ffff,%edi
04:000015CE 00
04:000015CF BA409A    	     8M 	mov $ACC_TYPE_CODE_R|ACC_PRESENT|EXT_32BIT,%dx
                      	     9M 	initDescriptor
04:000015D2 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000015D7 00
04:000015D8 6601C3    	     2M 	add %eax,%ebx
04:000015DB 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000015DE 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000015E2 66C1EE10  	     5M 	shr $16,%esi
04:000015E6 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:000015E8 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:000015EC 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000015F0 66C1EF10  	     9M 	shr $16,%edi
04:000015F4 89F9      	    10M 	mov %di,%cx
04:000015F6 80E10F    	    11M 	and $0x0f,%cl
04:000015F9 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000015FD 80E2F0    	    13M 	and $0xf0,%dl
04:00001600 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001604 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc C_SEG_PROT32, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   320: 	defGDTDesc CU_SEG_PROT32, 0xffff0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_PRESENT|ACC_DPL_3,EXT_32BIT
                      	     1M 	.ifnc CU_SEG_PROT32, 0
                      	     2M 	.set CU_SEG_PROT32,GDTSelDesc
                      	     3M 	.endif
04:00001608 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:0000160D 15
04:0000160E 66B8100000	     5M 	mov $CU_SEG_PROT32,%eax
04:00001613 00
04:00001614 66BE0000FF	     6M 	mov $0xffff0000,%esi
04:00001619 FF
04:0000161A 66BFFFFF00	     7M 	mov $0x0000ffff,%edi
04:0000161F 00
04:00001620 BA40FA    	     8M 	mov $ACC_TYPE_CODE_R|ACC_PRESENT|ACC_DPL_3|EXT_32BIT,%dx
                      	     9M 	initDescriptor
04:00001623 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001628 00
04:00001629 6601C3    	     2M 	add %eax,%ebx
04:0000162C 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:0000162F 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001633 66C1EE10  	     5M 	shr $16,%esi
04:00001637 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001639 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:0000163D 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001641 66C1EF10  	     9M 	shr $16,%edi
04:00001645 89F9      	    10M 	mov %di,%cx
04:00001647 80E10F    	    11M 	and $0x0f,%cl
04:0000164A 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:0000164E 80E2F0    	    13M 	and $0xf0,%dl
04:00001651 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001655 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc CU_SEG_PROT32, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   321: 	defGDTDesc CC_SEG_PROT32, 0xffff0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_TYPE_CONFORMING|ACC_PRESENT|EXT_32BIT
                      	     1M 	.ifnc CC_SEG_PROT32, 0
                      	     2M 	.set CC_SEG_PROT32,GDTSelDesc
                      	     3M 	.endif
04:00001659 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:0000165E 15
04:0000165F 66B8180000	     5M 	mov $CC_SEG_PROT32,%eax
04:00001664 00
04:00001665 66BE0000FF	     6M 	mov $0xffff0000,%esi
04:0000166A FF
04:0000166B 66BFFFFF00	     7M 	mov $0x0000ffff,%edi
04:00001670 00
04:00001671 BA409E    	     8M 	mov $ACC_TYPE_CODE_R|ACC_TYPE_CONFORMING|ACC_PRESENT|EXT_32BIT|0,%dx
                      	     9M 	initDescriptor
04:00001674 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001679 00
04:0000167A 6601C3    	     2M 	add %eax,%ebx
04:0000167D 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001680 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001684 66C1EE10  	     5M 	shr $16,%esi
04:00001688 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:0000168A 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:0000168E 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001692 66C1EF10  	     9M 	shr $16,%edi
04:00001696 89F9      	    10M 	mov %di,%cx
04:00001698 80E10F    	    11M 	and $0x0f,%cl
04:0000169B 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:0000169F 80E2F0    	    13M 	and $0xf0,%dl
04:000016A2 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000016A6 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc CC_SEG_PROT32, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   322: 	defGDTDesc IDT_SEG_PROT,  0xFFF90400,0x000000ff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc IDT_SEG_PROT, 0
                      	     2M 	.set IDT_SEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:000016AA 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000016AF 15
04:000016B0 66B8200000	     5M 	mov $IDT_SEG_PROT,%eax
04:000016B5 00
04:000016B6 66BE0004F9	     6M 	mov $0xFFF90400,%esi
04:000016BB FF
04:000016BC 66BFFF0000	     7M 	mov $0x000000ff,%edi
04:000016C1 00
04:000016C2 BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:000016C5 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000016CA 00
04:000016CB 6601C3    	     2M 	add %eax,%ebx
04:000016CE 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000016D1 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000016D5 66C1EE10  	     5M 	shr $16,%esi
04:000016D9 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:000016DB 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:000016DF 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000016E3 66C1EF10  	     9M 	shr $16,%edi
04:000016E7 89F9      	    10M 	mov %di,%cx
04:000016E9 80E10F    	    11M 	and $0x0f,%cl
04:000016EC 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000016F0 80E2F0    	    13M 	and $0xf0,%dl
04:000016F3 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000016F7 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc IDT_SEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   323: 	defGDTDesc IDTU_SEG_PROT, 0xFFF90400,0x000000ff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3
                      	     1M 	.ifnc IDTU_SEG_PROT, 0
                      	     2M 	.set IDTU_SEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:000016FB 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001700 15
04:00001701 66B8280000	     5M 	mov $IDTU_SEG_PROT,%eax
04:00001706 00
04:00001707 66BE0004F9	     6M 	mov $0xFFF90400,%esi
04:0000170C FF
04:0000170D 66BFFF0000	     7M 	mov $0x000000ff,%edi
04:00001712 00
04:00001713 BA00F2    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3|0,%dx
                      	     9M 	initDescriptor
04:00001716 6625F8FF00	     1M 	and $0xFFF8,%eax
04:0000171B 00
04:0000171C 6601C3    	     2M 	add %eax,%ebx
04:0000171F 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001722 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001726 66C1EE10  	     5M 	shr $16,%esi
04:0000172A 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:0000172C 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001730 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001734 66C1EF10  	     9M 	shr $16,%edi
04:00001738 89F9      	    10M 	mov %di,%cx
04:0000173A 80E10F    	    11M 	and $0x0f,%cl
04:0000173D 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001741 80E2F0    	    13M 	and $0xf0,%dl
04:00001744 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001748 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc IDTU_SEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   324: 	defGDTDesc GDT_DSEG_PROT, 0xFFF90500,0x000002ff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc GDT_DSEG_PROT, 0
                      	     2M 	.set GDT_DSEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:0000174C 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001751 15
04:00001752 66B8300000	     5M 	mov $GDT_DSEG_PROT,%eax
04:00001757 00
04:00001758 66BE0005F9	     6M 	mov $0xFFF90500,%esi
04:0000175D FF
04:0000175E 66BFFF0200	     7M 	mov $0x000002ff,%edi
04:00001763 00
04:00001764 BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:00001767 6625F8FF00	     1M 	and $0xFFF8,%eax
04:0000176C 00
04:0000176D 6601C3    	     2M 	add %eax,%ebx
04:00001770 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001773 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001777 66C1EE10  	     5M 	shr $16,%esi
04:0000177B 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:0000177D 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001781 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001785 66C1EF10  	     9M 	shr $16,%edi
04:00001789 89F9      	    10M 	mov %di,%cx
04:0000178B 80E10F    	    11M 	and $0x0f,%cl
04:0000178E 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001792 80E2F0    	    13M 	and $0xf0,%dl
04:00001795 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001799 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc GDT_DSEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   325: 	defGDTDesc GDTU_DSEG_PROT,0xFFF90500,0x000002ff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3
                      	     1M 	.ifnc GDTU_DSEG_PROT, 0
                      	     2M 	.set GDTU_DSEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:0000179D 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000017A2 15
04:000017A3 66B8380000	     5M 	mov $GDTU_DSEG_PROT,%eax
04:000017A8 00
04:000017A9 66BE0005F9	     6M 	mov $0xFFF90500,%esi
04:000017AE FF
04:000017AF 66BFFF0200	     7M 	mov $0x000002ff,%edi
04:000017B4 00
04:000017B5 BA00F2    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3|0,%dx
                      	     9M 	initDescriptor
04:000017B8 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000017BD 00
04:000017BE 6601C3    	     2M 	add %eax,%ebx
04:000017C1 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000017C4 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000017C8 66C1EE10  	     5M 	shr $16,%esi
04:000017CC 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:000017CE 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:000017D2 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000017D6 66C1EF10  	     9M 	shr $16,%edi
04:000017DA 89F9      	    10M 	mov %di,%cx
04:000017DC 80E10F    	    11M 	and $0x0f,%cl
04:000017DF 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000017E3 80E2F0    	    13M 	and $0xf0,%dl
04:000017E6 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000017EA 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc GDTU_DSEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   326: 	defGDTDesc LDT_SEG_PROT,  0xFFF90800,0x000007ff,ACC_TYPE_LDT|ACC_PRESENT
                      	     1M 	.ifnc LDT_SEG_PROT, 0
                      	     2M 	.set LDT_SEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:000017EE 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000017F3 15
04:000017F4 66B8400000	     5M 	mov $LDT_SEG_PROT,%eax
04:000017F9 00
04:000017FA 66BE0008F9	     6M 	mov $0xFFF90800,%esi
04:000017FF FF
04:00001800 66BFFF0700	     7M 	mov $0x000007ff,%edi
04:00001805 00
04:00001806 BA0082    	     8M 	mov $ACC_TYPE_LDT|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:00001809 6625F8FF00	     1M 	and $0xFFF8,%eax
04:0000180E 00
04:0000180F 6601C3    	     2M 	add %eax,%ebx
04:00001812 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001815 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001819 66C1EE10  	     5M 	shr $16,%esi
04:0000181D 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:0000181F 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001823 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001827 66C1EF10  	     9M 	shr $16,%edi
04:0000182B 89F9      	    10M 	mov %di,%cx
04:0000182D 80E10F    	    11M 	and $0x0f,%cl
04:00001830 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001834 80E2F0    	    13M 	and $0xf0,%dl
04:00001837 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:0000183B 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc LDT_SEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   327: 	defGDTDesc LDT_DSEG_PROT, 0xFFF90800,0x000007ff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc LDT_DSEG_PROT, 0
                      	     2M 	.set LDT_DSEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:0000183F 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001844 15
04:00001845 66B8480000	     5M 	mov $LDT_DSEG_PROT,%eax
04:0000184A 00
04:0000184B 66BE0008F9	     6M 	mov $0xFFF90800,%esi
04:00001850 FF
04:00001851 66BFFF0700	     7M 	mov $0x000007ff,%edi
04:00001856 00
04:00001857 BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:0000185A 6625F8FF00	     1M 	and $0xFFF8,%eax
04:0000185F 00
04:00001860 6601C3    	     2M 	add %eax,%ebx
04:00001863 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001866 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:0000186A 66C1EE10  	     5M 	shr $16,%esi
04:0000186E 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001870 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001874 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001878 66C1EF10  	     9M 	shr $16,%edi
04:0000187C 89F9      	    10M 	mov %di,%cx
04:0000187E 80E10F    	    11M 	and $0x0f,%cl
04:00001881 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001885 80E2F0    	    13M 	and $0xf0,%dl
04:00001888 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:0000188C 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc LDT_DSEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   328: 	defGDTDesc PG_SEG_PROT,   0xfff80000,0x0002ffff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc PG_SEG_PROT, 0
                      	     2M 	.set PG_SEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:00001890 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001895 15
04:00001896 66B8500000	     5M 	mov $PG_SEG_PROT,%eax
04:0000189B 00
04:0000189C 66BE0000F8	     6M 	mov $0xfff80000,%esi
04:000018A1 FF
04:000018A2 66BFFFFF02	     7M 	mov $0x0002ffff,%edi
04:000018A7 00
04:000018A8 BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:000018AB 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000018B0 00
04:000018B1 6601C3    	     2M 	add %eax,%ebx
04:000018B4 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000018B7 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000018BB 66C1EE10  	     5M 	shr $16,%esi
04:000018BF 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:000018C1 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:000018C5 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000018C9 66C1EF10  	     9M 	shr $16,%edi
04:000018CD 89F9      	    10M 	mov %di,%cx
04:000018CF 80E10F    	    11M 	and $0x0f,%cl
04:000018D2 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000018D6 80E2F0    	    13M 	and $0xf0,%dl
04:000018D9 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000018DD 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc PG_SEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   329: 	defGDTDesc S_SEG_PROT32,  0xfffc0000,0x0008ffff,ACC_TYPE_DATA_W|ACC_PRESENT,EXT_32BIT
                      	     1M 	.ifnc S_SEG_PROT32, 0
                      	     2M 	.set S_SEG_PROT32,GDTSelDesc
                      	     3M 	.endif
04:000018E1 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000018E6 15
04:000018E7 66B8580000	     5M 	mov $S_SEG_PROT32,%eax
04:000018EC 00
04:000018ED 66BE0000FC	     6M 	mov $0xfffc0000,%esi
04:000018F2 FF
04:000018F3 66BFFFFF08	     7M 	mov $0x0008ffff,%edi
04:000018F8 00
04:000018F9 BA4092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|EXT_32BIT,%dx
                      	     9M 	initDescriptor
04:000018FC 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001901 00
04:00001902 6601C3    	     2M 	add %eax,%ebx
04:00001905 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001908 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:0000190C 66C1EE10  	     5M 	shr $16,%esi
04:00001910 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001912 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001916 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:0000191A 66C1EF10  	     9M 	shr $16,%edi
04:0000191E 89F9      	    10M 	mov %di,%cx
04:00001920 80E10F    	    11M 	and $0x0f,%cl
04:00001923 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001927 80E2F0    	    13M 	and $0xf0,%dl
04:0000192A 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:0000192E 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc S_SEG_PROT32, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   330: 	defGDTDesc SU_SEG_PROT32, 0xfffc0000,0x0008ffff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3,EXT_32BIT
                      	     1M 	.ifnc SU_SEG_PROT32, 0
                      	     2M 	.set SU_SEG_PROT32,GDTSelDesc
                      	     3M 	.endif
04:00001932 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001937 15
04:00001938 66B8600000	     5M 	mov $SU_SEG_PROT32,%eax
04:0000193D 00
04:0000193E 66BE0000FC	     6M 	mov $0xfffc0000,%esi
04:00001943 FF
04:00001944 66BFFFFF08	     7M 	mov $0x0008ffff,%edi
04:00001949 00
04:0000194A BA40F2    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3|EXT_32BIT,%dx
                      	     9M 	initDescriptor
04:0000194D 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001952 00
04:00001953 6601C3    	     2M 	add %eax,%ebx
04:00001956 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001959 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:0000195D 66C1EE10  	     5M 	shr $16,%esi
04:00001961 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001963 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001967 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:0000196B 66C1EF10  	     9M 	shr $16,%edi
04:0000196F 89F9      	    10M 	mov %di,%cx
04:00001971 80E10F    	    11M 	and $0x0f,%cl
04:00001974 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001978 80E2F0    	    13M 	and $0xf0,%dl
04:0000197B 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:0000197F 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc SU_SEG_PROT32, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   331: 	defGDTDesc TSS_PROT,      0xfff94000,0x00000fff,ACC_TYPE_TSS|ACC_PRESENT|ACC_DPL_3
                      	     1M 	.ifnc TSS_PROT, 0
                      	     2M 	.set TSS_PROT,GDTSelDesc
                      	     3M 	.endif
04:00001983 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001988 15
04:00001989 66B8680000	     5M 	mov $TSS_PROT,%eax
04:0000198E 00
04:0000198F 66BE0040F9	     6M 	mov $0xfff94000,%esi
04:00001994 FF
04:00001995 66BFFF0F00	     7M 	mov $0x00000fff,%edi
04:0000199A 00
04:0000199B BA00E9    	     8M 	mov $ACC_TYPE_TSS|ACC_PRESENT|ACC_DPL_3|0,%dx
                      	     9M 	initDescriptor
04:0000199E 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000019A3 00
04:000019A4 6601C3    	     2M 	add %eax,%ebx
04:000019A7 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000019AA 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000019AE 66C1EE10  	     5M 	shr $16,%esi
04:000019B2 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:000019B4 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:000019B8 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000019BC 66C1EF10  	     9M 	shr $16,%edi
04:000019C0 89F9      	    10M 	mov %di,%cx
04:000019C2 80E10F    	    11M 	and $0x0f,%cl
04:000019C5 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000019C9 80E2F0    	    13M 	and $0xf0,%dl
04:000019CC 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000019D0 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc TSS_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   332: 	defGDTDesc TSS_DSEG_PROT, 0xfff94000,0x00000fff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc TSS_DSEG_PROT, 0
                      	     2M 	.set TSS_DSEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:000019D4 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000019D9 15
04:000019DA 66B8700000	     5M 	mov $TSS_DSEG_PROT,%eax
04:000019DF 00
04:000019E0 66BE0040F9	     6M 	mov $0xfff94000,%esi
04:000019E5 FF
04:000019E6 66BFFF0F00	     7M 	mov $0x00000fff,%edi
04:000019EB 00
04:000019EC BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:000019EF 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000019F4 00
04:000019F5 6601C3    	     2M 	add %eax,%ebx
04:000019F8 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000019FB 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000019FF 66C1EE10  	     5M 	shr $16,%esi
04:00001A03 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001A05 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001A09 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001A0D 66C1EF10  	     9M 	shr $16,%edi
04:00001A11 89F9      	    10M 	mov %di,%cx
04:00001A13 80E10F    	    11M 	and $0x0f,%cl
04:00001A16 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001A1A 80E2F0    	    13M 	and $0xf0,%dl
04:00001A1D 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001A21 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc TSS_DSEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   333: 	defGDTDesc FLAT_SEG_PROT, 0x00000000,0xffffffff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc FLAT_SEG_PROT, 0
                      	     2M 	.set FLAT_SEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:00001A25 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001A2A 15
04:00001A2B 66B8780000	     5M 	mov $FLAT_SEG_PROT,%eax
04:00001A30 00
04:00001A31 66BE000000	     6M 	mov $0x00000000,%esi
04:00001A36 00
04:00001A37 66BFFFFFFF	     7M 	mov $0xffffffff,%edi
04:00001A3C FF
04:00001A3D BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:00001A40 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001A45 00
04:00001A46 6601C3    	     2M 	add %eax,%ebx
04:00001A49 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001A4C 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001A50 66C1EE10  	     5M 	shr $16,%esi
04:00001A54 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001A56 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001A5A 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001A5E 66C1EF10  	     9M 	shr $16,%edi
04:00001A62 89F9      	    10M 	mov %di,%cx
04:00001A64 80E10F    	    11M 	and $0x0f,%cl
04:00001A67 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001A6B 80E2F0    	    13M 	and $0xf0,%dl
04:00001A6E 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001A72 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc FLAT_SEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   334: 	defGDTDesc RING0_GATE # placeholder for a call gate used to switch to ring 0
                      	     1M 	.ifnc RING0_GATE, 0
                      	     2M 	.set RING0_GATE,GDTSelDesc
                      	     3M 	.endif
04:00001A76 662EC51E09	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001A7B 15
04:00001A7C 66B8800000	     5M 	mov $RING0_GATE,%eax
04:00001A81 00
04:00001A82 66BE000000	     6M 	mov $0,%esi
04:00001A87 00
04:00001A88 66BF000000	     7M 	mov $0,%edi
04:00001A8D 00
04:00001A8E BA0000    	     8M 	mov $0|0,%dx
                      	     9M 	initDescriptor
04:00001A91 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001A96 00
04:00001A97 6601C3    	     2M 	add %eax,%ebx
04:00001A9A 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001A9D 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001AA1 66C1EE10  	     5M 	shr $16,%esi
04:00001AA5 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001AA7 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001AAB 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001AAF 66C1EF10  	     9M 	shr $16,%edi
04:00001AB3 89F9      	    10M 	mov %di,%cx
04:00001AB5 80E10F    	    11M 	and $0x0f,%cl
04:00001AB8 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001ABC 80E2F0    	    13M 	and $0xf0,%dl
04:00001ABF 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001AC3 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc RING0_GATE, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   335: 
04:00001AC7 EB6B      	   336: 	jmp initIDT
                      	   337: 
                      	   338: ptrIDTprot: # pointer to the IDT for pmode
04:00001AC9 00000000  	   339: 	.4byte 0         		# 32-bit offset
04:00001ACD 2000      	   340: 	.2byte IDT_SEG_PROT # 16-bit segment selector
                      	   341: ptrIDTUprot: # pointer to the IDT for pmode
04:00001ACF 00000000  	   342: 	.4byte 0            	# 32-bit offset
04:00001AD3 2800      	   343: 	.2byte IDTU_SEG_PROT  # 16-bit segment selector
                      	   344: ptrGDTprot: # pointer to the GDT for pmode (kernel mode data segment)
04:00001AD5 00000000  	   345: 	.4byte 0
04:00001AD9 3000      	   346: 	.2byte GDT_DSEG_PROT
                      	   347: ptrGDTUprot: # pointer to the GDT for pmode (user mode data segment)
04:00001ADB 00000000  	   348: 	.4byte 0
04:00001ADF 3800      	   349: 	.2byte GDTU_DSEG_PROT
                      	   350: ptrLDTprot: # pointer to the LDT for pmode
04:00001AE1 00000000  	   351: 	.4byte 0
04:00001AE5 4800      	   352: 	.2byte LDT_DSEG_PROT
                      	   353: ptrPDprot: # pointer to the Page Directory for pmode
04:00001AE7 00000000  	   354: 	.4byte 0
04:00001AEB 5000      	   355: 	.2byte PG_SEG_PROT
                      	   356: ptrPT0prot: # pointer to Page Table 0
04:00001AED 00100000  	   357: 	.4byte 0x1000
04:00001AF1 5000      	   358: 	.2byte PG_SEG_PROT
                      	   359: ptrPT1prot: # pointer to Page Table 1
04:00001AF3 00200000  	   360: 	.4byte 0x2000
04:00001AF7 5000      	   361: 	.2byte PG_SEG_PROT
                      	   362: ptrSSprot: # pointer to the stack for pmode
04:00001AF9 FFFF0000  	   363: 	.4byte ESP_R0_PROT
04:00001AFD 5800      	   364: 	.2byte S_SEG_PROT32
                      	   365: ptrTSSprot: # pointer to the task state segment
04:00001AFF 00000000  	   366: 	.4byte 0
04:00001B03 7000      	   367: 	.2byte TSS_DSEG_PROT
                      	   368: addrProtIDT: # address of pmode IDT to be used with lidt
04:00001B05 FF00      	   369: 	.2byte 0xFF              						# 16-bit limit
04:00001B07 0000FFFF  	   370: 	.4byte 0xffff0000|(IDT_SEG_REAL << 4) 	# 32-bit base address
                      	   371: addrGDT: # address of GDT to be used with lgdt
04:00001B0B FF02      	   372: 	.2byte GDT_SEG_LIMIT
04:00001B0D 0005FFFF  	   373: 	.4byte 0xffff0000|(GDT_SEG_REAL << 4)
                      	   374: 
                      	   375: # Initializes an interrupt gate in system memory in real mode
                      	   376: initIntGateReal:
04:00001B11 6660      	   377: 	pushal
                      	   378: 	initIntGate
04:00001B13 66C1E003  	     1M 	shl $3,%eax
04:00001B17 6601C3    	     2M 	add	%eax,%ebx
04:00001B1A 67893B    	     3M 	movw %di,(%ebx)
04:00001B1D 67897302  	     4M 	movw %si,2(%ebx)
04:00001B21 81CA008E  	     5M 	orw $ACC_TYPE_GATE386_INT | ACC_PRESENT, %dx
04:00001B25 67895304  	     6M 	movw %dx,4(%ebx)
04:00001B29 66C1EF10  	     7M 	shr $16,%edi
04:00001B2D 67897B06  	     8M 	movw %di,6(%ebx)
04:00001B31 6661      	   379: 	popal
04:00001B33 C3        	   380: 	ret
                      	   381: 
                      	   382: initIDT:
04:00001B34 662EC51E0F	   383: 	lds %cs:ptrIDTreal-TEST_CODE,%ebx
04:00001B39 15
04:00001B3A 66BE080000	   384: 	mov $C_SEG_PROT32,%esi
04:00001B3F 00
04:00001B40 66BFAD2401	   385: 	mov $DefaultExcHandler-TEST_CODE,%edi
04:00001B45 00
04:00001B46 BA0000    	   386: 	mov $ACC_DPL_0,%dx
                      	   387: .set vector,00
                      	   388: .rept 0x15
                      	   389: 	mov $vector,%eax
                      	   390: 	call initIntGateReal
                      	   391: .set vector,vector+1
                      	   392: .endr
04:00001B49 66B8000000	     1R 	mov $vector,%eax
04:00001B4E 00
04:00001B4F E8BFFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B52 66B8010000	     1R 	mov $vector,%eax
04:00001B57 00
04:00001B58 E8B6FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B5B 66B8020000	     1R 	mov $vector,%eax
04:00001B60 00
04:00001B61 E8ADFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B64 66B8030000	     1R 	mov $vector,%eax
04:00001B69 00
04:00001B6A E8A4FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B6D 66B8040000	     1R 	mov $vector,%eax
04:00001B72 00
04:00001B73 E89BFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B76 66B8050000	     1R 	mov $vector,%eax
04:00001B7B 00
04:00001B7C E892FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B7F 66B8060000	     1R 	mov $vector,%eax
04:00001B84 00
04:00001B85 E889FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B88 66B8070000	     1R 	mov $vector,%eax
04:00001B8D 00
04:00001B8E E880FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B91 66B8080000	     1R 	mov $vector,%eax
04:00001B96 00
04:00001B97 E877FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B9A 66B8090000	     1R 	mov $vector,%eax
04:00001B9F 00
04:00001BA0 E86EFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BA3 66B80A0000	     1R 	mov $vector,%eax
04:00001BA8 00
04:00001BA9 E865FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BAC 66B80B0000	     1R 	mov $vector,%eax
04:00001BB1 00
04:00001BB2 E85CFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BB5 66B80C0000	     1R 	mov $vector,%eax
04:00001BBA 00
04:00001BBB E853FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BBE 66B80D0000	     1R 	mov $vector,%eax
04:00001BC3 00
04:00001BC4 E84AFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BC7 66B80E0000	     1R 	mov $vector,%eax
04:00001BCC 00
04:00001BCD E841FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BD0 66B80F0000	     1R 	mov $vector,%eax
04:00001BD5 00
04:00001BD6 E838FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BD9 66B8100000	     1R 	mov $vector,%eax
04:00001BDE 00
04:00001BDF E82FFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BE2 66B8110000	     1R 	mov $vector,%eax
04:00001BE7 00
04:00001BE8 E826FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BEB 66B8120000	     1R 	mov $vector,%eax
04:00001BF0 00
04:00001BF1 E81DFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BF4 66B8130000	     1R 	mov $vector,%eax
04:00001BF9 00
04:00001BFA E814FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BFD 66B8140000	     1R 	mov $vector,%eax
04:00001C02 00
04:00001C03 E80BFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
                      	   393: 
04:00001C06 EB00      	   394: 	jmp initPaging
                      	   395: 
                      	   396: initPaging:
                      	   397: #
                      	   398: # pages:
                      	   399: #  FFF90000-FFF90FFF   1  1000h   4K IDTs, GDT and LDT
                      	   400: #  FFF80000-FFF81FFF   1  2000h   8K page directory
                      	   401: #  FFF82000-FFF83FFF   1  2000h   8K page table 0
                      	   402: #  FFF84000-FFF85FFF   1  2000h   8K page table 1
                      	   403: #  FFF94000-FFF95FFF   1  2000h   8K task switch segments
                      	   404: #  FFFC0000-FFFCFFFF  8  10000h   64K stack
                      	   405: #  FFFF0000-FFFFFFFF  8  10000h   64K tests
                      	   406: #  FFF86000-FFF87FFF   1  2000h   8K used for page faults (PTE 9Fh)
                      	   407: #
                      	   408: .set PAGE_DIR_ADDR,0x2000
                      	   409: .set PAGE_TBL0_ADDR,PAGE_DIR_ADDR+0x2000
                      	   410: .set PAGE_TBL1_ADDR,PAGE_DIR_ADDR+0x4000
                      	   411: 
                      	   412: #   Now we want to build a page table. We need two pages of
                      	   413: #   8K-aligned physical memory.  We use a hard-coded address, segment 0x8000,
                      	   414: #   corresponding to physical address 0xFFF80000.
                      	   415: #
04:00001C08 66BE002000	   416: 	mov $PAGE_DIR_ADDR,%esi
04:00001C0D 00
04:00001C0E 6689F0    	   417: 	mov %esi,%eax
04:00001C11 66C1E804  	   418: 	shr $4,%eax
04:00001C15 0D0080    	   419: 	or $0x8000,%ax
04:00001C18 8EC0      	   420: 	mov %ax,%es
                      	   421: #
                      	   422: #   Build a page table at ES:EDI (8000:0000) with only 64 valid PTEs at end,
                      	   423: #   because we're not going to access any memory outside the last 512kB.
                      	   424: #
                      	   425: # The .if is to avoid a long loop during simulation.
                      	   426: .if 0
                      	   427: 	cld
                      	   428: 	xor %edi,%edi
                      	   429: 	mov $1919,%ecx		# ECX == number of dwords to write = ((1024-64)*8)/4-1
                      	   430: 	xor %eax,%eax    	# fill PTEs with 0
                      	   431: 	rep
                      	   432: 	stosl
                      	   433: .endif
04:00001C1A 66BF001E00	   434: 	mov $7680,%edi		# index of last 64 PTEs
04:00001C1F 00
04:00001C20 66B97F0000	   435: 	mov $127,%ecx			# ECX = (64 * 8) / 4 - 1
04:00001C25 00
04:00001C26 66BA0000F8	   436: 	mov $0xfff80000,%edx
04:00001C2B FF
                      	   437: .ipt1:
04:00001C2C 66B8150000	   438: 	mov $PTE_PRESENT | PTE_USER | PTE_WRITE,%eax
04:00001C31 00
04:00001C32 6601D0    	   439: 	add %edx,%eax			# add in the address
04:00001C35 66AB      	   440: 	stosl
                      	   441: 	# Bits 32 to 63 can all be zero. The high order page number is not used
                      	   442: 	# because the test system uses only a 32-bit physical address.
04:00001C37 6631C0    	   443: 	xor %eax,%eax			# page table hi order page number
04:00001C3A 66AB      	   444: 	stosl
04:00001C3C 6681C20020	   445: 	add $0x2000,%edx	# increment address to next page
04:00001C41 0000
04:00001C43 E2E7      	   446: 	loop .ipt1
                      	   447: 
                      	   448: switchToProtMode:
04:00001C45 FA        	   449: 	cli 							# make sure interrupts are off now, since we've not initialized the IDT yet
04:00001C46 66        	   450: 	data32
04:00001C47 2E0F011E05	   451: 	lidt %cs:addrProtIDT-TEST_CODE
04:00001C4C 1B
04:00001C4D 66        	   452: 	data32
04:00001C4E 2E0F01160B	   453: 	lgdt %cs:addrGDT-TEST_CODE
04:00001C53 1B
04:00001C54 0F22DE    	   454: 	mov %esi,%cr3
04:00001C57 0F20C0    	   455: 	mov %cr0,%eax
04:00001C5A 660D010000	   456: 	or $CR0_MSW_PE | CR0_PG,%eax
04:00001C5F 80
04:00001C60 0F22C0    	   457: 	mov %eax,%cr0
04:00001C63 EA0800681C	   458: 	jmp $C_SEG_PROT32,$toProt32 	# jump to flush the prefetch queue
                      	   459: toProt32:
                      	   460: 	.code32
04:00001C68 E981000000	   461: 	jmp initLDT
                      	   462: 
                      	   463: .include "protected_p.asm"

Source: "protected_p.asm"
                      	     1: # Procedures for 32 bit code segment
                      	     2: 
                      	     3: initIntGateProt:
                      	     4: 	initIntGate
04:00001C6D C1E003    	     1M 	shl $3,%eax
04:00001C70 01C3      	     2M 	add	%eax,%ebx
04:00001C72 66893B    	     3M 	movw %di,(%ebx)
04:00001C75 66897302  	     4M 	movw %si,2(%ebx)
04:00001C79 6681CA008E	     5M 	orw $ACC_TYPE_GATE386_INT | ACC_PRESENT, %dx
04:00001C7E 66895304  	     6M 	movw %dx,4(%ebx)
04:00001C82 C1EF10    	     7M 	shr $16,%edi
04:00001C85 66897B06  	     8M 	movw %di,6(%ebx)
04:00001C89 C3        	     5: 	ret
                      	     6: 
                      	     7: initDescriptorProt:
                      	     8: 	initDescriptor
04:00001C8A 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001C8F 01C3      	     2M 	add %eax,%ebx
04:00001C91 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001C94 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001C98 C1EE10    	     5M 	shr $16,%esi
04:00001C9B 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001C9E 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001CA1 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001CA4 C1EF10    	     9M 	shr $16,%edi
04:00001CA7 6689F9    	    10M 	mov %di,%cx
04:00001CAA 80E10F    	    11M 	and $0x0f,%cl
04:00001CAD 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001CB0 80E2F0    	    13M 	and $0xf0,%dl
04:00001CB3 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001CB6 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
04:00001CB9 C3        	     9: 	ret
                      	    10: 
                      	    11: #
                      	    12: # Defines a Call Gate in GDT
                      	    13: #
                      	    14: #    7                             0 7                             0
                      	    15: #   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â
                      	    16: # +7â•‘                  DESTINATION OFFSET 31-16                     â•‘+6
                      	    17: #   â•Ÿâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â
                      	    18: # +5â•‘ P â”‚  DPL  â”‚ 0 â”‚ 1   1   0   0 â”‚ x   x   x â”‚  WORD COUNT 4-0   â•‘+4
                      	    19: #   â•Ÿâ”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â
                      	    20: # +3â•‘                 DESTINATION SELECTOR 15-2             â”‚ x   x â•‘+2
                      	    21: #   â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â
                      	    22: # +1â•‘                  DESTINATION OFFSET 15-0                      â•‘ 0
                      	    23: #   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â
                      	    24: #    15                                                            0
                      	    25: #
                      	    26: # FS:EBX pointer to the GDT
                      	    27: # EAX GDT selector
                      	    28: # SI  destination selector
                      	    29: # EDI destination offset
                      	    30: # DL word count
                      	    31: # DH DPL (as bit field, use ACC_DPL_* equs on dx)
                      	    32: #;
                      	    33: initCallGate:
04:00001CBA 25F8FF0000	    34: 	and $0xFFF8,%eax
04:00001CBF 01C3      	    35: 	add %eax,%ebx
04:00001CC1 6664893C1D	    36: 	movw %di,%fs:(,%ebx,1)   	# DESTINATION OFFSET 15-0
04:00001CC6 00000000
04:00001CCA 666489341D	    37: 	movw %si,%fs:2(,%ebx,1)		# DESTINATION SELECTOR 15-2
04:00001CCF 02000000
04:00001CD3 6681CA008C	    38: 	or $ACC_TYPE_GATE386_CALL | ACC_PRESENT,%dx
04:00001CD8 666489141D	    39: 	movw %dx,%fs:4(,%ebx,1) 	# ACC byte | WORD COUNT 4-0
04:00001CDD 04000000
04:00001CE1 C1EF10    	    40: 	shr $16,%edi
04:00001CE4 6664893C1D	    41: 	movw %di,%fs:6(,%ebx,1) 	# DESTINATION OFFSET 31-16
04:00001CE9 06000000
04:00001CED C3        	    42: 	ret
                      	    43: 

Source: "t386.asm"
                      	   464: 
                      	   465: initLDT:
                      	   466: 	defLDTDesc D_SEG_PROT16,   TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.set D_SEG_PROT16,LDTSelDesc
04:00001CEE 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001CF3 0000
04:00001CF5 B804000000	     3M 	mov $D_SEG_PROT16,%eax
04:00001CFA BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001CFF BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001D04 66BA0092  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     7M 	initDescriptor
04:00001D08 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001D0D 01C3      	     2M 	add %eax,%ebx
04:00001D0F 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001D12 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001D16 C1EE10    	     5M 	shr $16,%esi
04:00001D19 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001D1C 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001D1F 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001D22 C1EF10    	     9M 	shr $16,%edi
04:00001D25 6689F9    	    10M 	mov %di,%cx
04:00001D28 80E10F    	    11M 	and $0x0f,%cl
04:00001D2B 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001D2E 80E2F0    	    13M 	and $0xf0,%dl
04:00001D31 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001D34 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   467: 	defLDTDesc D_SEG_PROT32,   TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT,EXT_32BIT
                      	     1M 	.set D_SEG_PROT32,LDTSelDesc
04:00001D37 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001D3C 0000
04:00001D3E B80C000000	     3M 	mov $D_SEG_PROT32,%eax
04:00001D43 BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001D48 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001D4D 66BA4092  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|EXT_32BIT,%dx
                      	     7M 	initDescriptor
04:00001D51 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001D56 01C3      	     2M 	add %eax,%ebx
04:00001D58 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001D5B 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001D5F C1EE10    	     5M 	shr $16,%esi
04:00001D62 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001D65 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001D68 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001D6B C1EF10    	     9M 	shr $16,%edi
04:00001D6E 6689F9    	    10M 	mov %di,%cx
04:00001D71 80E10F    	    11M 	and $0x0f,%cl
04:00001D74 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001D77 80E2F0    	    13M 	and $0xf0,%dl
04:00001D7A 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001D7D 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   468: 	defLDTDesc DU_SEG_PROT,    TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3
                      	     1M 	.set DU_SEG_PROT,LDTSelDesc
04:00001D80 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001D85 0000
04:00001D87 B814000000	     3M 	mov $DU_SEG_PROT,%eax
04:00001D8C BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001D91 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001D96 66BA00F2  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3|0,%dx
                      	     7M 	initDescriptor
04:00001D9A 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001D9F 01C3      	     2M 	add %eax,%ebx
04:00001DA1 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001DA4 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001DA8 C1EE10    	     5M 	shr $16,%esi
04:00001DAB 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001DAE 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001DB1 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001DB4 C1EF10    	     9M 	shr $16,%edi
04:00001DB7 6689F9    	    10M 	mov %di,%cx
04:00001DBA 80E10F    	    11M 	and $0x0f,%cl
04:00001DBD 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001DC0 80E2F0    	    13M 	and $0xf0,%dl
04:00001DC3 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001DC6 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   469: 	defLDTDesc D1_SEG_PROT,    TEST_BASE1,0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.set D1_SEG_PROT,LDTSelDesc
04:00001DC9 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001DCE 0000
04:00001DD0 B81C000000	     3M 	mov $D1_SEG_PROT,%eax
04:00001DD5 BE0040FCFF	     4M 	mov $TEST_BASE1,%esi
04:00001DDA BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001DDF 66BA0092  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     7M 	initDescriptor
04:00001DE3 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001DE8 01C3      	     2M 	add %eax,%ebx
04:00001DEA 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001DED 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001DF1 C1EE10    	     5M 	shr $16,%esi
04:00001DF4 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001DF7 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001DFA 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001DFD C1EF10    	     9M 	shr $16,%edi
04:00001E00 6689F9    	    10M 	mov %di,%cx
04:00001E03 80E10F    	    11M 	and $0x0f,%cl
04:00001E06 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001E09 80E2F0    	    13M 	and $0xf0,%dl
04:00001E0C 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001E0F 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   470: 	defLDTDesc D2_SEG_PROT,    TEST_BASE2,0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.set D2_SEG_PROT,LDTSelDesc
04:00001E12 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001E17 0000
04:00001E19 B824000000	     3M 	mov $D2_SEG_PROT,%eax
04:00001E1E BE0060FCFF	     4M 	mov $TEST_BASE2,%esi
04:00001E23 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001E28 66BA0092  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     7M 	initDescriptor
04:00001E2C 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001E31 01C3      	     2M 	add %eax,%ebx
04:00001E33 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001E36 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001E3A C1EE10    	     5M 	shr $16,%esi
04:00001E3D 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001E40 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001E43 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001E46 C1EF10    	     9M 	shr $16,%edi
04:00001E49 6689F9    	    10M 	mov %di,%cx
04:00001E4C 80E10F    	    11M 	and $0x0f,%cl
04:00001E4F 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001E52 80E2F0    	    13M 	and $0xf0,%dl
04:00001E55 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001E58 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   471: 	defLDTDesc DC_SEG_PROT32,  TEST_BASE1,0x000fffff,ACC_TYPE_CODE_R|ACC_PRESENT,EXT_32BIT
                      	     1M 	.set DC_SEG_PROT32,LDTSelDesc
04:00001E5B 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001E60 0000
04:00001E62 B82C000000	     3M 	mov $DC_SEG_PROT32,%eax
04:00001E67 BE0040FCFF	     4M 	mov $TEST_BASE1,%esi
04:00001E6C BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001E71 66BA409A  	     6M 	mov $ACC_TYPE_CODE_R|ACC_PRESENT|EXT_32BIT,%dx
                      	     7M 	initDescriptor
04:00001E75 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001E7A 01C3      	     2M 	add %eax,%ebx
04:00001E7C 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001E7F 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001E83 C1EE10    	     5M 	shr $16,%esi
04:00001E86 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001E89 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001E8C 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001E8F C1EF10    	     9M 	shr $16,%edi
04:00001E92 6689F9    	    10M 	mov %di,%cx
04:00001E95 80E10F    	    11M 	and $0x0f,%cl
04:00001E98 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001E9B 80E2F0    	    13M 	and $0xf0,%dl
04:00001E9E 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001EA1 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   472: 	defLDTDesc RO_SEG_PROT,    TEST_BASE, 0x000fffff,ACC_TYPE_DATA_R|ACC_PRESENT
                      	     1M 	.set RO_SEG_PROT,LDTSelDesc
04:00001EA4 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001EA9 0000
04:00001EAB B834000000	     3M 	mov $RO_SEG_PROT,%eax
04:00001EB0 BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001EB5 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001EBA 66BA0090  	     6M 	mov $ACC_TYPE_DATA_R|ACC_PRESENT|0,%dx
                      	     7M 	initDescriptor
04:00001EBE 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001EC3 01C3      	     2M 	add %eax,%ebx
04:00001EC5 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001EC8 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001ECC C1EE10    	     5M 	shr $16,%esi
04:00001ECF 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001ED2 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001ED5 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001ED8 C1EF10    	     9M 	shr $16,%edi
04:00001EDB 6689F9    	    10M 	mov %di,%cx
04:00001EDE 80E10F    	    11M 	and $0x0f,%cl
04:00001EE1 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001EE4 80E2F0    	    13M 	and $0xf0,%dl
04:00001EE7 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001EEA 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   473: 	defLDTDesc ROU_SEG_PROT,   TEST_BASE, 0x000fffff,ACC_TYPE_DATA_R|ACC_PRESENT|ACC_DPL_3
                      	     1M 	.set ROU_SEG_PROT,LDTSelDesc
04:00001EED 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001EF2 0000
04:00001EF4 B83C000000	     3M 	mov $ROU_SEG_PROT,%eax
04:00001EF9 BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001EFE BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001F03 66BA00F0  	     6M 	mov $ACC_TYPE_DATA_R|ACC_PRESENT|ACC_DPL_3|0,%dx
                      	     7M 	initDescriptor
04:00001F07 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001F0C 01C3      	     2M 	add %eax,%ebx
04:00001F0E 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001F11 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001F15 C1EE10    	     5M 	shr $16,%esi
04:00001F18 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001F1B 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001F1E 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001F21 C1EF10    	     9M 	shr $16,%edi
04:00001F24 6689F9    	    10M 	mov %di,%cx
04:00001F27 80E10F    	    11M 	and $0x0f,%cl
04:00001F2A 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001F2D 80E2F0    	    13M 	and $0xf0,%dl
04:00001F30 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001F33 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   474: 	defLDTDesc DTEST_SEG_PROT, TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT,EXT_32BIT
                      	     1M 	.set DTEST_SEG_PROT,LDTSelDesc
04:00001F36 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001F3B 0000
04:00001F3D B844000000	     3M 	mov $DTEST_SEG_PROT,%eax
04:00001F42 BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001F47 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001F4C 66BA4092  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|EXT_32BIT,%dx
                      	     7M 	initDescriptor
04:00001F50 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001F55 01C3      	     2M 	add %eax,%ebx
04:00001F57 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001F5A 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001F5E C1EE10    	     5M 	shr $16,%esi
04:00001F61 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001F64 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001F67 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001F6A C1EF10    	     9M 	shr $16,%edi
04:00001F6D 6689F9    	    10M 	mov %di,%cx
04:00001F70 80E10F    	    11M 	and $0x0f,%cl
04:00001F73 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001F76 80E2F0    	    13M 	and $0xf0,%dl
04:00001F79 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001F7C 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   475: 	defLDTDesc DPL1_SEG_PROT,  TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_1
                      	     1M 	.set DPL1_SEG_PROT,LDTSelDesc
04:00001F7F 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001F84 0000
04:00001F86 B84C000000	     3M 	mov $DPL1_SEG_PROT,%eax
04:00001F8B BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001F90 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001F95 66BA00B2  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_1|0,%dx
                      	     7M 	initDescriptor
04:00001F99 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001F9E 01C3      	     2M 	add %eax,%ebx
04:00001FA0 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001FA3 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001FA7 C1EE10    	     5M 	shr $16,%esi
04:00001FAA 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001FAD 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001FB0 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001FB3 C1EF10    	     9M 	shr $16,%edi
04:00001FB6 6689F9    	    10M 	mov %di,%cx
04:00001FB9 80E10F    	    11M 	and $0x0f,%cl
04:00001FBC 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001FBF 80E2F0    	    13M 	and $0xf0,%dl
04:00001FC2 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001FC5 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   476: 	defLDTDesc NP_SEG_PROT,    TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W
                      	     1M 	.set NP_SEG_PROT,LDTSelDesc
04:00001FC8 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001FCD 0000
04:00001FCF B854000000	     3M 	mov $NP_SEG_PROT,%eax
04:00001FD4 BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001FD9 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001FDE 66BA0012  	     6M 	mov $ACC_TYPE_DATA_W|0,%dx
                      	     7M 	initDescriptor
04:00001FE2 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001FE7 01C3      	     2M 	add %eax,%ebx
04:00001FE9 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001FEC 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001FF0 C1EE10    	     5M 	shr $16,%esi
04:00001FF3 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001FF6 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001FF9 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001FFC C1EF10    	     9M 	shr $16,%edi
04:00001FFF 6689F9    	    10M 	mov %di,%cx
04:00002002 80E10F    	    11M 	and $0x0f,%cl
04:00002005 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00002008 80E2F0    	    13M 	and $0xf0,%dl
04:0000200B 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:0000200E 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   477: 	defLDTDesc SYS_SEG_PROT,   TEST_BASE, 0x000fffff,ACC_PRESENT
                      	     1M 	.set SYS_SEG_PROT,LDTSelDesc
04:00002011 2EC51DE11A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00002016 0000
04:00002018 B85C000000	     3M 	mov $SYS_SEG_PROT,%eax
04:0000201D BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00002022 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00002027 66BA0080  	     6M 	mov $ACC_PRESENT|0,%dx
                      	     7M 	initDescriptor
04:0000202B 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00002030 01C3      	     2M 	add %eax,%ebx
04:00002032 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00002035 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00002039 C1EE10    	     5M 	shr $16,%esi
04:0000203C 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:0000203F 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00002042 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00002045 C1EF10    	     9M 	shr $16,%edi
04:00002048 6689F9    	    10M 	mov %di,%cx
04:0000204B 80E10F    	    11M 	and $0x0f,%cl
04:0000204E 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00002051 80E2F0    	    13M 	and $0xf0,%dl
04:00002054 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00002057 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   478: 
04:0000205A 66B84000  	   479: 	mov  $LDT_SEG_PROT,%ax
04:0000205E 0F00D0    	   480: 	lldt %ax
04:00002061 66B86800  	   481: 	mov $TSS_PROT,%ax
04:00002065 0F00D8    	   482: 	ltr %ax
04:00002068 EB00      	   483: 	jmp protTests
                      	   484: 
                      	   485: #.include "tss_p.asm"
                      	   486: #.include "protected_rings_p.asm"
                      	   487: 
                      	   488: protTests:
                      	   489: 
                      	   490: .include "lea_m.asm"

Source: "lea_m.asm"
                      	     1: #
                      	     2: #   Execs LEA op with 16-bit addressing and compares the result with given value
                      	     3: #   %1 address to calculate
                      	     4: #   %2 value to compare
                      	     5: #   Uses: flags.
                      	     6: #
                      	     7: .macro testLEA16 arg1,arg2
                      	     8: 	push %ax
                      	     9: 	lea \arg1,%ax
                      	    10: 	cmp \arg2,%ax
                      	    11: 	jne error
                      	    12: 	pop %ax
                      	    13: .endm
                      	    14: 
                      	    15: #
                      	    16: #   Execs LEA op with 32-bit addressing and compares the result with given value
                      	    17: #   %1 address to calculate
                      	    18: #   %2 value to compare
                      	    19: #   Uses: flags.
                      	    20: #
                      	    21: .macro testLEA32 arg1,arg2
                      	    22: 	push %eax
                      	    23: 	lea \arg1,%eax
                      	    24: 	cmp \arg2,%eax
                      	    25: 	jne error
                      	    26: 	pop %eax
                      	    27: .endm
                      	    28: 

Source: "t386.asm"
                      	   491: #.include "lea_p.asm"
                      	   492: postD:
                      	   493: 
                      	   494: #-------------------------------------------------------------------------------
                      	   495: 	POST $0x0D
04:0000206A B00D      	     1M 	movb $0x0D,%al
04:0000206C 66BA9001  	     2M 	movw $POST_PORT,%dx
04:00002070 EE        	     3M 	out %al,%dx
                      	   496: #-------------------------------------------------------------------------------
                      	   497: #
                      	   498: #   16-bit addressing modes (LEA)
                      	   499: #
04:00002071 66B80100  	   500: 	mov $1,%ax
04:00002075 66BB0200  	   501: 	mov $2,%bx
04:00002079 66B90400  	   502: 	mov $4,%cx
04:0000207D 66BA0800  	   503: 	mov $8,%dx
04:00002081 66BE1000  	   504: 	mov $0x10,%si
04:00002085 66BF2000  	   505: 	mov $0x20,%di
                      	   506: 	testLEA16 0x4000, $0x4000
04:00002089 6650      	     1M 	push %ax
04:0000208B 668D050040	     2M 	lea 0x4000,%ax
04:00002090 0000
04:00002092 663D0040  	     3M 	cmp $0x4000,%ax
04:00002096 0F85110400	     4M 	jne error
04:0000209B 00
04:0000209C 6658      	     5M 	pop %ax
                      	   507: 	testLEA16 (%bx), $0x0002
04:0000209E 6650      	     1M 	push %ax
04:000020A0 67668D07  	     2M 	lea (%bx),%ax
04:000020A4 6683F802  	     3M 	cmp $0x0002,%ax
04:000020A8 0F85FF0300	     4M 	jne error
04:000020AD 00
04:000020AE 6658      	     5M 	pop %ax
                      	   508: 	testLEA16 (%si), $0x0010
04:000020B0 6650      	     1M 	push %ax
04:000020B2 67668D04  	     2M 	lea (%si),%ax
04:000020B6 6683F810  	     3M 	cmp $0x0010,%ax
04:000020BA 0F85ED0300	     4M 	jne error
04:000020BF 00
04:000020C0 6658      	     5M 	pop %ax
                      	   509: 	testLEA16 (%di), $0x0020
04:000020C2 6650      	     1M 	push %ax
04:000020C4 67668D05  	     2M 	lea (%di),%ax
04:000020C8 6683F820  	     3M 	cmp $0x0020,%ax
04:000020CC 0F85DB0300	     4M 	jne error
04:000020D1 00
04:000020D2 6658      	     5M 	pop %ax
                      	   510: 	testLEA16 0x40(%bx), $0x0042
04:000020D4 6650      	     1M 	push %ax
04:000020D6 67668D4740	     2M 	lea 0x40(%bx),%ax
04:000020DB 6683F842  	     3M 	cmp $0x0042,%ax
04:000020DF 0F85C80300	     4M 	jne error
04:000020E4 00
04:000020E5 6658      	     5M 	pop %ax
                      	   511: 	testLEA16 0x40(%si), $0x0050
04:000020E7 6650      	     1M 	push %ax
04:000020E9 67668D4440	     2M 	lea 0x40(%si),%ax
04:000020EE 6683F850  	     3M 	cmp $0x0050,%ax
04:000020F2 0F85B50300	     4M 	jne error
04:000020F7 00
04:000020F8 6658      	     5M 	pop %ax
                      	   512: 	testLEA16 0x40(%di), $0x0060
04:000020FA 6650      	     1M 	push %ax
04:000020FC 67668D4540	     2M 	lea 0x40(%di),%ax
04:00002101 6683F860  	     3M 	cmp $0x0060,%ax
04:00002105 0F85A20300	     4M 	jne error
04:0000210A 00
04:0000210B 6658      	     5M 	pop %ax
                      	   513: 	testLEA16 0x4000(%bx), $0x4002
04:0000210D 6650      	     1M 	push %ax
04:0000210F 67668D8700	     2M 	lea 0x4000(%bx),%ax
04:00002114 400000
04:00002117 663D0240  	     3M 	cmp $0x4002,%ax
04:0000211B 0F858C0300	     4M 	jne error
04:00002120 00
04:00002121 6658      	     5M 	pop %ax
                      	   514: 	testLEA16 0x4000(%si), $0x4010
04:00002123 6650      	     1M 	push %ax
04:00002125 67668D8400	     2M 	lea 0x4000(%si),%ax
04:0000212A 400000
04:0000212D 663D1040  	     3M 	cmp $0x4010,%ax
04:00002131 0F85760300	     4M 	jne error
04:00002136 00
04:00002137 6658      	     5M 	pop %ax
                      	   515: 	testLEA16 (%bx,%si), $0x0012
04:00002139 6650      	     1M 	push %ax
04:0000213B 67668D00  	     2M 	lea (%bx,%si),%ax
04:0000213F 6683F812  	     3M 	cmp $0x0012,%ax
04:00002143 0F85640300	     4M 	jne error
04:00002148 00
04:00002149 6658      	     5M 	pop %ax
                      	   516: 	testLEA16 (%bx,%di), $0x0022
04:0000214B 6650      	     1M 	push %ax
04:0000214D 67668D01  	     2M 	lea (%bx,%di),%ax
04:00002151 6683F822  	     3M 	cmp $0x0022,%ax
04:00002155 0F85520300	     4M 	jne error
04:0000215A 00
04:0000215B 6658      	     5M 	pop %ax
                      	   517: 	testLEA16 0x40(%bx,%si), $0x0052
04:0000215D 6650      	     1M 	push %ax
04:0000215F 67668D4040	     2M 	lea 0x40(%bx,%si),%ax
04:00002164 6683F852  	     3M 	cmp $0x0052,%ax
04:00002168 0F853F0300	     4M 	jne error
04:0000216D 00
04:0000216E 6658      	     5M 	pop %ax
                      	   518: 	testLEA16 0x40(%bx,%di), $0x0062
04:00002170 6650      	     1M 	push %ax
04:00002172 67668D4140	     2M 	lea 0x40(%bx,%di),%ax
04:00002177 6683F862  	     3M 	cmp $0x0062,%ax
04:0000217B 0F852C0300	     4M 	jne error
04:00002180 00
04:00002181 6658      	     5M 	pop %ax
                      	   519: 	testLEA16 0x4000(%bx,%si), $0x4012
04:00002183 6650      	     1M 	push %ax
04:00002185 67668D8000	     2M 	lea 0x4000(%bx,%si),%ax
04:0000218A 400000
04:0000218D 663D1240  	     3M 	cmp $0x4012,%ax
04:00002191 0F85160300	     4M 	jne error
04:00002196 00
04:00002197 6658      	     5M 	pop %ax
                      	   520: 	testLEA16 0x4000(%bx,%di), $0x4022
04:00002199 6650      	     1M 	push %ax
04:0000219B 67668D8100	     2M 	lea 0x4000(%bx,%di),%ax
04:000021A0 400000
04:000021A3 663D2240  	     3M 	cmp $0x4022,%ax
04:000021A7 0F85000300	     4M 	jne error
04:000021AC 00
04:000021AD 6658      	     5M 	pop %ax
                      	   521: 
                      	   522: 
                      	   523: #-------------------------------------------------------------------------------
                      	   524: 	POST $0xE0
04:000021AF B0E0      	     1M 	movb $0xE0,%al
04:000021B1 66BA9001  	     2M 	movw $POST_PORT,%dx
04:000021B5 EE        	     3M 	out %al,%dx
                      	   525: #-------------------------------------------------------------------------------
                      	   526: 
                      	   527: .shifts386FlagsTest:
                      	   528: 
                      	   529: 	# SHR al,cl - SHR ax,cl
                      	   530: 	# undefined flags:
                      	   531: 	#  CF when cl>7 (byte) or cl>15 (word):
                      	   532: 	#    if byte operand and cl=8 or cl=16 or cl=24 then CF=MSB(operand)
                      	   533: 	#    if word operand and cl=16 then CF=MSB(operand)
                      	   534: 	#  OF when cl>1: set according to result   *** rf386 calc's overflow cl>1
                      	   535: 	#  AF when cl>0: always 1
                      	   536: 	# shift count is modulo 32 so if cl=32 then result is equal to cl=0
                      	   537: 
                      	   538: 	testShiftBFlags shrb, $0x81, $1, $0, $(PS_CF|PS_AF|PS_OF)
04:000021B6 66B80000  	     1M 	mov $0,%ax
04:000021BA 6650      	     2M 	push %ax
04:000021BC 9D        	     3M 	popf
04:000021BD B4FF      	     4M 	mov $0xff,%ah
04:000021BF B081      	     5M 	mov $0x81,%al
04:000021C1 B101      	     6M 	mov $1,%cl
04:000021C3 D2E8      	     7M 	shrb %cl,%al
04:000021C5 9C        	     8M 	pushf
04:000021C6 6658      	     9M 	pop %ax
04:000021C8 6625D508  	    10M 	and $PS_ARITH,%ax
04:000021CC 663D1108  	    11M 	cmp $(PS_CF|PS_AF|PS_OF),%ax
04:000021D0 0F85D70200	    12M 	jne error
04:000021D5 00
                      	   539: 	testShiftBFlags shrb, $0x82, $2, $0, $(PS_CF|PS_AF|PS_OF)
04:000021D6 66B80000  	     1M 	mov $0,%ax
04:000021DA 6650      	     2M 	push %ax
04:000021DC 9D        	     3M 	popf
04:000021DD B4FF      	     4M 	mov $0xff,%ah
04:000021DF B082      	     5M 	mov $0x82,%al
04:000021E1 B102      	     6M 	mov $2,%cl
04:000021E3 D2E8      	     7M 	shrb %cl,%al
04:000021E5 9C        	     8M 	pushf
04:000021E6 6658      	     9M 	pop %ax
04:000021E8 6625D508  	    10M 	and $PS_ARITH,%ax
04:000021EC 663D1108  	    11M 	cmp $(PS_CF|PS_AF|PS_OF),%ax
04:000021F0 0F85B70200	    12M 	jne error
04:000021F5 00
                      	   540: 	testShiftBFlags shrb, $0x80, $8, $0, $(PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF)
04:000021F6 66B80000  	     1M 	mov $0,%ax
04:000021FA 6650      	     2M 	push %ax
04:000021FC 9D        	     3M 	popf
04:000021FD B4FF      	     4M 	mov $0xff,%ah
04:000021FF B080      	     5M 	mov $0x80,%al
04:00002201 B108      	     6M 	mov $8,%cl
04:00002203 D2E8      	     7M 	shrb %cl,%al
04:00002205 9C        	     8M 	pushf
04:00002206 6658      	     9M 	pop %ax
04:00002208 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000220C 663D5508  	    11M 	cmp $(PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF),%ax
04:00002210 0F85970200	    12M 	jne error
04:00002215 00
                      	   541: 	testShiftBFlags shrb, $0x00,   $8,  $PS_CF, $(PS_PF|PS_ZF)
04:00002216 66B80100  	     1M 	mov $PS_CF,%ax
04:0000221A 6650      	     2M 	push %ax
04:0000221C 9D        	     3M 	popf
04:0000221D B4FF      	     4M 	mov $0xff,%ah
04:0000221F B000      	     5M 	mov $0x00,%al
04:00002221 B108      	     6M 	mov $8,%cl
04:00002223 D2E8      	     7M 	shrb %cl,%al
04:00002225 9C        	     8M 	pushf
04:00002226 6658      	     9M 	pop %ax
04:00002228 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000222C 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:00002230 0F85770200	    12M 	jne error
04:00002235 00
                      	   542: 	testShiftBFlags shrb, $0x80,   $16, $0,     $(PS_PF|PS_ZF|PS_OF)
04:00002236 66B80000  	     1M 	mov $0,%ax
04:0000223A 6650      	     2M 	push %ax
04:0000223C 9D        	     3M 	popf
04:0000223D B4FF      	     4M 	mov $0xff,%ah
04:0000223F B080      	     5M 	mov $0x80,%al
04:00002241 B110      	     6M 	mov $16,%cl
04:00002243 D2E8      	     7M 	shrb %cl,%al
04:00002245 9C        	     8M 	pushf
04:00002246 6658      	     9M 	pop %ax
04:00002248 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000224C 663D4408  	    11M 	cmp $(PS_PF|PS_ZF|PS_OF),%ax
04:00002250 0F85570200	    12M 	jne error
04:00002255 00
                      	   543: 	testShiftBFlags shrb, $0x00,   $16, $PS_CF, $(PS_PF|PS_ZF)
04:00002256 66B80100  	     1M 	mov $PS_CF,%ax
04:0000225A 6650      	     2M 	push %ax
04:0000225C 9D        	     3M 	popf
04:0000225D B4FF      	     4M 	mov $0xff,%ah
04:0000225F B000      	     5M 	mov $0x00,%al
04:00002261 B110      	     6M 	mov $16,%cl
04:00002263 D2E8      	     7M 	shrb %cl,%al
04:00002265 9C        	     8M 	pushf
04:00002266 6658      	     9M 	pop %ax
04:00002268 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000226C 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:00002270 0F85370200	    12M 	jne error
04:00002275 00
                      	   544: 	testShiftBFlags shrb, $0x80,   $24, $0,     $(PS_PF|PS_ZF|PS_OF)
04:00002276 66B80000  	     1M 	mov $0,%ax
04:0000227A 6650      	     2M 	push %ax
04:0000227C 9D        	     3M 	popf
04:0000227D B4FF      	     4M 	mov $0xff,%ah
04:0000227F B080      	     5M 	mov $0x80,%al
04:00002281 B118      	     6M 	mov $24,%cl
04:00002283 D2E8      	     7M 	shrb %cl,%al
04:00002285 9C        	     8M 	pushf
04:00002286 6658      	     9M 	pop %ax
04:00002288 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000228C 663D4408  	    11M 	cmp $(PS_PF|PS_ZF|PS_OF),%ax
04:00002290 0F85170200	    12M 	jne error
04:00002295 00
                      	   545: 	testShiftBFlags shrb, $0x00,   $24, $PS_CF, $(PS_PF|PS_ZF)
04:00002296 66B80100  	     1M 	mov $PS_CF,%ax
04:0000229A 6650      	     2M 	push %ax
04:0000229C 9D        	     3M 	popf
04:0000229D B4FF      	     4M 	mov $0xff,%ah
04:0000229F B000      	     5M 	mov $0x00,%al
04:000022A1 B118      	     6M 	mov $24,%cl
04:000022A3 D2E8      	     7M 	shrb %cl,%al
04:000022A5 9C        	     8M 	pushf
04:000022A6 6658      	     9M 	pop %ax
04:000022A8 6625D508  	    10M 	and $PS_ARITH,%ax
04:000022AC 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:000022B0 0F85F70100	    12M 	jne error
04:000022B5 00
                      	   546: 	testShiftBFlags shrb, $0x80,   $32, $0,     $PS_SF
04:000022B6 66B80000  	     1M 	mov $0,%ax
04:000022BA 6650      	     2M 	push %ax
04:000022BC 9D        	     3M 	popf
04:000022BD B4FF      	     4M 	mov $0xff,%ah
04:000022BF B080      	     5M 	mov $0x80,%al
04:000022C1 B120      	     6M 	mov $32,%cl
04:000022C3 D2E8      	     7M 	shrb %cl,%al
04:000022C5 9C        	     8M 	pushf
04:000022C6 6658      	     9M 	pop %ax
04:000022C8 6625D508  	    10M 	and $PS_ARITH,%ax
04:000022CC 663D8000  	    11M 	cmp $PS_SF,%ax
04:000022D0 0F85D70100	    12M 	jne error
04:000022D5 00
                      	   547: 	testShiftWFlags shrw, $0x8000, $16, $0,     $(PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF)
04:000022D6 66B80000  	     1M 	mov $0,%ax
04:000022DA 6650      	     2M 	push %ax
04:000022DC 9D        	     3M 	popf
04:000022DD 66B80080  	     4M 	mov $0x8000,%ax
04:000022E1 B110      	     5M 	mov $16,%cl
04:000022E3 66D3E8    	     6M 	shrw %cl,%ax
04:000022E6 9C        	     7M 	pushf
04:000022E7 6658      	     8M 	pop %ax
04:000022E9 6625D508  	     9M 	and $PS_ARITH,%ax
04:000022ED 663D5508  	    10M 	cmp $(PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF),%ax
04:000022F1 0F85B60100	    11M 	jne error
04:000022F6 00
                      	   548: 	testShiftWFlags shrw, $0x0000, $16, $PS_CF, $(PS_PF|PS_ZF)
04:000022F7 66B80100  	     1M 	mov $PS_CF,%ax
04:000022FB 6650      	     2M 	push %ax
04:000022FD 9D        	     3M 	popf
04:000022FE 66B80000  	     4M 	mov $0x0000,%ax
04:00002302 B110      	     5M 	mov $16,%cl
04:00002304 66D3E8    	     6M 	shrw %cl,%ax
04:00002307 9C        	     7M 	pushf
04:00002308 6658      	     8M 	pop %ax
04:0000230A 6625D508  	     9M 	and $PS_ARITH,%ax
04:0000230E 6683F844  	    10M 	cmp $(PS_PF|PS_ZF),%ax
04:00002312 0F85950100	    11M 	jne error
04:00002317 00
                      	   549: 	testShiftWFlags shrw, $0x8000, $32, $0,     $PS_SF|PS_PF
04:00002318 66B80000  	     1M 	mov $0,%ax
04:0000231C 6650      	     2M 	push %ax
04:0000231E 9D        	     3M 	popf
04:0000231F 66B80080  	     4M 	mov $0x8000,%ax
04:00002323 B120      	     5M 	mov $32,%cl
04:00002325 66D3E8    	     6M 	shrw %cl,%ax
04:00002328 9C        	     7M 	pushf
04:00002329 6658      	     8M 	pop %ax
04:0000232B 6625D508  	     9M 	and $PS_ARITH,%ax
04:0000232F 663D8400  	    10M 	cmp $PS_SF|PS_PF,%ax
04:00002333 0F85740100	    11M 	jne error
04:00002338 00
                      	   550: 
                      	   551: 	# SHL al,cl - SHL ax,cl
                      	   552: 	# undefined flags:
                      	   553: 	#  CF when cl>7 (byte) or cl>15 (word):
                      	   554: 	#    if byte operand and cl=8 or cl=16 or cl=24 then CF=LSB(operand)
                      	   555: 	#    if word operand and cl=16 then CF=LSB(operand)
                      	   556: 	#  OF when cl>1: set according to result
                      	   557: 	#  AF when cl>0: always 1
                      	   558: 	# shift count is modulo 32 so if cl=32 then result is equal to cl=0
                      	   559: 
                      	   560: 	testShiftBFlags shlb, $0x81, $1,  $0,     $(PS_CF|PS_OF)
04:00002339 66B80000  	     1M 	mov $0,%ax
04:0000233D 6650      	     2M 	push %ax
04:0000233F 9D        	     3M 	popf
04:00002340 B4FF      	     4M 	mov $0xff,%ah
04:00002342 B081      	     5M 	mov $0x81,%al
04:00002344 B101      	     6M 	mov $1,%cl
04:00002346 D2E0      	     7M 	shlb %cl,%al
04:00002348 9C        	     8M 	pushf
04:00002349 6658      	     9M 	pop %ax
04:0000234B 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000234F 663D0108  	    11M 	cmp $(PS_CF|PS_OF),%ax
04:00002353 0F85540100	    12M 	jne error
04:00002358 00
                      	   561: 	testShiftBFlags shlb, $0x41, $2,  $0,     $(PS_CF|PS_OF)
04:00002359 66B80000  	     1M 	mov $0,%ax
04:0000235D 6650      	     2M 	push %ax
04:0000235F 9D        	     3M 	popf
04:00002360 B4FF      	     4M 	mov $0xff,%ah
04:00002362 B041      	     5M 	mov $0x41,%al
04:00002364 B102      	     6M 	mov $2,%cl
04:00002366 D2E0      	     7M 	shlb %cl,%al
04:00002368 9C        	     8M 	pushf
04:00002369 6658      	     9M 	pop %ax
04:0000236B 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000236F 663D0108  	    11M 	cmp $(PS_CF|PS_OF),%ax
04:00002373 0F85340100	    12M 	jne error
04:00002378 00
                      	   562: 	testShiftBFlags shlb, $0x01, $8,  $0,     $(PS_CF|PS_PF|PS_ZF|PS_OF)
04:00002379 66B80000  	     1M 	mov $0,%ax
04:0000237D 6650      	     2M 	push %ax
04:0000237F 9D        	     3M 	popf
04:00002380 B4FF      	     4M 	mov $0xff,%ah
04:00002382 B001      	     5M 	mov $0x01,%al
04:00002384 B108      	     6M 	mov $8,%cl
04:00002386 D2E0      	     7M 	shlb %cl,%al
04:00002388 9C        	     8M 	pushf
04:00002389 6658      	     9M 	pop %ax
04:0000238B 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000238F 663D4508  	    11M 	cmp $(PS_CF|PS_PF|PS_ZF|PS_OF),%ax
04:00002393 0F85140100	    12M 	jne error
04:00002398 00
                      	   563: 	testShiftBFlags shlb, $0x00, $8,  $PS_CF, $(PS_PF|PS_ZF)
04:00002399 66B80100  	     1M 	mov $PS_CF,%ax
04:0000239D 6650      	     2M 	push %ax
04:0000239F 9D        	     3M 	popf
04:000023A0 B4FF      	     4M 	mov $0xff,%ah
04:000023A2 B000      	     5M 	mov $0x00,%al
04:000023A4 B108      	     6M 	mov $8,%cl
04:000023A6 D2E0      	     7M 	shlb %cl,%al
04:000023A8 9C        	     8M 	pushf
04:000023A9 6658      	     9M 	pop %ax
04:000023AB 6625D508  	    10M 	and $PS_ARITH,%ax
04:000023AF 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:000023B3 0F85F40000	    12M 	jne error
04:000023B8 00
                      	   564: 	testShiftBFlags shlb, $0x01, $16, $0,     $(PS_CF|PS_PF|PS_ZF|PS_OF)
04:000023B9 66B80000  	     1M 	mov $0,%ax
04:000023BD 6650      	     2M 	push %ax
04:000023BF 9D        	     3M 	popf
04:000023C0 B4FF      	     4M 	mov $0xff,%ah
04:000023C2 B001      	     5M 	mov $0x01,%al
04:000023C4 B110      	     6M 	mov $16,%cl
04:000023C6 D2E0      	     7M 	shlb %cl,%al
04:000023C8 9C        	     8M 	pushf
04:000023C9 6658      	     9M 	pop %ax
04:000023CB 6625D508  	    10M 	and $PS_ARITH,%ax
04:000023CF 663D4508  	    11M 	cmp $(PS_CF|PS_PF|PS_ZF|PS_OF),%ax
04:000023D3 0F85D40000	    12M 	jne error
04:000023D8 00
                      	   565: 	testShiftBFlags shlb, $0x00, $16, $PS_CF, $(PS_PF|PS_ZF)
04:000023D9 66B80100  	     1M 	mov $PS_CF,%ax
04:000023DD 6650      	     2M 	push %ax
04:000023DF 9D        	     3M 	popf
04:000023E0 B4FF      	     4M 	mov $0xff,%ah
04:000023E2 B000      	     5M 	mov $0x00,%al
04:000023E4 B110      	     6M 	mov $16,%cl
04:000023E6 D2E0      	     7M 	shlb %cl,%al
04:000023E8 9C        	     8M 	pushf
04:000023E9 6658      	     9M 	pop %ax
04:000023EB 6625D508  	    10M 	and $PS_ARITH,%ax
04:000023EF 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:000023F3 0F85B40000	    12M 	jne error
04:000023F8 00
                      	   566: 	testShiftBFlags shlb, $0x01, $24, $0,     $(PS_CF|PS_PF|PS_ZF|PS_OF)
04:000023F9 66B80000  	     1M 	mov $0,%ax
04:000023FD 6650      	     2M 	push %ax
04:000023FF 9D        	     3M 	popf
04:00002400 B4FF      	     4M 	mov $0xff,%ah
04:00002402 B001      	     5M 	mov $0x01,%al
04:00002404 B118      	     6M 	mov $24,%cl
04:00002406 D2E0      	     7M 	shlb %cl,%al
04:00002408 9C        	     8M 	pushf
04:00002409 6658      	     9M 	pop %ax
04:0000240B 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000240F 663D4508  	    11M 	cmp $(PS_CF|PS_PF|PS_ZF|PS_OF),%ax
04:00002413 0F85940000	    12M 	jne error
04:00002418 00
                      	   567: 	testShiftBFlags shlb, $0x00, $24, $PS_CF, $(PS_PF|PS_ZF)
04:00002419 66B80100  	     1M 	mov $PS_CF,%ax
04:0000241D 6650      	     2M 	push %ax
04:0000241F 9D        	     3M 	popf
04:00002420 B4FF      	     4M 	mov $0xff,%ah
04:00002422 B000      	     5M 	mov $0x00,%al
04:00002424 B118      	     6M 	mov $24,%cl
04:00002426 D2E0      	     7M 	shlb %cl,%al
04:00002428 9C        	     8M 	pushf
04:00002429 6658      	     9M 	pop %ax
04:0000242B 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000242F 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:00002433 7578      	    12M 	jne error
                      	   568: 	testShiftBFlags shlb, $0x01, $32, $0,     $0
04:00002435 66B80000  	     1M 	mov $0,%ax
04:00002439 6650      	     2M 	push %ax
04:0000243B 9D        	     3M 	popf
04:0000243C B4FF      	     4M 	mov $0xff,%ah
04:0000243E B001      	     5M 	mov $0x01,%al
04:00002440 B120      	     6M 	mov $32,%cl
04:00002442 D2E0      	     7M 	shlb %cl,%al
04:00002444 9C        	     8M 	pushf
04:00002445 6658      	     9M 	pop %ax
04:00002447 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000244B 6683F800  	    11M 	cmp $0,%ax
04:0000244F 755C      	    12M 	jne error
                      	   569: 	testShiftWFlags shlw, $0x01, $16, $0,     $(PS_CF|PS_PF|PS_ZF|PS_OF)
04:00002451 66B80000  	     1M 	mov $0,%ax
04:00002455 6650      	     2M 	push %ax
04:00002457 9D        	     3M 	popf
04:00002458 66B80100  	     4M 	mov $0x01,%ax
04:0000245C B110      	     5M 	mov $16,%cl
04:0000245E 66D3E0    	     6M 	shlw %cl,%ax
04:00002461 9C        	     7M 	pushf
04:00002462 6658      	     8M 	pop %ax
04:00002464 6625D508  	     9M 	and $PS_ARITH,%ax
04:00002468 663D4508  	    10M 	cmp $(PS_CF|PS_PF|PS_ZF|PS_OF),%ax
04:0000246C 753F      	    11M 	jne error
                      	   570: 	testShiftWFlags shlw, $0x00, $16, $PS_CF, $(PS_PF|PS_ZF)
04:0000246E 66B80100  	     1M 	mov $PS_CF,%ax
04:00002472 6650      	     2M 	push %ax
04:00002474 9D        	     3M 	popf
04:00002475 66B80000  	     4M 	mov $0x00,%ax
04:00002479 B110      	     5M 	mov $16,%cl
04:0000247B 66D3E0    	     6M 	shlw %cl,%ax
04:0000247E 9C        	     7M 	pushf
04:0000247F 6658      	     8M 	pop %ax
04:00002481 6625D508  	     9M 	and $PS_ARITH,%ax
04:00002485 6683F844  	    10M 	cmp $(PS_PF|PS_ZF),%ax
04:00002489 7522      	    11M 	jne error
                      	   571: 	testShiftWFlags shlw, $0x01, $32, $0,     $0
04:0000248B 66B80000  	     1M 	mov $0,%ax
04:0000248F 6650      	     2M 	push %ax
04:00002491 9D        	     3M 	popf
04:00002492 66B80100  	     4M 	mov $0x01,%ax
04:00002496 B120      	     5M 	mov $32,%cl
04:00002498 66D3E0    	     6M 	shlw %cl,%ax
04:0000249B 9C        	     7M 	pushf
04:0000249C 6658      	     8M 	pop %ax
04:0000249E 6625D508  	     9M 	and $PS_ARITH,%ax
04:000024A2 6683F800  	    10M 	cmp $0,%ax
04:000024A6 7505      	    11M 	jne error
                      	   572: 
04:000024A8 E9FCFFFFFF	   573: 	jmp _bootrom
                      	   574: 
                      	   575: #	pushl $10
                      	   576: #	call _Fibonacci
                      	   577: 
                      	   578: #
                      	   579: # Default exception handler and error routine
                      	   580: #
                      	   581: DefaultExcHandler:
                      	   582: error:
                      	   583: # CLI and HLT are privileged instructions, don't use them in ring3
04:000024AD 668CC8    	   584: 	mov %cs,%ax
                      	   585: 
                      	   586: # when in real mode, the jnz will be decoded together with test as
                      	   587: # "test eax,0xfe750007" (66A9070075FE)
04:000024B0 66A90700  	   588: 	test $7,%ax     # 66 A9 07 00
04:000024B4 75FE      	   589: .ring3: jnz .ring3 # 75 FE
04:000024B6 FA        	   590: 	cli
04:000024B7 F4        	   591: 	hlt
04:000024B8 EBF3      	   592: 	jmp error
                      	   593: 
                      	   594: 
                      	   595: .rept 16
                      	   596: 	nop
                      	   597: .endr
04:000024BA 90        	     1R 	nop
04:000024BB 90        	     1R 	nop
04:000024BC 90        	     1R 	nop
04:000024BD 90        	     1R 	nop
04:000024BE 90        	     1R 	nop
04:000024BF 90        	     1R 	nop
04:000024C0 90        	     1R 	nop
04:000024C1 90        	     1R 	nop
04:000024C2 90        	     1R 	nop
04:000024C3 90        	     1R 	nop
04:000024C4 90        	     1R 	nop
04:000024C5 90        	     1R 	nop
04:000024C6 90        	     1R 	nop
04:000024C7 90        	     1R 	nop
04:000024C8 90        	     1R 	nop
04:000024C9 90        	     1R 	nop
                      	   598: 	
                      	   599: #	.type	_start,@function
                      	   600: #	.size	_start,$-_start
                      	   601: 
                      	   602: #.include "Fibonacci.asm"
                      	   603: #.include "serial.asm"
                      	   604: #.include "xmodem.asm"
                      	   605: #.include "bootrom.asm"
                      	   606: 
                      	   607: .global _disable_int
                      	   608: .global _restore_int
                      	   609: .extern _start_data
                      	   610: .extern _start_rodata
                      	   611: .extern _start_bss
                      	   612: 


Symbols by name:
.ipt1                           04:00001C2C
.ring3                          04:000024B4
.shifts386FlagsTest             04:000021B6
ACC_DPL_0                        S:00000000
ACC_DPL_1                        S:00002000
ACC_DPL_3                        S:00006000
ACC_PRESENT                      S:00008000
ACC_TYPE_CODE_R                  S:00001A00
ACC_TYPE_CONFORMING              S:00000400
ACC_TYPE_DATA_R                  S:00001000
ACC_TYPE_DATA_W                  S:00001200
ACC_TYPE_GATE386_CALL            S:00000C00
ACC_TYPE_GATE386_INT             S:00000E00
ACC_TYPE_LDT                     S:00000200
ACC_TYPE_TSS                     S:00000900
CC_SEG_PROT32                    S:00000018
CR0_MSW_PE                       S:00000001
CR0_PG                           S:80000000
CU_SEG_PROT32                    S:00000010
C_SEG_PROT16                     S:00000000
C_SEG_PROT32                     S:00000008
C_SEG_REAL                       S:0000F000
D1_SEG_PROT                      S:0000001C
D1_SEG_REAL                      S:0FFFC400
D2_SEG_PROT                      S:00000024
D2_SEG_REAL                      S:0FFFC600
DC_SEG_PROT32                    S:0000002C
DPL1_SEG_PROT                    S:0000004C
DTEST_SEG_PROT                   S:00000044
DU_SEG_PROT                      S:00000014
D_SEG_PROT16                     S:00000004
D_SEG_PROT32                     S:0000000C
DefaultExcHandler               04:000024AD
ESP_R0_PROT                      S:0000FFFF
ESP_REAL                         S:00007FFC
EXT_32BIT                        S:00000040
EXT_NONE                         S:00000000
EX_UD                            S:00000006
FLAT_SEG_PROT                    S:00000078
GDTSelDesc                       S:00000088
GDTU_DSEG_PROT                   S:00000038
GDT_DSEG_PROT                    S:00000030
GDT_SEG_LIMIT                    S:000002FF
GDT_SEG_REAL                     S:00009050
IDTU_SEG_PROT                    S:00000028
IDT_SEG_PROT                     S:00000020
IDT_SEG_REAL                     S:00009000
LDTSelDesc                       S:00000064
LDT_DSEG_PROT                    S:00000048
LDT_SEG_PROT                     S:00000040
NP_SEG_PROT                      S:00000054
PAGE_DIR_ADDR                    S:00002000
PG_SEG_PROT                      S:00000050
POST_PORT                        S:00000190
PS_AF                            S:00000010
PS_ARITH                         S:000008D5
PS_CF                            S:00000001
PS_OF                            S:00000800
PS_PF                            S:00000004
PS_SF                            S:00000080
PS_ZF                            S:00000040
PTE_PRESENT                      S:00000001
PTE_USER                         S:00000010
PTE_WRITE                        S:00000004
RING0_GATE                       S:00000080
ROU_SEG_PROT                     S:0000003C
RO_SEG_PROT                      S:00000034
SU_SEG_PROT32                    S:00000060
SYS_SEG_PROT                     S:0000005C
S_SEG_PROT32                     S:00000058
S_SEG_REAL                       S:0000C000
TEST_BASE                        S:FFFC0000
TEST_BASE1                       S:FFFC4000
TEST_BASE2                       S:FFFC6000
TEST_CODE                        S:FFFF0000
TSS_DSEG_PROT                    S:00000070
TSS_PROT                         S:00000068
_Fibonacci                      external EXP
_bootrom                        external EXP
_disable_int                    external EXP
_restore_int                    external EXP
_start                          04:00000000
_start1                         04:0000005B
_start_bss                      external EXP
_start_data                     external EXP
_start_rodata                   external EXP
addrGDT                         04:00001B0B
addrProtIDT                     04:00001B05
aloop7                          04:00000076
b                                S:00000000
bytes                            S:00000100
continue25                      04:0000054D
continue28                      04:000005C7
d                                S:00000002
err110                          04:000000C7
err111                          04:00000209
err210                          04:0000013C
err211                          04:00000394
error                           04:000024AD
exit10                          04:0000014B
exit11                          04:000003A9
exit52                          04:00001349
farfn1652                       04:000012F3
farfn3252                       04:00001313
header                          04:00000002
idt_addr                        03:00000000
initCallGate                    04:00001CBA
initDescriptorProt              04:00001C8A
initGDT                         04:00001515
initIDT                         04:00001B34
initIntGateProt                 04:00001C6D
initIntGateReal                 04:00001B11
initLDT                         04:00001CEE
initPaging                      04:00001C08
items                            S:00000040
ja10                            04:000000EE
ja11                            04:00000242
jaok10                          04:000000FE
jaok11                          04:000002DD
jcok10                          04:000000C8
jcok11                          04:0000020A
jcxz10                          04:00000120
jcxz11                          04:00000311
jcxzok10                        04:00000147
jecxz10                         04:00000130
jecxze10                        04:0000013A
jecxzok10                       04:00000149
jl10                            04:00000117
jl11                            04:00000304
jle10                           04:0000011D
jle11                           04:0000030C
jleok10                         04:00000145
jleok11                         04:000003A5
jlok10                          04:00000143
jlok11                          04:000003A1
jna10                           04:000000BE
jna11                           04:0000017B
jnaok10                         04:000000D0
jnaok11                         04:0000021A
jnc10                           04:000000D2
jnc11                           04:0000021E
jncok10                         04:000000F6
jncok11                         04:000002CD
jnl10                           04:0000010D
jnl11                           04:000002F2
jnle10                          04:00000112
jnle11                          04:000002FB
jnleok10                        04:00000141
jnleok11                        04:0000039D
jnlok10                         04:0000013F
jnlok11                         04:00000399
jnp10                           04:000000E2
jnp11                           04:00000232
jnpok10                         04:000000FA
jnpok11                         04:000002D5
jns10                           04:000000E8
jns11                           04:0000023A
jnsok10                         04:000000FC
jnsok11                         04:000002D9
jnz10                           04:000000DC
jnz11                           04:0000022A
jnzok10                         04:000000F8
jnzok11                         04:000002D1
jo10                            04:00000100
jo11                            04:000002E1
jook10                          04:0000013D
jook11                          04:00000395
jp10                            04:000000AE
jp11                            04:00000163
jpok10                          04:000000CC
jpok11                          04:00000212
js10                            04:000000B6
js11                            04:0000016F
jsok10                          04:000000CE
jsok11                          04:00000216
jz10                            04:000000A6
jz11                            04:00000157
jzok10                          04:000000CA
jzok11                          04:0000020E
m161652                         04:00001325
m163252                         04:00001335
nearfn1651                      04:0000129F
nearfn3251                      04:000012BB
next110                         04:000000C5
next111                         04:00000186
next210                         04:000000F4
next211                         04:0000024A
o3252                           04:00001304
off_cmp                          S:0001FFFF
off_mask                         S:0000FFFF
off_value                        S:000100FF
postD                           04:0000206A
protTests                       04:0000206A
ptrGDTUprot                     04:00001ADB
ptrGDTprot                      04:00001AD5
ptrGDTreal                      04:00001509
ptrIDTUprot                     04:00001ACF
ptrIDTprot                      04:00001AC9
ptrIDTreal                      04:0000150F
ptrLDTprot                      04:00001AE1
ptrPDprot                       04:00001AE7
ptrPT0prot                      04:00001AED
ptrPT1prot                      04:00001AF3
ptrSSprot                       04:00001AF9
ptrTSSprot                      04:00001AFF
realmd_mask                      S:0000FFFF
rel1651                         04:00001295
rel3251                         04:000012B0
rm1651                          04:000012CD
rm3251                          04:000012D7
rodata_seg                       S:0FFFA000
romGDT                          04:00001503
romGDTEnd                       04:00001503
romGDTaddr                      04:00001503
start_rodata                     S:FFFA0000
switchToProtMode                04:00001C45
test25                          04:00000548
test28                          04:000005C0
toProt32                        04:00001C68
val_mask                         S:FFFFFFFF
val_size                         S:00000004
value                            S:12345678
vector                           S:00000015
w                                S:00000001

Symbols by value:
FFFA0000 start_rodata
FFFC0000 TEST_BASE
FFFC4000 TEST_BASE1
FFFC6000 TEST_BASE2
FFFF0000 TEST_CODE
FFFFFFFF val_mask
00000000 b
00000000 EXT_NONE
00000000 idt_addr
00000000 ACC_DPL_0
00000000 C_SEG_PROT16
00000000 _start
00000001 w
00000001 PTE_PRESENT
00000001 PS_CF
00000001 CR0_MSW_PE
00000002 header
00000002 d
00000004 val_size
00000004 PS_PF
00000004 PTE_WRITE
00000004 D_SEG_PROT16
00000006 EX_UD
00000008 C_SEG_PROT32
0000000C D_SEG_PROT32
00000010 PS_AF
00000010 PTE_USER
00000010 CU_SEG_PROT32
00000014 DU_SEG_PROT
00000015 vector
00000018 CC_SEG_PROT32
0000001C D1_SEG_PROT
00000020 IDT_SEG_PROT
00000024 D2_SEG_PROT
00000028 IDTU_SEG_PROT
0000002C DC_SEG_PROT32
00000030 GDT_DSEG_PROT
00000034 RO_SEG_PROT
00000038 GDTU_DSEG_PROT
0000003C ROU_SEG_PROT
00000040 items
00000040 EXT_32BIT
00000040 LDT_SEG_PROT
00000040 PS_ZF
00000044 DTEST_SEG_PROT
00000048 LDT_DSEG_PROT
0000004C DPL1_SEG_PROT
00000050 PG_SEG_PROT
00000054 NP_SEG_PROT
00000058 S_SEG_PROT32
0000005B _start1
0000005C SYS_SEG_PROT
00000060 SU_SEG_PROT32
00000064 LDTSelDesc
00000068 TSS_PROT
00000070 TSS_DSEG_PROT
00000076 aloop7
00000078 FLAT_SEG_PROT
00000080 PS_SF
00000080 RING0_GATE
00000088 GDTSelDesc
000000A6 jz10
000000AE jp10
000000B6 js10
000000BE jna10
000000C5 next110
000000C7 err110
000000C8 jcok10
000000CA jzok10
000000CC jpok10
000000CE jsok10
000000D0 jnaok10
000000D2 jnc10
000000DC jnz10
000000E2 jnp10
000000E8 jns10
000000EE ja10
000000F4 next210
000000F6 jncok10
000000F8 jnzok10
000000FA jnpok10
000000FC jnsok10
000000FE jaok10
00000100 bytes
00000100 jo10
0000010D jnl10
00000112 jnle10
00000117 jl10
0000011D jle10
00000120 jcxz10
00000130 jecxz10
0000013A jecxze10
0000013C err210
0000013D jook10
0000013F jnlok10
00000141 jnleok10
00000143 jlok10
00000145 jleok10
00000147 jcxzok10
00000149 jecxzok10
0000014B exit10
00000157 jz11
00000163 jp11
0000016F js11
0000017B jna11
00000186 next111
00000190 POST_PORT
00000200 ACC_TYPE_LDT
00000209 err111
0000020A jcok11
0000020E jzok11
00000212 jpok11
00000216 jsok11
0000021A jnaok11
0000021E jnc11
0000022A jnz11
00000232 jnp11
0000023A jns11
00000242 ja11
0000024A next211
000002CD jncok11
000002D1 jnzok11
000002D5 jnpok11
000002D9 jnsok11
000002DD jaok11
000002E1 jo11
000002F2 jnl11
000002FB jnle11
000002FF GDT_SEG_LIMIT
00000304 jl11
0000030C jle11
00000311 jcxz11
00000394 err211
00000395 jook11
00000399 jnlok11
0000039D jnleok11
000003A1 jlok11
000003A5 jleok11
000003A9 exit11
00000400 ACC_TYPE_CONFORMING
00000548 test25
0000054D continue25
000005C0 test28
000005C7 continue28
00000800 PS_OF
000008D5 PS_ARITH
00000900 ACC_TYPE_TSS
00000C00 ACC_TYPE_GATE386_CALL
00000E00 ACC_TYPE_GATE386_INT
00001000 ACC_TYPE_DATA_R
00001200 ACC_TYPE_DATA_W
00001295 rel1651
0000129F nearfn1651
000012B0 rel3251
000012BB nearfn3251
000012CD rm1651
000012D7 rm3251
000012F3 farfn1652
00001304 o3252
00001313 farfn3252
00001325 m161652
00001335 m163252
00001349 exit52
00001503 romGDT
00001503 romGDTaddr
00001503 romGDTEnd
00001509 ptrGDTreal
0000150F ptrIDTreal
00001515 initGDT
00001A00 ACC_TYPE_CODE_R
00001AC9 ptrIDTprot
00001ACF ptrIDTUprot
00001AD5 ptrGDTprot
00001ADB ptrGDTUprot
00001AE1 ptrLDTprot
00001AE7 ptrPDprot
00001AED ptrPT0prot
00001AF3 ptrPT1prot
00001AF9 ptrSSprot
00001AFF ptrTSSprot
00001B05 addrProtIDT
00001B0B addrGDT
00001B11 initIntGateReal
00001B34 initIDT
00001C08 initPaging
00001C2C .ipt1
00001C45 switchToProtMode
00001C68 toProt32
00001C6D initIntGateProt
00001C8A initDescriptorProt
00001CBA initCallGate
00001CEE initLDT
00002000 PAGE_DIR_ADDR
00002000 ACC_DPL_1
0000206A protTests
0000206A postD
000021B6 .shifts386FlagsTest
000024AD DefaultExcHandler
000024AD error
000024B4 .ring3
00006000 ACC_DPL_3
00007FFC ESP_REAL
00008000 ACC_PRESENT
00009000 IDT_SEG_REAL
00009050 GDT_SEG_REAL
0000C000 S_SEG_REAL
0000F000 C_SEG_REAL
0000FFFF realmd_mask
0000FFFF off_mask
0000FFFF ESP_R0_PROT
000100FF off_value
0001FFFF off_cmp
0FFFA000 rodata_seg
0FFFC400 D1_SEG_REAL
0FFFC600 D2_SEG_REAL
12345678 value
80000000 CR0_PG
