Sections:
00: ".pgtbl" (0-A)
01: ".bss" (0-A)
02: ".data" (0-A)
03: ".rodata" (0-6)
04: ".text" (0-24CC)


Source: "t386.asm"
                      	     1: # t386.asm rf386 cpu test
                      	     2: # Port to vasm standard syntax including mods.
                      	     3: # (c) 2024 Robert Finch <robfinch@finitron.ca>
                      	     4: #
                      	     5: # Original work from test386.asm
                      	     6: #   Copyright (C) 2012-2015 Jeff Parsons <Jeff@pcjs.org>
                      	     7: #   Copyright (C) 2017-2021 Marco Bortolin <barotto@gmail.com>
                      	     8: #
                      	     9: #   This file is a derivative work of PCjs
                      	    10: #   https://www.pcjs.org/software/pcx86/test/cpu/80386/test386.asm
                      	    11: #
                      	    12: #   test386.asm is free software: you can redistribute it and/or modify it under
                      	    13: #   the terms of the GNU General Public License as published by the Free
                      	    14: #   Software Foundation, either version 3 of the License, or (at your option)
                      	    15: #   any later version.
                      	    16: #
                      	    17: #   test386.asm is distributed in the hope that it will be useful, but WITHOUT ANY
                      	    18: #   WARRANTY without even the implied warranty of MERCHANTABILITY or FITNESS
                      	    19: #   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
                      	    20: #   details.
                      	    21: #
                      	    22: #   You should have received a copy of the GNU General Public License along with
                      	    23: #   test386.asm.  If not see <http://www.gnu.org/licenses/gpl.html>.
                      	    24: #
                      	    25: #   This program was originally developed for IBMulator
                      	    26: #   https://barotto.github.io/IBMulator
                      	    27: #
                      	    28: #   Overview
                      	    29: #   --------
                      	    30: #   This file is designed to run as a test ROM, loaded in place of the BIOS.
                      	    31: #   Its pourpose is to test the CPU, reporting its status to the POST port and
                      	    32: #   its computational results in ASCII form to various configurable ports.
                      	    33: #   A 80386 or later CPU is required. This ROM is designed to test an emulator
                      	    34: #   CPU and was never tested on real hardware.
                      	    35: #
                      	    36: #   It must be installed at physical address 0xffff0000 and aliased at physical
                      	    37: #   address 0xffff0000.  The jump at resetVector should align with the CPU reset
                      	    38: #   address 0xfffffff0, which will transfer control to f000:0045.  From that
                      	    39: #   point on, all memory accesses should remain within the first 1MB.
                      	    40: #
                      	    41: 
                      	    42: #
                      	    43: # WARNING
                      	    44: #
                      	    45: #   A word of caution before you start developing.
                      	    46: #   NASM (2.11.08) generates [ebp + ebp] for [ebp*2] (i.e. no base register),
                      	    47: #   which are not the same thing: [ebp+ebp] references the SS segment, [ebp*2]
                      	    48: #   references the DS segment.
                      	    49: #   NASM developers think [ebp*2] and [ebp+ebp] are the same, but that is true
                      	    50: #   only assuming a flat memory model. Until the time NASM authors realize their
                      	    51: #   mistake (any assumption of a flat memory model should be optional), you can
                      	    52: #   disable this behaviour by writing: [nosplit ebp*2].
                      	    53: #
                      	    54: #	NASM Assembly            Translated               Assembled
                      	    55: #	mov eax,[ebp*2]          mov eax,[ebp+ebp*1+0x0]  8B442D00
                      	    56: #	mov eax,[nosplit ebp*2]  mov eax,[ebp*2+0x0]      8B046D00000000
                      	    57: #
                      	    58: 
                      	    59: .macro cpyright
                      	    60: 	.ascii "t386.asm (c) 2024 Robert Finch (C) 2012-2015 Jeff Parsons, (C) 2017-2021 Marco Bortolin ",0
                      	    61: .endm
                      	    62: .macro RELEASE
                      	    63: 	.ascii "??/??/24",0
                      	    64: .endm
                      	    65: 
                      	    66: 	.set POST_PORT,0x190
                      	    67: 
                      	    68: #
                      	    69: # memory map:
                      	    70: #  FFF80000-FFF8FFFF page table
                      	    71: #  FFF90000-FFF903FF real mode IDT
                      	    72: #  FFF90400-FFF904FF protected mode IDT
                      	    73: #  FFF90500-FFF9077F protected mode GDT
                      	    74: #  FFF90800-FFF90FFF protected mode LDT
                      	    75: #  FFFA0000-FFFAFFFF read only data
                      	    76: #  FFFC0000-FFFCFFFF stack
                      	    77: #  FFF01000-FFF01FFF page directory
                      	    78: #  FFF94000-FFF95FFF TSS
                      	    79: #  20000-9FFFF tests
                      	    80: #
                      	    81: 
                      	    82: .set realmd_mask,0x0000ffff
                      	    83: .set rodata_seg,0x0fffa000
                      	    84: .set start_rodata,0xfffa0000
                      	    85: .set TEST_BASE,0xFFFC0000
                      	    86: .set TEST_CODE,0xFFFF0000
                      	    87: .set TEST_BASE1,TEST_BASE+0x0000
                      	    88: .set TEST_BASE2,TEST_BASE+0x2000
                      	    89: 
                      	    90: 	.section .pgtbl
00:00000000 00        	    91: 	.space 10
00:00000001 *
                      	    92: 
                      	    93: 	.bss
01:00000000 00        	    94: 	.space	10
01:00000001 *
                      	    95: 
                      	    96: 	.data
02:00000000 00        	    97: 	.space	10
02:00000001 *
                      	    98: 
                      	    99: 	.rodata
                      	   100: idt_addr:
03:00000000 0004      	   101: 	.2byte 0x400
03:00000002 0000F9FF  	   102: 	.4byte 0xFFF90000		# Linear address of table
                      	   103: 
                      	   104: #	.org	0xF0000
                      	   105: 	.text
                      	   106: 	.code16
                      	   107: #	.align	0
                      	   108: .extern	_bootrom
                      	   109: .extern _Fibonacci
                      	   110: 
                      	   111: #
                      	   112: #   Real mode segments
                      	   113: #
                      	   114: .set C_SEG_REAL,0xF000
                      	   115: .set S_SEG_REAL,0xC000
                      	   116: .set IDT_SEG_REAL,0x9000
                      	   117: .set IDT_SEG_PROT,0x9040
                      	   118: .set GDT_SEG_REAL,0x9050
                      	   119: .set GDT_SEG_LIMIT,0x2FF
                      	   120: .set D1_SEG_REAL,TEST_BASE1 >> 4
                      	   121: .set D2_SEG_REAL,TEST_BASE2 >> 4
                      	   122: 
                      	   123: .set ESP_REAL,0x7ffc
                      	   124: 
                      	   125: 
                      	   126: .include "x86_e.asm"

Source: "x86_e.asm"
                      	     1: .set PS_CF,0x0001
                      	     2: .set PS_PF,0x0004
                      	     3: .set PS_AF,0x0010
                      	     4: .set PS_ZF,0x0040
                      	     5: .set PS_SF,0x0080
                      	     6: .set PS_TF,0x0100
                      	     7: .set PS_IF,0x0200
                      	     8: .set PS_DF,0x0400
                      	     9: .set PS_OF,0x0800
                      	    10: .set PS_ARITH,(PS_CF | PS_PF | PS_AF | PS_ZF | PS_SF | PS_OF)
                      	    11: .set PS_LOGIC,(PS_CF | PS_PF | PS_ZF | PS_SF | PS_OF)
                      	    12: .set PS_MULTIPLY,(PS_CF | PS_OF) # only CF and OF are "defined" following MUL or IMUL
                      	    13: .set PS_DIVIDE,0 # none of the Processor Status flags are "defined" following DIV or IDIV
                      	    14: .set PS_SHIFTS_1,(PS_CF | PS_SF | PS_ZF | PS_PF | PS_OF)
                      	    15: .set PS_SHIFTS_R,(PS_CF | PS_SF | PS_ZF | PS_PF)
                      	    16: 
                      	    17: .set CR0_MSW_PE,0x0001
                      	    18: .set CR0_PG,0x80000000	# set if paging enabled
                      	    19: 
                      	    20: .set ACC_TYPE_GATE386_INT,0x0E00
                      	    21: .set ACC_TYPE_GATE386_CALL,0x0C00
                      	    22: .set ACC_TYPE_SEG,0x1000
                      	    23: .set ACC_PRESENT,0x8000
                      	    24: .set ACC_TYPE_CODE_R,0x1a00
                      	    25: .set ACC_TYPE_CONFORMING,0x0400
                      	    26: .set ACC_TYPE_DATA_R,0x1000
                      	    27: .set ACC_TYPE_DATA_W,0x1200
                      	    28: .set ACC_TYPE_LDT,0x0200
                      	    29: .set ACC_TYPE_TSS,0x0900
                      	    30: 
                      	    31: .set ACC_DPL_0,0x0000
                      	    32: .set ACC_DPL_1,0x2000
                      	    33: .set ACC_DPL_2,0x4000
                      	    34: .set ACC_DPL_3,0x6000
                      	    35: 
                      	    36: .set EXT_NONE,0x0000
                      	    37: .set EXT_16BIT,EXT_NONE
                      	    38: .set EXT_32BIT,0x0040 # size bit
                      	    39: .set EXT_PAGE,0x0080 # granularity bit
                      	    40: 
                      	    41: # i386 paging
                      	    42: #PTE_FRAME,0xffffe000
                      	    43: #PTE_DIRTY,0x00000040 		# page has been modified
                      	    44: #PTE_ACCESSED  equ 0x00000020 ; page has been accessed
                      	    45: #PTE_USER      equ 0x00000004 ; set for user level (CPL 3), clear for supervisor level (CPL 0-2)
                      	    46: #PTE_WRITE     equ 0x00000002 ; set for read/write, clear for read-only (affects CPL 3 only)
                      	    47: #PTE_PRESENT   equ 0x00000001 ; set for present page, clear for not-present page
                      	    48: 
                      	    49: # Bigfoot paging
                      	    50: .set PTE_FRAME,0xffffe000
                      	    51: .set PTE_DIRTY,0x00000080 		# page has been modified
                      	    52: .set PTE_ACCESSED,0x00000040 	# page has been accessed
                      	    53: .set PTE_USER,0x00000010 			# set for user level (CPL 3), clear for supervisor level (CPL 0-2)
                      	    54: .set PTE_WRITE,0x00000004 		# set for read/write, clear for read-only (affects CPL 3 only)
                      	    55: .set PTE_PRESENT,0x00000001 	# set for present page, clear for not-present page
                      	    56: 
                      	    57: #PTE_PRESENT_BIT   equ 0000001b
                      	    58: #PTE_WRITE_BIT     equ 0000010b
                      	    59: #PTE_USER_BIT      equ 0000100b
                      	    60: #PTE_ACCESSED_BIT  equ 0100000b
                      	    61: #PTE_DIRTY_BIT     equ 1000000b
                      	    62: 
                      	    63: .set EX_DE,0
                      	    64: .set EX_DB,1
                      	    65: .set EX_BP,3
                      	    66: .set EX_OF,4
                      	    67: .set EX_BR,5
                      	    68: .set EX_UD,6
                      	    69: .set EX_NM,7
                      	    70: .set EX_DF,8
                      	    71: .set EX_MP,9
                      	    72: .set EX_TS,10
                      	    73: .set EX_NP,11
                      	    74: .set EX_SS,12
                      	    75: .set EX_GP,13
                      	    76: .set EX_PF,14
                      	    77: .set EX_MF,15
                      	    78: 

Source: "t386.asm"
                      	   127: .include "macros_m.asm"

Source: "macros_m.asm"
                      	     1: #
                      	     2: #   Output a byte to the POST port, destroys al and dx
                      	     3: #
                      	     4: .macro POST arg1
                      	     5: 	movb \arg1,%al
                      	     6: 	movw $POST_PORT,%dx
                      	     7: 	out %al,%dx
                      	     8: .endm
                      	     9: 
                      	    10: #
                      	    11: # Initializes an interrupt gate in system memory.
                      	    12: # This is the body of procedures used in 16 and 32-bit code segments.
                      	    13: #
                      	    14: #    7                             0 7                             0
                      	    15: #   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â
                      	    16: # +7â•‘                          OFFSET 31-16                         â•‘+6
                      	    17: #   â•Ÿâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â
                      	    18: # +5â•‘ P â”‚  DPL  â”‚ 0 â”‚ 1   1   1   0 â”‚            UNUSED             â•‘+4
                      	    19: #   â•Ÿâ”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â
                      	    20: # +3â•‘                           SELECTOR                            â•‘+2
                      	    21: #   â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â
                      	    22: # +1â•‘                          OFFSET 15-0                          â•‘ 0
                      	    23: #   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â
                      	    24: #    15                                                            0
                      	    25: #
                      	    26: # DS:EBX pointer to IDT
                      	    27: # EAX vector
                      	    28: # ESI selector
                      	    29: # EDI offset
                      	    30: # DX DPL (use ACC_DPL_* equs)
                      	    31: #
                      	    32: .macro initIntGate
                      	    33: 	shl $3,%eax
                      	    34: 	add	%eax,%ebx
                      	    35: 	movw %di,(%ebx)
                      	    36: 	movw %si,2(%ebx)
                      	    37: 	orw $ACC_TYPE_GATE386_INT | ACC_PRESENT, %dx
                      	    38: 	movw %dx,4(%ebx)
                      	    39: 	shr $16,%edi
                      	    40: 	movw %di,6(%ebx)
                      	    41: .endm
                      	    42: 
                      	    43: #
                      	    44: # Set a descriptor in system memory.
                      	    45: # This is the body of procedures used in 16 and 32-bit code segments.
                      	    46: #
                      	    47: #    7                             0 7                             0
                      	    48: #   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•¤â•â
                      	    49: # +7â•‘            BASE 31-24         â”‚ G â”‚B/Dâ”‚ 0 â”‚AVLâ”‚  LIMIT 19-16  â•‘+6
                      	    50: #   â•Ÿâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¼â”€â”€â”€â”´â”€â
                      	    51: # +5â•‘ P â”‚  DPL  â”‚ S â”‚    TYPE    (A)â”‚          BASE 23-16           â•‘+4
                      	    52: #   â•Ÿâ”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â
                      	    53: # +3â•‘                           BASE 15-0                           â•‘+2
                      	    54: #   â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â
                      	    55: # +1â•‘                           LIMIT 15-0                          â•‘ 0
                      	    56: #   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â
                      	    57: #    15                                                            0
                      	    58: #
                      	    59: # DS:EBX pointer to the descriptor table
                      	    60: # EAX segment selector
                      	    61: # ESI base
                      	    62: # EDI limit
                      	    63: # DL ext nibble (upper 4 bits)
                      	    64: # DH acc byte (P|DPL|S|TYPE|A)
                      	    65: #
                      	    66: .macro initDescriptor
                      	    67: 	and $0xFFF8,%eax
                      	    68: 	add %eax,%ebx
                      	    69: 	movw %di,(%ebx)						# LIMIT 15-0
                      	    70: 	movw %si,2(%ebx)					# BASE 15-0
                      	    71: 	shr $16,%esi
                      	    72: 	mov %si,%ax								# AX := BASE 31-16
                      	    73: 	movb %al,4(%ebx)					# BASE 23-16
                      	    74: 	movb %dh,5(%ebx)					# acc byte
                      	    75: 	shr $16,%edi
                      	    76: 	mov %di,%cx
                      	    77: 	and $0x0f,%cl
                      	    78: 	movb %cl,6(%ebx)					# LIMIT 19-16
                      	    79: 	and $0xf0,%dl
                      	    80: 	orb %dl,6(%ebx)						# ext nybble
                      	    81: 	movb %ah,7(%ebx)					# BASE 31-24
                      	    82: .endm
                      	    83: 
                      	    84: 
                      	    85: .macro advTestBase
                      	    86: 	.set TEST_BASE1,TEST_BASE1+0x1000
                      	    87: 	.set TEST_BASE2,TEST_BASE2+0x1000
                      	    88: .endm
                      	    89: 

Source: "t386.asm"
                      	   128: .include "shift_m.asm"

Source: "shift_m.asm"
                      	     1: #
                      	     2: #   Executes a byte shift operation and checks the resulting flags.
                      	     3: #
                      	     4: #   %1 operation
                      	     5: #   %2 al: byte operand
                      	     6: #   %3 cl: shift count
                      	     7: #   %4 flags: value of flags before %1 execution
                      	     8: #   %5 flags: expected value of flags after %1 execution (cmp with PS_ARITH mask)
                      	     9: #
                      	    10: #   Uses: AX, CL, Flags
                      	    11: #
                      	    12: 
                      	    13: .macro testShiftBFlags arg1,arg2,arg3,arg4,arg5
                      	    14: 	mov \arg4,%ax
                      	    15: 	push %ax
                      	    16: 	popf
                      	    17: 	mov $0xff,%ah
                      	    18: 	mov \arg2,%al
                      	    19: 	mov \arg3,%cl
                      	    20: 	\arg1 %cl,%al
                      	    21: 	pushf
                      	    22: 	pop %ax
                      	    23: 	and $PS_ARITH,%ax
                      	    24: 	cmp \arg5,%ax
                      	    25: 	jne error
                      	    26: .endm
                      	    27: 
                      	    28: #
                      	    29: #   Executes a word shift operation and checks the resulting flags.
                      	    30: #
                      	    31: #   %1 operation
                      	    32: #   %2 ax: word operand
                      	    33: #   %3 cl: shift count
                      	    34: #   %4 flags: value of flags before %1 execution
                      	    35: #   %5 flags: expected value of flags after %1 execution (cmp with PS_ARITH mask)
                      	    36: #
                      	    37: #   Uses: AX, CL, Flags
                      	    38: #
                      	    39: .macro testShiftWFlags arg1,arg2,arg3,arg4,arg5
                      	    40: 	mov \arg4,%ax
                      	    41: 	push %ax
                      	    42: 	popf
                      	    43: 	mov \arg2,%ax
                      	    44: 	mov \arg3,%cl
                      	    45: 	\arg1 %cl,%ax
                      	    46: 	pushf
                      	    47: 	pop %ax
                      	    48: 	and $PS_ARITH,%ax
                      	    49: 	cmp \arg5,%ax
                      	    50: 	jne error
                      	    51: .endm
                      	    52: 

Source: "t386.asm"
                      	   129: 
                      	   130: _start:
04:00000000 EB59      	   131: 	jmp _start1
                      	   132: header:
                      	   133: 	cpyright
04:00000002 743338362E	     1M 	.ascii "t386.asm (c) 2024 Robert Finch (C) 2012-2015 Jeff Parsons, (C) 2017-2021 Marco Bortolin ",0
04:00000007 61736D2028
04:0000000C 6329203230
04:00000011 323420526F
04:00000016 6265727420
04:0000001B 46696E6368
04:00000020 2028432920
04:00000025 323031322D
04:0000002A 3230313520
04:0000002F 4A65666620
04:00000034 506172736F
04:00000039 6E732C2028
04:0000003E 4329203230
04:00000043 31372D3230
04:00000048 3231204D61
04:0000004D 72636F2042
04:00000052 6F72746F6C
04:00000057 696E20
04:0000005A 00
                      	   134: 
                      	   135: _start1:
04:0000005B FA        	   136: 	cli	
                      	   137: # init IDT
                      	   138: #	mov $17,%cx
                      	   139: #	movl $error,%edx
                      	   140: #	movl $0xfff90000,%eax
                      	   141: #	movl $error,%edx
                      	   142: #.aloop:
                      	   143: #	movw %dx,(%eax)
                      	   144: #	movw $0xf000,2(%eax)
                      	   145: ##	movw $error,(,%eax,4)
                      	   146: ##	movw $0xf000,2(,%eax,4)
                      	   147: #	addl $4,%eax
                      	   148: #	loop .aloop
                      	   149: 
                      	   150: #	mov $ESP_REAL,%esp
                      	   151: 
                      	   152: # ==============================================================================
                      	   153: #	Real mode tests
                      	   154: # ==============================================================================
                      	   155: 
                      	   156: .include "real_m.asm"

Source: "real_m.asm"
                      	     1: #
                      	     2: # Advances the base address of data segments used by tests, D1_SEG_REAL and
                      	     3: # D2_SEG_REAL.
                      	     4: #
                      	     5: # Loads DS with D1_SEG_REAL and ES with D2_SEG_REAL.
                      	     6: #
                      	     7: .macro advTestSegReal
                      	     8: 	advTestBase
                      	     9: 	.set D1_SEG_REAL,TEST_BASE1 >> 4
                      	    10: 	.set D2_SEG_REAL,TEST_BASE2 >> 4
                      	    11: 	mov $D1_SEG_REAL,%dx
                      	    12: 	mov %dx,%ds
                      	    13: 	mov $D2_SEG_REAL,%dx
                      	    14: 	mov %dx,%es
                      	    15: .endm
                      	    16: 
                      	    17: #
                      	    18: # Initializes the real mode IDT with C_SEG_REAL:error
                      	    19: # This code is called in real mode.
                      	    20: #
                      	    21: .macro initRealModeIDT
                      	    22: 	mov $IDT_SEG_REAL,%ax
                      	    23: 	mov %ax,%ds
                      	    24: 	xor %di,%di
                      	    25: 	mov $17,%cx
                      	    26: aloop\@:
                      	    27: 	movw $error,(%di)
                      	    28: 	movw $C_SEG_REAL,2(%di)
                      	    29: 	add $4,%di
                      	    30: 	loop aloop\@
                      	    31: .endm
                      	    32: 
                      	    33: 
                      	    34: #
                      	    35: # Exception handling testing in real mode
                      	    36: #
                      	    37: 
                      	    38: # Initialises an exc handler
                      	    39: # %1: vector
                      	    40: # %2: handler IP
                      	    41: # Trashes AX,DS
                      	    42: 
                      	    43: .macro realModeExcInit arg1,arg2
                      	    44: 	mov $IDT_SEG_REAL,%ax
                      	    45: 	mov %ax,%ds
                      	    46: 	movw $\arg2,\arg1*4
                      	    47: 	movw $C_SEG_REAL,\arg1*4+2
                      	    48: .endm
                      	    49: 
                      	    50: # Checks exc result and restores the default handler
                      	    51: # %1: vector
                      	    52: # %2: expected pushed value of IP
                      	    53: # Trashes AX,DS
                      	    54: 
                      	    55: .macro realModeExcCheck arg1,arg2
                      	    56: 	cmp $ESP_REAL-6,%sp
                      	    57: 	jne error
                      	    58: 	cmpw $C_SEG_REAL,%ss:ESP_REAL-4
                      	    59: 	jne error
                      	    60: 	cmpw $\arg2,%ss:ESP_REAL-6
                      	    61: 	jne error
                      	    62: 	mov $0,%ax
                      	    63: 	mov %ax,%ds
                      	    64: 	movw $error,\arg1*4
                      	    65: 	movw $C_SEG_REAL,\arg1*4+2
                      	    66: .endm
                      	    67: 
                      	    68: 
                      	    69: # Tests a fault
                      	    70: # %1: vector
                      	    71: # %2: instruction to execute that causes a fault
                      	    72: 
                      	    73: .macro realModeFaultTest arg1,arg2,arg3
                      	    74: 	realModeExcInit \arg1,continue\@
                      	    75: 	mov $S_SEG_REAL,%ax
                      	    76: 	mov %ax,%ss
                      	    77: 	mov $ESP_REAL,%sp
                      	    78: test\@:
                      	    79: 	\arg2,%\arg3
                      	    80: 	jmp error
                      	    81: continue\@:
                      	    82: 	realModeExcCheck \arg1,test\@
                      	    83: .endm
                      	    84: 

Source: "t386.asm"
                      	   157: #-------------------------------------------------------------------------------
                      	   158: 	POST $0x00
04:0000005C B000      	     1M 	movb $0x00,%al
04:0000005E BA9001    	     2M 	movw $POST_PORT,%dx
04:00000061 EE        	     3M 	out %al,%dx
                      	   159: #-------------------------------------------------------------------------------
                      	   160: #
                      	   161: #   Real mode initialization
                      	   162: #
04:00000062 B800A0    	   163: 	mov $rodata_seg & realmd_mask,%ax
04:00000065 8ED8      	   164: 	mov %ax,%ds
04:00000067 0F011E0000	   165: 	lidt idt_addr-start_rodata
                      	   166: 	initRealModeIDT
04:0000006C B80090    	     1M 	mov $IDT_SEG_REAL,%ax
04:0000006F 8ED8      	     2M 	mov %ax,%ds
04:00000071 31FF      	     3M 	xor %di,%di
04:00000073 B91100    	     4M 	mov $17,%cx
                      	     5M aloop7:
04:00000076 C705AF24  	     6M 	movw $error,(%di)
04:0000007A C7450200F0	     7M 	movw $C_SEG_REAL,2(%di)
04:0000007F 83C704    	     8M 	add $4,%di
04:00000082 E2F2      	     9M 	loop aloop7
04:00000084 B800C0    	   167: 	mov $S_SEG_REAL,%ax
04:00000087 8ED0      	   168: 	mov %ax,%ss
04:00000089 BCFC7F    	   169: 	mov $ESP_REAL,%sp
04:0000008C C7C200C0  	   170: 	mov $D1_SEG_REAL,%dx
04:00000090 8EDA      	   171: 	mov %dx,%ds
04:00000092 C7C200C2  	   172: 	mov $D2_SEG_REAL,%dx
04:00000096 8EC2      	   173: 	mov %dx,%es
                      	   174: 
                      	   175: #-------------------------------------------------------------------------------
                      	   176: 	POST $0x01
04:00000098 B001      	     1M 	movb $0x01,%al
04:0000009A BA9001    	     2M 	movw $POST_PORT,%dx
04:0000009D EE        	     3M 	out %al,%dx
                      	   177: #-------------------------------------------------------------------------------
                      	   178: #
                      	   179: #   Conditional jumps
                      	   180: #
                      	   181: .include "jcc_m.asm"

Source: "jcc_m.asm"
                      	     1: #
                      	     2: # Tests conditional relative jumps.
                      	     3: # Uses: AX, ECX, Flags
                      	     4: #
                      	     5: # Opcodes tested, with positive and negative offsets:
                      	     6: #
                      	     7: # rel8  rel16/32 mnemonic condition
                      	     8: # 70    0F80     JO       OF=1
                      	     9: # 71    0F81     JNO      OF=0
                      	    10: # 72    0F82     JC       CF=1
                      	    11: # 73    0F83     JNC      CF=0
                      	    12: # 74    0F84     JZ       ZF=1
                      	    13: # 75    0F85     JNZ      ZF=0
                      	    14: # 76    0F86     JBE      CF=1 || ZF=1
                      	    15: # 77    0F87     JA       CF=0 && ZF=0
                      	    16: # 78    0F88     JS       SF=1
                      	    17: # 79    0F89     JNS      SF=0
                      	    18: # 7A    0F8A     JP       PF=1
                      	    19: # 7B    0F8B     JNP      PF=0
                      	    20: # 7C    0F8C     JL       SF!=OF
                      	    21: # 7D    0F8D     JNL      SF=OF
                      	    22: # 7E    0F8E     JLE      ZF=1 || SF!=OF
                      	    23: # 7F    0F8F     JNLE     ZF=0 && SF=OF
                      	    24: # E3             JCXZ     CX=0
                      	    25: # E3             JECXZ    ECX=0
                      	    26: #
                      	    27: .macro testJcc arg1
                      	    28: 	mov $PS_CF,%ah
                      	    29: 	sahf         # dont use the stack (pushf/popf)
                      	    30: 	jnc err1\@ 	# 73 / 0F83   JNC  CF=0
                      	    31: 	jc jcok\@ 	# 72 / 0F82   JC   CF=1
                      	    32: 	hlt
                      	    33: jz\@:
                      	    34: 	mov $PS_ZF,%ah
                      	    35: 	sahf
                      	    36: 	jnz err1\@ 	# 75 / 0F85   JNZ  ZF=0
                      	    37: 	jz jzok\@ 	# 74 / 0F84   JZ   ZF=1
                      	    38: 	hlt
                      	    39: jp\@:
                      	    40: 	mov $PS_PF,%ah
                      	    41: 	sahf
                      	    42: 	jnp err1\@ 	# 7B / 0F8B   JNP  PF=0
                      	    43: 	jp jpok\@ 	# 7A / 0F8A   JP   PF=1
                      	    44: 	hlt
                      	    45: js\@:
                      	    46: 	mov $PS_SF,%ah
                      	    47: 	sahf
                      	    48: 	jns err1\@ 	# 79 / 0F89   JNS  SF=0
                      	    49: 	js jsok\@ 	# 78 / 0F88   JS   SF=1
                      	    50: 	hlt
                      	    51: jna\@:
                      	    52: 	mov $PS_ZF|PS_CF,%ah
                      	    53: 	sahf
                      	    54: 	ja err1\@  	# 77 / 0F87   JA   CF=0 && ZF=0
                      	    55: 	jna jnaok\@ # 76 / 0F86   JBE  CF=1 || ZF=1
                      	    56: next1\@:
                      	    57: 	jmp jnc\@
                      	    58: 
                      	    59: .if \arg1==16
                      	    60: 	.rept 128
                      	    61: 		hlt
                      	    62: 	.endr
                      	    63: .endif
                      	    64: 
                      	    65: err1\@:
                      	    66: 	hlt
                      	    67: 
                      	    68: # test negative offsets
                      	    69: jcok\@:   jc   jz\@
                      	    70: jzok\@:   jz   jp\@
                      	    71: jpok\@:   jp   js\@
                      	    72: jsok\@:   js   jna\@
                      	    73: jnaok\@:  jna  next1\@
                      	    74: 
                      	    75: 
                      	    76: jnc\@:
                      	    77: 	mov $PS_SF|PS_ZF|PS_AF|PS_PF,%ah
                      	    78: 	sahf
                      	    79: 	mov $0,%ax
                      	    80: 	sahf
                      	    81: 	jnc   jncok\@ # 73 / 0F83   JNC  CF=0
                      	    82: 	hlt
                      	    83: jnz\@:
                      	    84: 	mov $PS_SF|PS_AF|PS_PF|PS_CF,%ah
                      	    85: 	sahf
                      	    86: 	jnz   jnzok\@ # 75 / 0F85   JNZ  ZF=0
                      	    87: 	hlt
                      	    88: jnp\@:
                      	    89: 	mov $PS_SF|PS_ZF|PS_AF|PS_CF,%ah
                      	    90: 	sahf
                      	    91: 	jnp   jnpok\@ # 7B / 0F8B   JNP  PF=0
                      	    92: 	hlt
                      	    93: jns\@:
                      	    94: 	mov $PS_ZF|PS_AF|PS_PF|PS_CF,%ah
                      	    95: 	sahf
                      	    96: 	jns jnsok\@ # 79 /  0F89  JNS  SF=0
                      	    97: 	hlt
                      	    98: ja\@:
                      	    99: 	mov $PS_SF|PS_AF|PS_PF,%ah
                      	   100: 	sahf
                      	   101: 	ja    jaok\@  # 77 / 0F87   JA   CF=0 && ZF=0
                      	   102: 	hlt
                      	   103: next2\@:
                      	   104: 	jmp   jo\@
                      	   105: 
                      	   106: .if \arg1==16
                      	   107: 	.rept 128
                      	   108: 		hlt
                      	   109: 	.endr
                      	   110: .endif
                      	   111: 
                      	   112: # test negative offsets
                      	   113: jncok\@:  jnc  jnz\@
                      	   114: jnzok\@:  jnz  jnp\@
                      	   115: jnpok\@:  jnp  jns\@
                      	   116: jnsok\@:  jns  ja\@
                      	   117: jaok\@:   ja   next2\@
                      	   118: 
                      	   119: jo\@:
                      	   120: 	mov $0,%ah
                      	   121: 	sahf
                      	   122: 	mov $0b1000000,%al
                      	   123: 	shl $1,%al   	# OF = high-order bit of AL <> (CF), ZF=0,SF=1,OF=1
                      	   124: 	jno err2\@
                      	   125: 	jo jook\@
                      	   126: 	hlt
                      	   127: jnl\@:
                      	   128: 	jl err2\@   	# 7C / 0F8C   JL   SF!=OF
                      	   129: 	jnl jnlok\@  	# 7D / 0F8D   JNL  SF=OF
                      	   130: 	hlt
                      	   131: jnle\@:
                      	   132: 	jle err2\@   	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
                      	   133: 	jnle jnleok\@ # 7F / 0F8F   JNLE ZF=0 && SF=OF
                      	   134: 	hlt
                      	   135: jl\@:
                      	   136: 	mov $PS_ZF,%ah
                      	   137: 	sahf          # ZF=1,SF=0,OF=1
                      	   138: 	jl jlok\@   	# 7C / 0F8C   JL   SF!=OF
                      	   139: 	hlt
                      	   140: jle\@:
                      	   141: 	jle jleok\@  	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
                      	   142: 	hlt
                      	   143: jcxz\@:
                      	   144: .if \arg1==8
                      	   145: 	mov $1,%ecx
                      	   146: 	jcxz err2\@      	# E3   JCXZ  CX=0
                      	   147: 	mov $0x10000,%ecx
                      	   148: 	jcxz jcxzok\@
                      	   149: jecxz\@:
                      	   150: 	jecxz err2\@
                      	   151: 	mov $0,%ecx
                      	   152: 	jecxz jecxzok\@ 	# E3   JECXZ   ECX=0
                      	   153: jecxze\@:
                      	   154: .endif
                      	   155: 	jmp exit\@
                      	   156: 
                      	   157: .if \arg1==16
                      	   158: 	.rept 128
                      	   159: 		hlt
                      	   160: 	.endr
                      	   161: .endif
                      	   162: 
                      	   163: err2\@:
                      	   164: 	hlt
                      	   165: 
                      	   166: # test negative offsets
                      	   167: jook\@:   jo   jnl\@
                      	   168: jnlok\@:  jnl  jnle\@
                      	   169: jnleok\@: jnle jl\@
                      	   170: jlok\@:   jl   jle\@
                      	   171: jleok\@:  jle  jcxz\@
                      	   172: .if \arg1==8
                      	   173: jcxzok\@:  jcxz  jecxz\@
                      	   174: jecxzok\@: jecxz jecxze\@
                      	   175: .endif
                      	   176: 
                      	   177: exit\@:
                      	   178: .endm
                      	   179: 

Source: "t386.asm"
                      	   182: 	testJcc 8
04:0000009E B401      	     1M 	mov $PS_CF,%ah
04:000000A0 9E        	     2M 	sahf         # dont use the stack (pushf/popf)
04:000000A1 7324      	     3M 	jnc err110 	# 73 / 0F83   JNC  CF=0
04:000000A3 7223      	     4M 	jc jcok10 	# 72 / 0F82   JC   CF=1
04:000000A5 F4        	     5M 	hlt
                      	     6M jz10:
04:000000A6 B440      	     7M 	mov $PS_ZF,%ah
04:000000A8 9E        	     8M 	sahf
04:000000A9 751C      	     9M 	jnz err110 	# 75 / 0F85   JNZ  ZF=0
04:000000AB 741D      	    10M 	jz jzok10 	# 74 / 0F84   JZ   ZF=1
04:000000AD F4        	    11M 	hlt
                      	    12M jp10:
04:000000AE B404      	    13M 	mov $PS_PF,%ah
04:000000B0 9E        	    14M 	sahf
04:000000B1 7B14      	    15M 	jnp err110 	# 7B / 0F8B   JNP  PF=0
04:000000B3 7A17      	    16M 	jp jpok10 	# 7A / 0F8A   JP   PF=1
04:000000B5 F4        	    17M 	hlt
                      	    18M js10:
04:000000B6 B480      	    19M 	mov $PS_SF,%ah
04:000000B8 9E        	    20M 	sahf
04:000000B9 790C      	    21M 	jns err110 	# 79 / 0F89   JNS  SF=0
04:000000BB 7811      	    22M 	js jsok10 	# 78 / 0F88   JS   SF=1
04:000000BD F4        	    23M 	hlt
                      	    24M jna10:
04:000000BE B441      	    25M 	mov $PS_ZF|PS_CF,%ah
04:000000C0 9E        	    26M 	sahf
04:000000C1 7704      	    27M 	ja err110  	# 77 / 0F87   JA   CF=0 && ZF=0
04:000000C3 760B      	    28M 	jna jnaok10 # 76 / 0F86   JBE  CF=1 || ZF=1
                      	    29M next110:
04:000000C5 EB0B      	    30M 	jmp jnc10
                      	    31M 
                      	    32M .if 8==16
                      	    33M 	.rept 128
                      	    34M 		hlt
                      	    35M 	.endr
                      	    36M .endif
                      	    37M 
                      	    38M err110:
04:000000C7 F4        	    39M 	hlt
                      	    40M 
                      	    41M # test negative offsets
04:000000C8 72DC      	    42M jcok10:   jc   jz10
04:000000CA 74E2      	    43M jzok10:   jz   jp10
04:000000CC 7AE8      	    44M jpok10:   jp   js10
04:000000CE 78EE      	    45M jsok10:   js   jna10
04:000000D0 76F3      	    46M jnaok10:  jna  next110
                      	    47M 
                      	    48M 
                      	    49M jnc10:
04:000000D2 B4D4      	    50M 	mov $PS_SF|PS_ZF|PS_AF|PS_PF,%ah
04:000000D4 9E        	    51M 	sahf
04:000000D5 B80000    	    52M 	mov $0,%ax
04:000000D8 9E        	    53M 	sahf
04:000000D9 731B      	    54M 	jnc   jncok10 # 73 / 0F83   JNC  CF=0
04:000000DB F4        	    55M 	hlt
                      	    56M jnz10:
04:000000DC B495      	    57M 	mov $PS_SF|PS_AF|PS_PF|PS_CF,%ah
04:000000DE 9E        	    58M 	sahf
04:000000DF 7517      	    59M 	jnz   jnzok10 # 75 / 0F85   JNZ  ZF=0
04:000000E1 F4        	    60M 	hlt
                      	    61M jnp10:
04:000000E2 B4D1      	    62M 	mov $PS_SF|PS_ZF|PS_AF|PS_CF,%ah
04:000000E4 9E        	    63M 	sahf
04:000000E5 7B13      	    64M 	jnp   jnpok10 # 7B / 0F8B   JNP  PF=0
04:000000E7 F4        	    65M 	hlt
                      	    66M jns10:
04:000000E8 B455      	    67M 	mov $PS_ZF|PS_AF|PS_PF|PS_CF,%ah
04:000000EA 9E        	    68M 	sahf
04:000000EB 790F      	    69M 	jns jnsok10 # 79 /  0F89  JNS  SF=0
04:000000ED F4        	    70M 	hlt
                      	    71M ja10:
04:000000EE B494      	    72M 	mov $PS_SF|PS_AF|PS_PF,%ah
04:000000F0 9E        	    73M 	sahf
04:000000F1 770B      	    74M 	ja    jaok10  # 77 / 0F87   JA   CF=0 && ZF=0
04:000000F3 F4        	    75M 	hlt
                      	    76M next210:
04:000000F4 EB0A      	    77M 	jmp   jo10
                      	    78M 
                      	    79M .if 8==16
                      	    80M 	.rept 128
                      	    81M 		hlt
                      	    82M 	.endr
                      	    83M .endif
                      	    84M 
                      	    85M # test negative offsets
04:000000F6 73E4      	    86M jncok10:  jnc  jnz10
04:000000F8 75E8      	    87M jnzok10:  jnz  jnp10
04:000000FA 7BEC      	    88M jnpok10:  jnp  jns10
04:000000FC 79F0      	    89M jnsok10:  jns  ja10
04:000000FE 77F4      	    90M jaok10:   ja   next210
                      	    91M 
                      	    92M jo10:
04:00000100 B400      	    93M 	mov $0,%ah
04:00000102 9E        	    94M 	sahf
04:00000103 B040      	    95M 	mov $0b1000000,%al
04:00000105 C0E001    	    96M 	shl $1,%al   	# OF = high-order bit of AL <> (CF), ZF=0,SF=1,OF=1
04:00000108 7132      	    97M 	jno err210
04:0000010A 7031      	    98M 	jo jook10
04:0000010C F4        	    99M 	hlt
                      	   100M jnl10:
04:0000010D 7C2D      	   101M 	jl err210   	# 7C / 0F8C   JL   SF!=OF
04:0000010F 7D2E      	   102M 	jnl jnlok10  	# 7D / 0F8D   JNL  SF=OF
04:00000111 F4        	   103M 	hlt
                      	   104M jnle10:
04:00000112 7E28      	   105M 	jle err210   	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
04:00000114 7F2B      	   106M 	jnle jnleok10 # 7F / 0F8F   JNLE ZF=0 && SF=OF
04:00000116 F4        	   107M 	hlt
                      	   108M jl10:
04:00000117 B440      	   109M 	mov $PS_ZF,%ah
04:00000119 9E        	   110M 	sahf          # ZF=1,SF=0,OF=1
04:0000011A 7C27      	   111M 	jl jlok10   	# 7C / 0F8C   JL   SF!=OF
04:0000011C F4        	   112M 	hlt
                      	   113M jle10:
04:0000011D 7E26      	   114M 	jle jleok10  	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
04:0000011F F4        	   115M 	hlt
                      	   116M jcxz10:
                      	   117M .if 8==8
04:00000120 66B9010000	   118M 	mov $1,%ecx
04:00000125 00
04:00000126 E314      	   119M 	jcxz err210      	# E3   JCXZ  CX=0
04:00000128 66B9000001	   120M 	mov $0x10000,%ecx
04:0000012D 00
04:0000012E E317      	   121M 	jcxz jcxzok10
                      	   122M jecxz10:
04:00000130 E30A      	   123M 	jecxz err210
04:00000132 66B9000000	   124M 	mov $0,%ecx
04:00000137 00
04:00000138 E30F      	   125M 	jecxz jecxzok10 	# E3   JECXZ   ECX=0
                      	   126M jecxze10:
                      	   127M .endif
04:0000013A EB0F      	   128M 	jmp exit10
                      	   129M 
                      	   130M .if 8==16
                      	   131M 	.rept 128
                      	   132M 		hlt
                      	   133M 	.endr
                      	   134M .endif
                      	   135M 
                      	   136M err210:
04:0000013C F4        	   137M 	hlt
                      	   138M 
                      	   139M # test negative offsets
04:0000013D 70CE      	   140M jook10:   jo   jnl10
04:0000013F 7DD1      	   141M jnlok10:  jnl  jnle10
04:00000141 7FD4      	   142M jnleok10: jnle jl10
04:00000143 7CD8      	   143M jlok10:   jl   jle10
04:00000145 7ED9      	   144M jleok10:  jle  jcxz10
                      	   145M .if 8==8
04:00000147 E3E7      	   146M jcxzok10:  jcxz  jecxz10
04:00000149 E3EF      	   147M jecxzok10: jecxz jecxze10
                      	   148M .endif
                      	   149M 
                      	   150M exit10:
                      	   183: 	testJcc 16
04:0000014B B401      	     1M 	mov $PS_CF,%ah
04:0000014D 9E        	     2M 	sahf         # dont use the stack (pushf/popf)
04:0000014E 0F83B700  	     3M 	jnc err111 	# 73 / 0F83   JNC  CF=0
04:00000152 0F82B400  	     4M 	jc jcok11 	# 72 / 0F82   JC   CF=1
04:00000156 F4        	     5M 	hlt
                      	     6M jz11:
04:00000157 B440      	     7M 	mov $PS_ZF,%ah
04:00000159 9E        	     8M 	sahf
04:0000015A 0F85AB00  	     9M 	jnz err111 	# 75 / 0F85   JNZ  ZF=0
04:0000015E 0F84AC00  	    10M 	jz jzok11 	# 74 / 0F84   JZ   ZF=1
04:00000162 F4        	    11M 	hlt
                      	    12M jp11:
04:00000163 B404      	    13M 	mov $PS_PF,%ah
04:00000165 9E        	    14M 	sahf
04:00000166 0F8B9F00  	    15M 	jnp err111 	# 7B / 0F8B   JNP  PF=0
04:0000016A 0F8AA400  	    16M 	jp jpok11 	# 7A / 0F8A   JP   PF=1
04:0000016E F4        	    17M 	hlt
                      	    18M js11:
04:0000016F B480      	    19M 	mov $PS_SF,%ah
04:00000171 9E        	    20M 	sahf
04:00000172 0F899300  	    21M 	jns err111 	# 79 / 0F89   JNS  SF=0
04:00000176 0F889C00  	    22M 	js jsok11 	# 78 / 0F88   JS   SF=1
04:0000017A F4        	    23M 	hlt
                      	    24M jna11:
04:0000017B B441      	    25M 	mov $PS_ZF|PS_CF,%ah
04:0000017D 9E        	    26M 	sahf
04:0000017E 0F878700  	    27M 	ja err111  	# 77 / 0F87   JA   CF=0 && ZF=0
04:00000182 0F869400  	    28M 	jna jnaok11 # 76 / 0F86   JBE  CF=1 || ZF=1
                      	    29M next111:
04:00000186 E99500    	    30M 	jmp jnc11
                      	    31M 
                      	    32M .if 16==16
                      	    33M 	.rept 128
                      	    34M 		hlt
                      	    35M 	.endr
04:00000189 F4        	     1M 		hlt
                      	     2M 	
04:0000018A F4        	     1M 		hlt
                      	     2M 	
04:0000018B F4        	     1M 		hlt
                      	     2M 	
04:0000018C F4        	     1M 		hlt
                      	     2M 	
04:0000018D F4        	     1M 		hlt
                      	     2M 	
04:0000018E F4        	     1M 		hlt
                      	     2M 	
04:0000018F F4        	     1M 		hlt
                      	     2M 	
04:00000190 F4        	     1M 		hlt
                      	     2M 	
04:00000191 F4        	     1M 		hlt
                      	     2M 	
04:00000192 F4        	     1M 		hlt
                      	     2M 	
04:00000193 F4        	     1M 		hlt
                      	     2M 	
04:00000194 F4        	     1M 		hlt
                      	     2M 	
04:00000195 F4        	     1M 		hlt
                      	     2M 	
04:00000196 F4        	     1M 		hlt
                      	     2M 	
04:00000197 F4        	     1M 		hlt
                      	     2M 	
04:00000198 F4        	     1M 		hlt
                      	     2M 	
04:00000199 F4        	     1M 		hlt
                      	     2M 	
04:0000019A F4        	     1M 		hlt
                      	     2M 	
04:0000019B F4        	     1M 		hlt
                      	     2M 	
04:0000019C F4        	     1M 		hlt
                      	     2M 	
04:0000019D F4        	     1M 		hlt
                      	     2M 	
04:0000019E F4        	     1M 		hlt
                      	     2M 	
04:0000019F F4        	     1M 		hlt
                      	     2M 	
04:000001A0 F4        	     1M 		hlt
                      	     2M 	
04:000001A1 F4        	     1M 		hlt
                      	     2M 	
04:000001A2 F4        	     1M 		hlt
                      	     2M 	
04:000001A3 F4        	     1M 		hlt
                      	     2M 	
04:000001A4 F4        	     1M 		hlt
                      	     2M 	
04:000001A5 F4        	     1M 		hlt
                      	     2M 	
04:000001A6 F4        	     1M 		hlt
                      	     2M 	
04:000001A7 F4        	     1M 		hlt
                      	     2M 	
04:000001A8 F4        	     1M 		hlt
                      	     2M 	
04:000001A9 F4        	     1M 		hlt
                      	     2M 	
04:000001AA F4        	     1M 		hlt
                      	     2M 	
04:000001AB F4        	     1M 		hlt
                      	     2M 	
04:000001AC F4        	     1M 		hlt
                      	     2M 	
04:000001AD F4        	     1M 		hlt
                      	     2M 	
04:000001AE F4        	     1M 		hlt
                      	     2M 	
04:000001AF F4        	     1M 		hlt
                      	     2M 	
04:000001B0 F4        	     1M 		hlt
                      	     2M 	
04:000001B1 F4        	     1M 		hlt
                      	     2M 	
04:000001B2 F4        	     1M 		hlt
                      	     2M 	
04:000001B3 F4        	     1M 		hlt
                      	     2M 	
04:000001B4 F4        	     1M 		hlt
                      	     2M 	
04:000001B5 F4        	     1M 		hlt
                      	     2M 	
04:000001B6 F4        	     1M 		hlt
                      	     2M 	
04:000001B7 F4        	     1M 		hlt
                      	     2M 	
04:000001B8 F4        	     1M 		hlt
                      	     2M 	
04:000001B9 F4        	     1M 		hlt
                      	     2M 	
04:000001BA F4        	     1M 		hlt
                      	     2M 	
04:000001BB F4        	     1M 		hlt
                      	     2M 	
04:000001BC F4        	     1M 		hlt
                      	     2M 	
04:000001BD F4        	     1M 		hlt
                      	     2M 	
04:000001BE F4        	     1M 		hlt
                      	     2M 	
04:000001BF F4        	     1M 		hlt
                      	     2M 	
04:000001C0 F4        	     1M 		hlt
                      	     2M 	
04:000001C1 F4        	     1M 		hlt
                      	     2M 	
04:000001C2 F4        	     1M 		hlt
                      	     2M 	
04:000001C3 F4        	     1M 		hlt
                      	     2M 	
04:000001C4 F4        	     1M 		hlt
                      	     2M 	
04:000001C5 F4        	     1M 		hlt
                      	     2M 	
04:000001C6 F4        	     1M 		hlt
                      	     2M 	
04:000001C7 F4        	     1M 		hlt
                      	     2M 	
04:000001C8 F4        	     1M 		hlt
                      	     2M 	
04:000001C9 F4        	     1M 		hlt
                      	     2M 	
04:000001CA F4        	     1M 		hlt
                      	     2M 	
04:000001CB F4        	     1M 		hlt
                      	     2M 	
04:000001CC F4        	     1M 		hlt
                      	     2M 	
04:000001CD F4        	     1M 		hlt
                      	     2M 	
04:000001CE F4        	     1M 		hlt
                      	     2M 	
04:000001CF F4        	     1M 		hlt
                      	     2M 	
04:000001D0 F4        	     1M 		hlt
                      	     2M 	
04:000001D1 F4        	     1M 		hlt
                      	     2M 	
04:000001D2 F4        	     1M 		hlt
                      	     2M 	
04:000001D3 F4        	     1M 		hlt
                      	     2M 	
04:000001D4 F4        	     1M 		hlt
                      	     2M 	
04:000001D5 F4        	     1M 		hlt
                      	     2M 	
04:000001D6 F4        	     1M 		hlt
                      	     2M 	
04:000001D7 F4        	     1M 		hlt
                      	     2M 	
04:000001D8 F4        	     1M 		hlt
                      	     2M 	
04:000001D9 F4        	     1M 		hlt
                      	     2M 	
04:000001DA F4        	     1M 		hlt
                      	     2M 	
04:000001DB F4        	     1M 		hlt
                      	     2M 	
04:000001DC F4        	     1M 		hlt
                      	     2M 	
04:000001DD F4        	     1M 		hlt
                      	     2M 	
04:000001DE F4        	     1M 		hlt
                      	     2M 	
04:000001DF F4        	     1M 		hlt
                      	     2M 	
04:000001E0 F4        	     1M 		hlt
                      	     2M 	
04:000001E1 F4        	     1M 		hlt
                      	     2M 	
04:000001E2 F4        	     1M 		hlt
                      	     2M 	
04:000001E3 F4        	     1M 		hlt
                      	     2M 	
04:000001E4 F4        	     1M 		hlt
                      	     2M 	
04:000001E5 F4        	     1M 		hlt
                      	     2M 	
04:000001E6 F4        	     1M 		hlt
                      	     2M 	
04:000001E7 F4        	     1M 		hlt
                      	     2M 	
04:000001E8 F4        	     1M 		hlt
                      	     2M 	
04:000001E9 F4        	     1M 		hlt
                      	     2M 	
04:000001EA F4        	     1M 		hlt
                      	     2M 	
04:000001EB F4        	     1M 		hlt
                      	     2M 	
04:000001EC F4        	     1M 		hlt
                      	     2M 	
04:000001ED F4        	     1M 		hlt
                      	     2M 	
04:000001EE F4        	     1M 		hlt
                      	     2M 	
04:000001EF F4        	     1M 		hlt
                      	     2M 	
04:000001F0 F4        	     1M 		hlt
                      	     2M 	
04:000001F1 F4        	     1M 		hlt
                      	     2M 	
04:000001F2 F4        	     1M 		hlt
                      	     2M 	
04:000001F3 F4        	     1M 		hlt
                      	     2M 	
04:000001F4 F4        	     1M 		hlt
                      	     2M 	
04:000001F5 F4        	     1M 		hlt
                      	     2M 	
04:000001F6 F4        	     1M 		hlt
                      	     2M 	
04:000001F7 F4        	     1M 		hlt
                      	     2M 	
04:000001F8 F4        	     1M 		hlt
                      	     2M 	
04:000001F9 F4        	     1M 		hlt
                      	     2M 	
04:000001FA F4        	     1M 		hlt
                      	     2M 	
04:000001FB F4        	     1M 		hlt
                      	     2M 	
04:000001FC F4        	     1M 		hlt
                      	     2M 	
04:000001FD F4        	     1M 		hlt
                      	     2M 	
04:000001FE F4        	     1M 		hlt
                      	     2M 	
04:000001FF F4        	     1M 		hlt
                      	     2M 	
04:00000200 F4        	     1M 		hlt
                      	     2M 	
04:00000201 F4        	     1M 		hlt
                      	     2M 	
04:00000202 F4        	     1M 		hlt
                      	     2M 	
04:00000203 F4        	     1M 		hlt
                      	     2M 	
04:00000204 F4        	     1M 		hlt
                      	     2M 	
04:00000205 F4        	     1M 		hlt
                      	     2M 	
04:00000206 F4        	     1M 		hlt
                      	     2M 	
04:00000207 F4        	     1M 		hlt
                      	     2M 	
04:00000208 F4        	     1M 		hlt
                      	     2M 	
                      	    36M .endif
                      	    37M 
                      	    38M err111:
04:00000209 F4        	    39M 	hlt
                      	    40M 
                      	    41M # test negative offsets
04:0000020A 0F8249FF  	    42M jcok11:   jc   jz11
04:0000020E 0F8451FF  	    43M jzok11:   jz   jp11
04:00000212 0F8A59FF  	    44M jpok11:   jp   js11
04:00000216 0F8861FF  	    45M jsok11:   js   jna11
04:0000021A 0F8668FF  	    46M jnaok11:  jna  next111
                      	    47M 
                      	    48M 
                      	    49M jnc11:
04:0000021E B4D4      	    50M 	mov $PS_SF|PS_ZF|PS_AF|PS_PF,%ah
04:00000220 9E        	    51M 	sahf
04:00000221 B80000    	    52M 	mov $0,%ax
04:00000224 9E        	    53M 	sahf
04:00000225 0F83A400  	    54M 	jnc   jncok11 # 73 / 0F83   JNC  CF=0
04:00000229 F4        	    55M 	hlt
                      	    56M jnz11:
04:0000022A B495      	    57M 	mov $PS_SF|PS_AF|PS_PF|PS_CF,%ah
04:0000022C 9E        	    58M 	sahf
04:0000022D 0F85A000  	    59M 	jnz   jnzok11 # 75 / 0F85   JNZ  ZF=0
04:00000231 F4        	    60M 	hlt
                      	    61M jnp11:
04:00000232 B4D1      	    62M 	mov $PS_SF|PS_ZF|PS_AF|PS_CF,%ah
04:00000234 9E        	    63M 	sahf
04:00000235 0F8B9C00  	    64M 	jnp   jnpok11 # 7B / 0F8B   JNP  PF=0
04:00000239 F4        	    65M 	hlt
                      	    66M jns11:
04:0000023A B455      	    67M 	mov $PS_ZF|PS_AF|PS_PF|PS_CF,%ah
04:0000023C 9E        	    68M 	sahf
04:0000023D 0F899800  	    69M 	jns jnsok11 # 79 /  0F89  JNS  SF=0
04:00000241 F4        	    70M 	hlt
                      	    71M ja11:
04:00000242 B494      	    72M 	mov $PS_SF|PS_AF|PS_PF,%ah
04:00000244 9E        	    73M 	sahf
04:00000245 0F879400  	    74M 	ja    jaok11  # 77 / 0F87   JA   CF=0 && ZF=0
04:00000249 F4        	    75M 	hlt
                      	    76M next211:
04:0000024A E99400    	    77M 	jmp   jo11
                      	    78M 
                      	    79M .if 16==16
                      	    80M 	.rept 128
                      	    81M 		hlt
                      	    82M 	.endr
04:0000024D F4        	     1M 		hlt
                      	     2M 	
04:0000024E F4        	     1M 		hlt
                      	     2M 	
04:0000024F F4        	     1M 		hlt
                      	     2M 	
04:00000250 F4        	     1M 		hlt
                      	     2M 	
04:00000251 F4        	     1M 		hlt
                      	     2M 	
04:00000252 F4        	     1M 		hlt
                      	     2M 	
04:00000253 F4        	     1M 		hlt
                      	     2M 	
04:00000254 F4        	     1M 		hlt
                      	     2M 	
04:00000255 F4        	     1M 		hlt
                      	     2M 	
04:00000256 F4        	     1M 		hlt
                      	     2M 	
04:00000257 F4        	     1M 		hlt
                      	     2M 	
04:00000258 F4        	     1M 		hlt
                      	     2M 	
04:00000259 F4        	     1M 		hlt
                      	     2M 	
04:0000025A F4        	     1M 		hlt
                      	     2M 	
04:0000025B F4        	     1M 		hlt
                      	     2M 	
04:0000025C F4        	     1M 		hlt
                      	     2M 	
04:0000025D F4        	     1M 		hlt
                      	     2M 	
04:0000025E F4        	     1M 		hlt
                      	     2M 	
04:0000025F F4        	     1M 		hlt
                      	     2M 	
04:00000260 F4        	     1M 		hlt
                      	     2M 	
04:00000261 F4        	     1M 		hlt
                      	     2M 	
04:00000262 F4        	     1M 		hlt
                      	     2M 	
04:00000263 F4        	     1M 		hlt
                      	     2M 	
04:00000264 F4        	     1M 		hlt
                      	     2M 	
04:00000265 F4        	     1M 		hlt
                      	     2M 	
04:00000266 F4        	     1M 		hlt
                      	     2M 	
04:00000267 F4        	     1M 		hlt
                      	     2M 	
04:00000268 F4        	     1M 		hlt
                      	     2M 	
04:00000269 F4        	     1M 		hlt
                      	     2M 	
04:0000026A F4        	     1M 		hlt
                      	     2M 	
04:0000026B F4        	     1M 		hlt
                      	     2M 	
04:0000026C F4        	     1M 		hlt
                      	     2M 	
04:0000026D F4        	     1M 		hlt
                      	     2M 	
04:0000026E F4        	     1M 		hlt
                      	     2M 	
04:0000026F F4        	     1M 		hlt
                      	     2M 	
04:00000270 F4        	     1M 		hlt
                      	     2M 	
04:00000271 F4        	     1M 		hlt
                      	     2M 	
04:00000272 F4        	     1M 		hlt
                      	     2M 	
04:00000273 F4        	     1M 		hlt
                      	     2M 	
04:00000274 F4        	     1M 		hlt
                      	     2M 	
04:00000275 F4        	     1M 		hlt
                      	     2M 	
04:00000276 F4        	     1M 		hlt
                      	     2M 	
04:00000277 F4        	     1M 		hlt
                      	     2M 	
04:00000278 F4        	     1M 		hlt
                      	     2M 	
04:00000279 F4        	     1M 		hlt
                      	     2M 	
04:0000027A F4        	     1M 		hlt
                      	     2M 	
04:0000027B F4        	     1M 		hlt
                      	     2M 	
04:0000027C F4        	     1M 		hlt
                      	     2M 	
04:0000027D F4        	     1M 		hlt
                      	     2M 	
04:0000027E F4        	     1M 		hlt
                      	     2M 	
04:0000027F F4        	     1M 		hlt
                      	     2M 	
04:00000280 F4        	     1M 		hlt
                      	     2M 	
04:00000281 F4        	     1M 		hlt
                      	     2M 	
04:00000282 F4        	     1M 		hlt
                      	     2M 	
04:00000283 F4        	     1M 		hlt
                      	     2M 	
04:00000284 F4        	     1M 		hlt
                      	     2M 	
04:00000285 F4        	     1M 		hlt
                      	     2M 	
04:00000286 F4        	     1M 		hlt
                      	     2M 	
04:00000287 F4        	     1M 		hlt
                      	     2M 	
04:00000288 F4        	     1M 		hlt
                      	     2M 	
04:00000289 F4        	     1M 		hlt
                      	     2M 	
04:0000028A F4        	     1M 		hlt
                      	     2M 	
04:0000028B F4        	     1M 		hlt
                      	     2M 	
04:0000028C F4        	     1M 		hlt
                      	     2M 	
04:0000028D F4        	     1M 		hlt
                      	     2M 	
04:0000028E F4        	     1M 		hlt
                      	     2M 	
04:0000028F F4        	     1M 		hlt
                      	     2M 	
04:00000290 F4        	     1M 		hlt
                      	     2M 	
04:00000291 F4        	     1M 		hlt
                      	     2M 	
04:00000292 F4        	     1M 		hlt
                      	     2M 	
04:00000293 F4        	     1M 		hlt
                      	     2M 	
04:00000294 F4        	     1M 		hlt
                      	     2M 	
04:00000295 F4        	     1M 		hlt
                      	     2M 	
04:00000296 F4        	     1M 		hlt
                      	     2M 	
04:00000297 F4        	     1M 		hlt
                      	     2M 	
04:00000298 F4        	     1M 		hlt
                      	     2M 	
04:00000299 F4        	     1M 		hlt
                      	     2M 	
04:0000029A F4        	     1M 		hlt
                      	     2M 	
04:0000029B F4        	     1M 		hlt
                      	     2M 	
04:0000029C F4        	     1M 		hlt
                      	     2M 	
04:0000029D F4        	     1M 		hlt
                      	     2M 	
04:0000029E F4        	     1M 		hlt
                      	     2M 	
04:0000029F F4        	     1M 		hlt
                      	     2M 	
04:000002A0 F4        	     1M 		hlt
                      	     2M 	
04:000002A1 F4        	     1M 		hlt
                      	     2M 	
04:000002A2 F4        	     1M 		hlt
                      	     2M 	
04:000002A3 F4        	     1M 		hlt
                      	     2M 	
04:000002A4 F4        	     1M 		hlt
                      	     2M 	
04:000002A5 F4        	     1M 		hlt
                      	     2M 	
04:000002A6 F4        	     1M 		hlt
                      	     2M 	
04:000002A7 F4        	     1M 		hlt
                      	     2M 	
04:000002A8 F4        	     1M 		hlt
                      	     2M 	
04:000002A9 F4        	     1M 		hlt
                      	     2M 	
04:000002AA F4        	     1M 		hlt
                      	     2M 	
04:000002AB F4        	     1M 		hlt
                      	     2M 	
04:000002AC F4        	     1M 		hlt
                      	     2M 	
04:000002AD F4        	     1M 		hlt
                      	     2M 	
04:000002AE F4        	     1M 		hlt
                      	     2M 	
04:000002AF F4        	     1M 		hlt
                      	     2M 	
04:000002B0 F4        	     1M 		hlt
                      	     2M 	
04:000002B1 F4        	     1M 		hlt
                      	     2M 	
04:000002B2 F4        	     1M 		hlt
                      	     2M 	
04:000002B3 F4        	     1M 		hlt
                      	     2M 	
04:000002B4 F4        	     1M 		hlt
                      	     2M 	
04:000002B5 F4        	     1M 		hlt
                      	     2M 	
04:000002B6 F4        	     1M 		hlt
                      	     2M 	
04:000002B7 F4        	     1M 		hlt
                      	     2M 	
04:000002B8 F4        	     1M 		hlt
                      	     2M 	
04:000002B9 F4        	     1M 		hlt
                      	     2M 	
04:000002BA F4        	     1M 		hlt
                      	     2M 	
04:000002BB F4        	     1M 		hlt
                      	     2M 	
04:000002BC F4        	     1M 		hlt
                      	     2M 	
04:000002BD F4        	     1M 		hlt
                      	     2M 	
04:000002BE F4        	     1M 		hlt
                      	     2M 	
04:000002BF F4        	     1M 		hlt
                      	     2M 	
04:000002C0 F4        	     1M 		hlt
                      	     2M 	
04:000002C1 F4        	     1M 		hlt
                      	     2M 	
04:000002C2 F4        	     1M 		hlt
                      	     2M 	
04:000002C3 F4        	     1M 		hlt
                      	     2M 	
04:000002C4 F4        	     1M 		hlt
                      	     2M 	
04:000002C5 F4        	     1M 		hlt
                      	     2M 	
04:000002C6 F4        	     1M 		hlt
                      	     2M 	
04:000002C7 F4        	     1M 		hlt
                      	     2M 	
04:000002C8 F4        	     1M 		hlt
                      	     2M 	
04:000002C9 F4        	     1M 		hlt
                      	     2M 	
04:000002CA F4        	     1M 		hlt
                      	     2M 	
04:000002CB F4        	     1M 		hlt
                      	     2M 	
04:000002CC F4        	     1M 		hlt
                      	     2M 	
                      	    83M .endif
                      	    84M 
                      	    85M # test negative offsets
04:000002CD 0F8359FF  	    86M jncok11:  jnc  jnz11
04:000002D1 0F855DFF  	    87M jnzok11:  jnz  jnp11
04:000002D5 0F8B61FF  	    88M jnpok11:  jnp  jns11
04:000002D9 0F8965FF  	    89M jnsok11:  jns  ja11
04:000002DD 0F8769FF  	    90M jaok11:   ja   next211
                      	    91M 
                      	    92M jo11:
04:000002E1 B400      	    93M 	mov $0,%ah
04:000002E3 9E        	    94M 	sahf
04:000002E4 B040      	    95M 	mov $0b1000000,%al
04:000002E6 C0E001    	    96M 	shl $1,%al   	# OF = high-order bit of AL <> (CF), ZF=0,SF=1,OF=1
04:000002E9 0F81A700  	    97M 	jno err211
04:000002ED 0F80A400  	    98M 	jo jook11
04:000002F1 F4        	    99M 	hlt
                      	   100M jnl11:
04:000002F2 0F8C9E00  	   101M 	jl err211   	# 7C / 0F8C   JL   SF!=OF
04:000002F6 0F8D9F00  	   102M 	jnl jnlok11  	# 7D / 0F8D   JNL  SF=OF
04:000002FA F4        	   103M 	hlt
                      	   104M jnle11:
04:000002FB 0F8E9500  	   105M 	jle err211   	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
04:000002FF 0F8F9A00  	   106M 	jnle jnleok11 # 7F / 0F8F   JNLE ZF=0 && SF=OF
04:00000303 F4        	   107M 	hlt
                      	   108M jl11:
04:00000304 B440      	   109M 	mov $PS_ZF,%ah
04:00000306 9E        	   110M 	sahf          # ZF=1,SF=0,OF=1
04:00000307 0F8C9600  	   111M 	jl jlok11   	# 7C / 0F8C   JL   SF!=OF
04:0000030B F4        	   112M 	hlt
                      	   113M jle11:
04:0000030C 0F8E9500  	   114M 	jle jleok11  	# 7E / 0F8E   JLE  ZF=1 || SF!=OF
04:00000310 F4        	   115M 	hlt
                      	   116M jcxz11:
                      	   117M .if 16==8
                      	   118M 	mov $1,%ecx
                      	   119M 	jcxz err211      	# E3   JCXZ  CX=0
                      	   120M 	mov $0x10000,%ecx
                      	   121M 	jcxz jcxzok11
                      	   122M jecxz11:
                      	   123M 	jecxz err211
                      	   124M 	mov $0,%ecx
                      	   125M 	jecxz jecxzok11 	# E3   JECXZ   ECX=0
                      	   126M jecxze11:
                      	   127M .endif
04:00000311 E99500    	   128M 	jmp exit11
                      	   129M 
                      	   130M .if 16==16
                      	   131M 	.rept 128
                      	   132M 		hlt
                      	   133M 	.endr
04:00000314 F4        	     1M 		hlt
                      	     2M 	
04:00000315 F4        	     1M 		hlt
                      	     2M 	
04:00000316 F4        	     1M 		hlt
                      	     2M 	
04:00000317 F4        	     1M 		hlt
                      	     2M 	
04:00000318 F4        	     1M 		hlt
                      	     2M 	
04:00000319 F4        	     1M 		hlt
                      	     2M 	
04:0000031A F4        	     1M 		hlt
                      	     2M 	
04:0000031B F4        	     1M 		hlt
                      	     2M 	
04:0000031C F4        	     1M 		hlt
                      	     2M 	
04:0000031D F4        	     1M 		hlt
                      	     2M 	
04:0000031E F4        	     1M 		hlt
                      	     2M 	
04:0000031F F4        	     1M 		hlt
                      	     2M 	
04:00000320 F4        	     1M 		hlt
                      	     2M 	
04:00000321 F4        	     1M 		hlt
                      	     2M 	
04:00000322 F4        	     1M 		hlt
                      	     2M 	
04:00000323 F4        	     1M 		hlt
                      	     2M 	
04:00000324 F4        	     1M 		hlt
                      	     2M 	
04:00000325 F4        	     1M 		hlt
                      	     2M 	
04:00000326 F4        	     1M 		hlt
                      	     2M 	
04:00000327 F4        	     1M 		hlt
                      	     2M 	
04:00000328 F4        	     1M 		hlt
                      	     2M 	
04:00000329 F4        	     1M 		hlt
                      	     2M 	
04:0000032A F4        	     1M 		hlt
                      	     2M 	
04:0000032B F4        	     1M 		hlt
                      	     2M 	
04:0000032C F4        	     1M 		hlt
                      	     2M 	
04:0000032D F4        	     1M 		hlt
                      	     2M 	
04:0000032E F4        	     1M 		hlt
                      	     2M 	
04:0000032F F4        	     1M 		hlt
                      	     2M 	
04:00000330 F4        	     1M 		hlt
                      	     2M 	
04:00000331 F4        	     1M 		hlt
                      	     2M 	
04:00000332 F4        	     1M 		hlt
                      	     2M 	
04:00000333 F4        	     1M 		hlt
                      	     2M 	
04:00000334 F4        	     1M 		hlt
                      	     2M 	
04:00000335 F4        	     1M 		hlt
                      	     2M 	
04:00000336 F4        	     1M 		hlt
                      	     2M 	
04:00000337 F4        	     1M 		hlt
                      	     2M 	
04:00000338 F4        	     1M 		hlt
                      	     2M 	
04:00000339 F4        	     1M 		hlt
                      	     2M 	
04:0000033A F4        	     1M 		hlt
                      	     2M 	
04:0000033B F4        	     1M 		hlt
                      	     2M 	
04:0000033C F4        	     1M 		hlt
                      	     2M 	
04:0000033D F4        	     1M 		hlt
                      	     2M 	
04:0000033E F4        	     1M 		hlt
                      	     2M 	
04:0000033F F4        	     1M 		hlt
                      	     2M 	
04:00000340 F4        	     1M 		hlt
                      	     2M 	
04:00000341 F4        	     1M 		hlt
                      	     2M 	
04:00000342 F4        	     1M 		hlt
                      	     2M 	
04:00000343 F4        	     1M 		hlt
                      	     2M 	
04:00000344 F4        	     1M 		hlt
                      	     2M 	
04:00000345 F4        	     1M 		hlt
                      	     2M 	
04:00000346 F4        	     1M 		hlt
                      	     2M 	
04:00000347 F4        	     1M 		hlt
                      	     2M 	
04:00000348 F4        	     1M 		hlt
                      	     2M 	
04:00000349 F4        	     1M 		hlt
                      	     2M 	
04:0000034A F4        	     1M 		hlt
                      	     2M 	
04:0000034B F4        	     1M 		hlt
                      	     2M 	
04:0000034C F4        	     1M 		hlt
                      	     2M 	
04:0000034D F4        	     1M 		hlt
                      	     2M 	
04:0000034E F4        	     1M 		hlt
                      	     2M 	
04:0000034F F4        	     1M 		hlt
                      	     2M 	
04:00000350 F4        	     1M 		hlt
                      	     2M 	
04:00000351 F4        	     1M 		hlt
                      	     2M 	
04:00000352 F4        	     1M 		hlt
                      	     2M 	
04:00000353 F4        	     1M 		hlt
                      	     2M 	
04:00000354 F4        	     1M 		hlt
                      	     2M 	
04:00000355 F4        	     1M 		hlt
                      	     2M 	
04:00000356 F4        	     1M 		hlt
                      	     2M 	
04:00000357 F4        	     1M 		hlt
                      	     2M 	
04:00000358 F4        	     1M 		hlt
                      	     2M 	
04:00000359 F4        	     1M 		hlt
                      	     2M 	
04:0000035A F4        	     1M 		hlt
                      	     2M 	
04:0000035B F4        	     1M 		hlt
                      	     2M 	
04:0000035C F4        	     1M 		hlt
                      	     2M 	
04:0000035D F4        	     1M 		hlt
                      	     2M 	
04:0000035E F4        	     1M 		hlt
                      	     2M 	
04:0000035F F4        	     1M 		hlt
                      	     2M 	
04:00000360 F4        	     1M 		hlt
                      	     2M 	
04:00000361 F4        	     1M 		hlt
                      	     2M 	
04:00000362 F4        	     1M 		hlt
                      	     2M 	
04:00000363 F4        	     1M 		hlt
                      	     2M 	
04:00000364 F4        	     1M 		hlt
                      	     2M 	
04:00000365 F4        	     1M 		hlt
                      	     2M 	
04:00000366 F4        	     1M 		hlt
                      	     2M 	
04:00000367 F4        	     1M 		hlt
                      	     2M 	
04:00000368 F4        	     1M 		hlt
                      	     2M 	
04:00000369 F4        	     1M 		hlt
                      	     2M 	
04:0000036A F4        	     1M 		hlt
                      	     2M 	
04:0000036B F4        	     1M 		hlt
                      	     2M 	
04:0000036C F4        	     1M 		hlt
                      	     2M 	
04:0000036D F4        	     1M 		hlt
                      	     2M 	
04:0000036E F4        	     1M 		hlt
                      	     2M 	
04:0000036F F4        	     1M 		hlt
                      	     2M 	
04:00000370 F4        	     1M 		hlt
                      	     2M 	
04:00000371 F4        	     1M 		hlt
                      	     2M 	
04:00000372 F4        	     1M 		hlt
                      	     2M 	
04:00000373 F4        	     1M 		hlt
                      	     2M 	
04:00000374 F4        	     1M 		hlt
                      	     2M 	
04:00000375 F4        	     1M 		hlt
                      	     2M 	
04:00000376 F4        	     1M 		hlt
                      	     2M 	
04:00000377 F4        	     1M 		hlt
                      	     2M 	
04:00000378 F4        	     1M 		hlt
                      	     2M 	
04:00000379 F4        	     1M 		hlt
                      	     2M 	
04:0000037A F4        	     1M 		hlt
                      	     2M 	
04:0000037B F4        	     1M 		hlt
                      	     2M 	
04:0000037C F4        	     1M 		hlt
                      	     2M 	
04:0000037D F4        	     1M 		hlt
                      	     2M 	
04:0000037E F4        	     1M 		hlt
                      	     2M 	
04:0000037F F4        	     1M 		hlt
                      	     2M 	
04:00000380 F4        	     1M 		hlt
                      	     2M 	
04:00000381 F4        	     1M 		hlt
                      	     2M 	
04:00000382 F4        	     1M 		hlt
                      	     2M 	
04:00000383 F4        	     1M 		hlt
                      	     2M 	
04:00000384 F4        	     1M 		hlt
                      	     2M 	
04:00000385 F4        	     1M 		hlt
                      	     2M 	
04:00000386 F4        	     1M 		hlt
                      	     2M 	
04:00000387 F4        	     1M 		hlt
                      	     2M 	
04:00000388 F4        	     1M 		hlt
                      	     2M 	
04:00000389 F4        	     1M 		hlt
                      	     2M 	
04:0000038A F4        	     1M 		hlt
                      	     2M 	
04:0000038B F4        	     1M 		hlt
                      	     2M 	
04:0000038C F4        	     1M 		hlt
                      	     2M 	
04:0000038D F4        	     1M 		hlt
                      	     2M 	
04:0000038E F4        	     1M 		hlt
                      	     2M 	
04:0000038F F4        	     1M 		hlt
                      	     2M 	
04:00000390 F4        	     1M 		hlt
                      	     2M 	
04:00000391 F4        	     1M 		hlt
                      	     2M 	
04:00000392 F4        	     1M 		hlt
                      	     2M 	
04:00000393 F4        	     1M 		hlt
                      	     2M 	
                      	   134M .endif
                      	   135M 
                      	   136M err211:
04:00000394 F4        	   137M 	hlt
                      	   138M 
                      	   139M # test negative offsets
04:00000395 0F8059FF  	   140M jook11:   jo   jnl11
04:00000399 0F8D5EFF  	   141M jnlok11:  jnl  jnle11
04:0000039D 0F8F63FF  	   142M jnleok11: jnle jl11
04:000003A1 0F8C67FF  	   143M jlok11:   jl   jle11
04:000003A5 0F8E68FF  	   144M jleok11:  jle  jcxz11
                      	   145M .if 16==8
                      	   146M jcxzok11:  jcxz  jecxz11
                      	   147M jecxzok11: jecxz jecxze11
                      	   148M .endif
                      	   149M 
                      	   150M exit11:
                      	   184: 
                      	   185: #
                      	   186: #   Loops
                      	   187: #
                      	   188: .include "loop_m.asm"

Source: "loop_m.asm"
                      	     1: #
                      	     2: #   Test of loop, loopz, loopnz
                      	     3: #   Use: EAX, ECX, Flags
                      	     4: #
                      	     5: 
                      	     6: .macro testLoop
                      	     7: 
                      	     8: 	mov $0x20000,%ecx
                      	     9: 	mov $0,%eax
                      	    10: loop16\@:
                      	    11: 	inc %eax
                      	    12: 	loopw loop16\@
                      	    13: 	cmp $0x10000,%eax
                      	    14: 	jne error
                      	    15: 	cmp $0x20000,%ecx
                      	    16: 	jne error
                      	    17: 
                      	    18: 	mov $0x20000,%ecx
                      	    19: 	mov $0,%eax
                      	    20: loop32\@:
                      	    21: 	inc %eax
                      	    22: 	loopl loop32\@
                      	    23: 	cmp $0x20000,%eax
                      	    24: 	jne error
                      	    25: 	cmp $0,%ecx
                      	    26: 	jne error
                      	    27: 
                      	    28: .endm
                      	    29: 
                      	    30: .macro testLoopZ
                      	    31: 
                      	    32: 	mov $0xFFFF,%cx
                      	    33: 	mov $0,%ax
                      	    34: loop16a\@:
                      	    35: 	inc %ax
                      	    36: 	cmp $0,%ah
                      	    37: 	loopzw loop16a\@
                      	    38: 	cmp $0x0100,%ax
                      	    39: 	jne error
                      	    40: 	cmp $0xFEFF,%cx
                      	    41: 	jne error
                      	    42: 
                      	    43: 	mov $0x00FF,%cx
                      	    44: 	mov $0,%ax
                      	    45: loop16b\@:
                      	    46: 	inc %ax
                      	    47: 	cmp $0,%ah
                      	    48: 	loopzw loop16b\@
                      	    49: 	cmp $0x00FF,%ax
                      	    50: 	jne error
                      	    51: 	cmp $0,%cx
                      	    52: 	jne error
                      	    53: 
                      	    54: 	mov $0x20000,%ecx
                      	    55: 	mov $0,%eax
                      	    56: loop32\@:
                      	    57: 	inc %eax
                      	    58: 	test $0x10000,%eax
                      	    59: 	loopzl loop32\@
                      	    60: 	cmp $0x10000,%eax
                      	    61: 	jne error
                      	    62: 	cmp $0x10000,%ecx
                      	    63: 	jne error
                      	    64: 
                      	    65: .endm
                      	    66: 
                      	    67: .macro testLoopNZ
                      	    68: 
                      	    69: 	mov $0xFFFF,%cx
                      	    70: 	mov $0,%ax
                      	    71: loop16a\@:
                      	    72: 	inc %ax
                      	    73: 	test $0xFF,%al
                      	    74: 	loopnzw loop16a\@
                      	    75: 	cmp $0x0100,%ax
                      	    76: 	jne error
                      	    77: 	cmp $0xFEFF,%cx
                      	    78: 	jne error
                      	    79: 
                      	    80: 	mov $0x00FF,%cx
                      	    81: 	mov $0,%ax
                      	    82: loop16b\@:
                      	    83: 	inc %ax
                      	    84: 	test $0xFF,%al
                      	    85: 	loopnzw loop16b\@
                      	    86: 	cmp $0x00FF,%ax
                      	    87: 	jne error
                      	    88: 	cmp $0,%cx
                      	    89: 	jne error
                      	    90: 
                      	    91: 	mov $0x10000,%ecx
                      	    92: 	mov $0,%eax
                      	    93: loop32\@:
                      	    94: 	inc %eax
                      	    95: 	test $0x0FFFF,%eax
                      	    96: 	loopnzl loop32\@
                      	    97: 	cmp $0x10000,%eax
                      	    98: 	jne error
                      	    99: 	cmp $0,%ecx
                      	   100: 	jne error
                      	   101: 
                      	   102: .endm

Source: "t386.asm"
                      	   189: #	testLoop
                      	   190: #	testLoopZ
                      	   191: #	testLoopNZ
                      	   192: 
                      	   193: #-------------------------------------------------------------------------------
                      	   194: 	POST $0x02
04:000003A9 B002      	     1M 	movb $0x02,%al
04:000003AB BA9001    	     2M 	movw $POST_PORT,%dx
04:000003AE EE        	     3M 	out %al,%dx
                      	   195: #-------------------------------------------------------------------------------
                      	   196: #
                      	   197: #   Quick tests of unsigned 32-bit multiplication and division
                      	   198: #   Thorough arithmetical and logical tests are done later
                      	   199: #
04:000003AF 66B8010000	   200: 	mov $0x80000001,%eax
04:000003B4 80
04:000003B5 66F7E8    	   201: 	imul %eax
04:000003B8 66B8112233	   202: 	mov $0x44332211,%eax
04:000003BD 44
04:000003BE 6689C3    	   203: 	mov %eax,%ebx
04:000003C1 66B9556677	   204: 	mov $0x88776655,%ecx
04:000003C6 88
04:000003C7 66F7E1    	   205: 	mul %ecx
04:000003CA 66F7F1    	   206: 	div %ecx
04:000003CD 6639D8    	   207: 	cmp %ebx,%eax
04:000003D0 0F85DB20  	   208: 	jne error
                      	   209: 
                      	   210: .include "mov_m.asm"

Source: "mov_m.asm"
                      	     1: #
                      	     2: #   Tests MOV from segment registers in real mode
                      	     3: #
                      	     4: #   %1 the segment register to test
                      	     5: #
                      	     6: .macro testMovSegR_real arg1
                      	     7: 	.ifc \arg1, cs
                      	     8: 	mov $C_SEG_REAL,%dx
                      	     9: 	.else
                      	    10: 	mov $D1_SEG_REAL,%dx
                      	    11: 	.endif
                      	    12: 
                      	    13: 	# MOV reg to Sreg
                      	    14: 	.ifc \arg1, cs
                      	    15: 	realModeFaultTest EX_UD, "mov %dx", \arg1 # test for #UD
                      	    16: 	.else
                      	    17: 	mov %dx,%\arg1
                      	    18: 	.endif
                      	    19: 
                      	    20: 	# MOV Sreg to 16 bit reg
                      	    21: 	xor %ax,%ax
                      	    22: 	mov %\arg1,%ax
                      	    23: 	cmp %dx,%ax
                      	    24: 	jne error
                      	    25: 
                      	    26: 	# MOV Sreg to 32 bit reg
                      	    27: 	mov $-1,%eax
                      	    28: 	mov %\arg1,%eax
                      	    29: 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    30: 	# TODO: verify on real hw and check TEST_UNDEF
                      	    31: 	cmp %dx,%ax
                      	    32: 	jne error
                      	    33: 
                      	    34: 	# MOV Sreg to word mem
                      	    35: 	movw $0xbeef,0
                      	    36: 	mov %\arg1,0
                      	    37: 	cmp %dx,0
                      	    38: 	jne error
                      	    39: 
                      	    40: 	# MOV word mem to Sreg
                      	    41: 	.ifc \arg1, cs
                      	    42: 	realModeFaultTest EX_UD, "mov 0", \arg1 # test for #UD
                      	    43: 	.else
                      	    44: 	mov %ds,%cx	 	# save current DS in CX
                      	    45: 	xor %ax,%ax
                      	    46: 	mov %ax,%\arg1
                      	    47: 	.ifc \arg1, ds
                      	    48: 	mov %cx,%es
                      	    49: 	mov %es:0,%\arg1
                      	    50: 	.else
                      	    51: 	mov 0,%\arg1
                      	    52: 	.endif
                      	    53: 	mov %\arg1,%ax
                      	    54: 	cmp %dx,%ax
                      	    55: 	jne error
                      	    56: 	.endif
                      	    57: 
                      	    58: .endm
                      	    59: 
                      	    60: 
                      	    61: .macro testMovSegR_prot arg1
                      	    62: 	mov $-1,%edx
                      	    63: 	.ifc \arg1, cs
                      	    64: 	mov $C_SEG_PROT32,%dx
                      	    65: 	%else
                      	    66: 	mov $D1_SEG_PROT,%dx
                      	    67: 	%endif
                      	    68: 
                      	    69: 	# MOV reg to Sreg
                      	    70: 	.ifc \arg1, cs
                      	    71: 	loadProtModeStack
                      	    72: 	protModeFaultTest EX_UD, $0, "mov %dx", \arg1 	# #UD: attempt is made to load the CS register.
                      	    73: 	.else
                      	    74: 	mov %dx,%\arg1
                      	    75: 	.endif
                      	    76: 
                      	    77: 	# MOV Sreg to 16 bit reg
                      	    78: 	xor %ax,%ax
                      	    79: 	mov %\arg1,%ax
                      	    80: 	cmp %dx,%ax
                      	    81: 	jne error
                      	    82: 
                      	    83: 	# MOV Sreg to 32 bit reg
                      	    84: 	mov $-1,%eax
                      	    85: 	mov %\arg1,%eax
                      	    86: 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    87: 	# TODO: verify on real hw and check TEST_UNDEF
                      	    88: 	cmp %dx,%ax
                      	    89: 	jne error
                      	    90: 
                      	    91: 	# MOV Sreg to word mem
                      	    92: 	movl $-1,0
                      	    93: 	mov %\arg1,0
                      	    94: 	cmp %edx,0
                      	    95: 	jne error
                      	    96: 
                      	    97: 	# MOV word mem to Sreg
                      	    98: 	.ifc \arg1, cs
                      	    99: 	protModeFaultTest EX_UD, $0, "mov 0", \arg1 # test for #UD
                      	   100: 	.else
                      	   101: 	mov %ds,%cx 	# save current DS in CX
                      	   102: 	mov $DTEST_SEG_PROT,%ax
                      	   103: 	mov %ax,%\arg1
                      	   104: 	.ifc \arg1, ds
                      	   105: 	mov %cx,%es
                      	   106: 	mov %es:0,%\arg1
                      	   107: 	.else
                      	   108: 	mov 0,%\arg1
                      	   109: 	.endif
                      	   110: 	mov %\arg1,%ax
                      	   111: 	cmp %dx,%ax
                      	   112: 	jne error
                      	   113: 	.endif
                      	   114: 
                      	   115: 	loadProtModeStack
                      	   116: 	.ifc \arg1, ss
                      	   117: 	# #GP(0) If attempt is made to load SS register with NULL segment selector.
                      	   118: 	mov $NULL,%ax
                      	   119: 	protModeFaultTest EX_GP, $0, "mov %ax", \arg1
                      	   120: 	# #GP(selector) If the SS register is being loaded and the segment selector's RPL and the segment descriptor’s DPL are
                      	   121: 	mov $DPL1_SEG_PROT|1,%ax
                      	   122: 	protModeFaultTest EX_GP, $DPL1_SEG_PROT, "mov %ax" ,\arg1
                      	   123: 	# #GP(selector) If the SS register is being loaded and the segment pointed to is a non-writable data segment.
                      	   124: 	mov $RO_SEG_PROT,%ax
                      	   125: 	protModeFaultTest EX_GP, $RO_SEG_PROT, "mov %ax", \arg1
                      	   126: 	# #SS(selector) If the SS register is being loaded and the segment pointed to is marked not present.
                      	   127: 	mov $NP_SEG_PROT,%ax
                      	   128: 	protModeFaultTest EX_SS, $NP_SEG_PROT, "mov %ax", \arg1
                      	   129: 	.endif
                      	   130: 	.ifnc \arg1, cs
                      	   131: 	# #GP(selector) If segment selector index is outside descriptor table limits.
                      	   132: 	mov $0xFFF8,%ax
                      	   133: 	protModeFaultTest EX_GP, $0xfff8, "mov %ax", \arg1
                      	   134: 	.ifnc \arg1, ss
                      	   135: 	# #NP(selector) If the DS, ES, FS, or GS register is being loaded and the segment pointed to is marked not present.
                      	   136: 	mov $NP_SEG_PROT,%ax
                      	   137: 	protModeFaultTest EX_NP, $NP_SEG_PROT, "mov %ax", \arg1
                      	   138: 	# #GP(selector) If the DS, ES, FS, or GS register is being loaded and the segment pointed to is not a data or readable
                      	   139: 	mov $SYS_SEG_PROT,%ax
                      	   140: 	protModeFaultTest EX_GP, $SYS_SEG_PROT, "mov %ax", \arg1
                      	   141: 	# #GP(selector)
                      	   142: 	# If the DS, ES, FS, or GS register is being loaded and the segment pointed to is a data or nonconforming code segment
                      	   143: 	call switchToRing3 # CPL=3
                      	   144: 	mov $DTEST_SEG_PROT|3,%ax 	# RPL=3,DPL=0
                      	   145: 	protModeFaultTest EX_GP, $DTEST_SEG_PROT, "mov %ax", \arg1
                      	   146: 	call switchToRing0
                      	   147: 	.endif
                      	   148: 	.endif
                      	   149: 
                      	   150: .endm
                      	   151: 

Source: "t386.asm"
                      	   211: #-------------------------------------------------------------------------------
                      	   212: 	POST $0x03
04:000003D4 B003      	     1M 	movb $0x03,%al
04:000003D6 BA9001    	     2M 	movw $POST_PORT,%dx
04:000003D9 EE        	     3M 	out %al,%dx
                      	   213: #-------------------------------------------------------------------------------
                      	   214: #
                      	   215: #   Move segment registers in real mode
                      	   216: #
                      	   217: 	testMovSegR_real ss
                      	     1M 	.ifc ss, cs
                      	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
04:000003DA C7C200C0  	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc ss, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", ss # test for #UD
                      	    10M 	.else
04:000003DE 8ED2      	    11M 	mov %dx,%ss
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:000003E0 31C0      	    15M 	xor %ax,%ax
04:000003E2 8CD0      	    16M 	mov %ss,%ax
04:000003E4 39D0      	    17M 	cmp %dx,%ax
04:000003E6 0F85C520  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:000003EA 66B8FFFFFF	    21M 	mov $-1,%eax
04:000003EF FF
04:000003F0 668CD0    	    22M 	mov %ss,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:000003F3 39D0      	    25M 	cmp %dx,%ax
04:000003F5 0F85B620  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:000003F9 C7060000EF	    29M 	movw $0xbeef,0
04:000003FE BE
04:000003FF 8C160000  	    30M 	mov %ss,0
04:00000403 39160000  	    31M 	cmp %dx,0
04:00000407 0F85A420  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc ss, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", ss # test for #UD
                      	    37M 	.else
04:0000040B 8CD9      	    38M 	mov %ds,%cx	 	# save current DS in CX
04:0000040D 31C0      	    39M 	xor %ax,%ax
04:0000040F 8ED0      	    40M 	mov %ax,%ss
                      	    41M 	.ifc ss, ds
                      	    42M 	mov %cx,%es
                      	    43M 	mov %es:0,%ss
                      	    44M 	.else
04:00000411 8E160000  	    45M 	mov 0,%ss
                      	    46M 	.endif
04:00000415 8CD0      	    47M 	mov %ss,%ax
04:00000417 39D0      	    48M 	cmp %dx,%ax
04:00000419 0F859220  	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   218: 	testMovSegR_real ds
                      	     1M 	.ifc ds, cs
                      	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
04:0000041D C7C200C0  	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc ds, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", ds # test for #UD
                      	    10M 	.else
04:00000421 8EDA      	    11M 	mov %dx,%ds
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:00000423 31C0      	    15M 	xor %ax,%ax
04:00000425 8CD8      	    16M 	mov %ds,%ax
04:00000427 39D0      	    17M 	cmp %dx,%ax
04:00000429 0F858220  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:0000042D 66B8FFFFFF	    21M 	mov $-1,%eax
04:00000432 FF
04:00000433 668CD8    	    22M 	mov %ds,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:00000436 39D0      	    25M 	cmp %dx,%ax
04:00000438 0F857320  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:0000043C C7060000EF	    29M 	movw $0xbeef,0
04:00000441 BE
04:00000442 8C1E0000  	    30M 	mov %ds,0
04:00000446 39160000  	    31M 	cmp %dx,0
04:0000044A 0F856120  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc ds, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", ds # test for #UD
                      	    37M 	.else
04:0000044E 8CD9      	    38M 	mov %ds,%cx	 	# save current DS in CX
04:00000450 31C0      	    39M 	xor %ax,%ax
04:00000452 8ED8      	    40M 	mov %ax,%ds
                      	    41M 	.ifc ds, ds
04:00000454 8EC1      	    42M 	mov %cx,%es
04:00000456 268E1E0000	    43M 	mov %es:0,%ds
                      	    44M 	.else
                      	    45M 	mov 0,%ds
                      	    46M 	.endif
04:0000045B 8CD8      	    47M 	mov %ds,%ax
04:0000045D 39D0      	    48M 	cmp %dx,%ax
04:0000045F 0F854C20  	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   219: 	testMovSegR_real es
                      	     1M 	.ifc es, cs
                      	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
04:00000463 C7C200C0  	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc es, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", es # test for #UD
                      	    10M 	.else
04:00000467 8EC2      	    11M 	mov %dx,%es
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:00000469 31C0      	    15M 	xor %ax,%ax
04:0000046B 8CC0      	    16M 	mov %es,%ax
04:0000046D 39D0      	    17M 	cmp %dx,%ax
04:0000046F 0F853C20  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:00000473 66B8FFFFFF	    21M 	mov $-1,%eax
04:00000478 FF
04:00000479 668CC0    	    22M 	mov %es,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:0000047C 39D0      	    25M 	cmp %dx,%ax
04:0000047E 0F852D20  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:00000482 C7060000EF	    29M 	movw $0xbeef,0
04:00000487 BE
04:00000488 8C060000  	    30M 	mov %es,0
04:0000048C 39160000  	    31M 	cmp %dx,0
04:00000490 0F851B20  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc es, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", es # test for #UD
                      	    37M 	.else
04:00000494 8CD9      	    38M 	mov %ds,%cx	 	# save current DS in CX
04:00000496 31C0      	    39M 	xor %ax,%ax
04:00000498 8EC0      	    40M 	mov %ax,%es
                      	    41M 	.ifc es, ds
                      	    42M 	mov %cx,%es
                      	    43M 	mov %es:0,%es
                      	    44M 	.else
04:0000049A 8E060000  	    45M 	mov 0,%es
                      	    46M 	.endif
04:0000049E 8CC0      	    47M 	mov %es,%ax
04:000004A0 39D0      	    48M 	cmp %dx,%ax
04:000004A2 0F850920  	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   220: 	testMovSegR_real fs
                      	     1M 	.ifc fs, cs
                      	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
04:000004A6 C7C200C0  	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc fs, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", fs # test for #UD
                      	    10M 	.else
04:000004AA 8EE2      	    11M 	mov %dx,%fs
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:000004AC 31C0      	    15M 	xor %ax,%ax
04:000004AE 8CE0      	    16M 	mov %fs,%ax
04:000004B0 39D0      	    17M 	cmp %dx,%ax
04:000004B2 0F85F91F  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:000004B6 66B8FFFFFF	    21M 	mov $-1,%eax
04:000004BB FF
04:000004BC 668CE0    	    22M 	mov %fs,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:000004BF 39D0      	    25M 	cmp %dx,%ax
04:000004C1 0F85EA1F  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:000004C5 C7060000EF	    29M 	movw $0xbeef,0
04:000004CA BE
04:000004CB 8C260000  	    30M 	mov %fs,0
04:000004CF 39160000  	    31M 	cmp %dx,0
04:000004D3 0F85D81F  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc fs, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", fs # test for #UD
                      	    37M 	.else
04:000004D7 8CD9      	    38M 	mov %ds,%cx	 	# save current DS in CX
04:000004D9 31C0      	    39M 	xor %ax,%ax
04:000004DB 8EE0      	    40M 	mov %ax,%fs
                      	    41M 	.ifc fs, ds
                      	    42M 	mov %cx,%es
                      	    43M 	mov %es:0,%fs
                      	    44M 	.else
04:000004DD 8E260000  	    45M 	mov 0,%fs
                      	    46M 	.endif
04:000004E1 8CE0      	    47M 	mov %fs,%ax
04:000004E3 39D0      	    48M 	cmp %dx,%ax
04:000004E5 0F85C61F  	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   221: 	testMovSegR_real gs
                      	     1M 	.ifc gs, cs
                      	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
04:000004E9 C7C200C0  	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc gs, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", gs # test for #UD
                      	    10M 	.else
04:000004ED 8EEA      	    11M 	mov %dx,%gs
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:000004EF 31C0      	    15M 	xor %ax,%ax
04:000004F1 8CE8      	    16M 	mov %gs,%ax
04:000004F3 39D0      	    17M 	cmp %dx,%ax
04:000004F5 0F85B61F  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:000004F9 66B8FFFFFF	    21M 	mov $-1,%eax
04:000004FE FF
04:000004FF 668CE8    	    22M 	mov %gs,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:00000502 39D0      	    25M 	cmp %dx,%ax
04:00000504 0F85A71F  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:00000508 C7060000EF	    29M 	movw $0xbeef,0
04:0000050D BE
04:0000050E 8C2E0000  	    30M 	mov %gs,0
04:00000512 39160000  	    31M 	cmp %dx,0
04:00000516 0F85951F  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc gs, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", gs # test for #UD
                      	    37M 	.else
04:0000051A 8CD9      	    38M 	mov %ds,%cx	 	# save current DS in CX
04:0000051C 31C0      	    39M 	xor %ax,%ax
04:0000051E 8EE8      	    40M 	mov %ax,%gs
                      	    41M 	.ifc gs, ds
                      	    42M 	mov %cx,%es
                      	    43M 	mov %es:0,%gs
                      	    44M 	.else
04:00000520 8E2E0000  	    45M 	mov 0,%gs
                      	    46M 	.endif
04:00000524 8CE8      	    47M 	mov %gs,%ax
04:00000526 39D0      	    48M 	cmp %dx,%ax
04:00000528 0F85831F  	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   222: 	testMovSegR_real cs
                      	     1M 	.ifc cs, cs
04:0000052C BA00F0    	     2M 	mov $C_SEG_REAL,%dx
                      	     3M 	.else
                      	     4M 	mov $D1_SEG_REAL,%dx
                      	     5M 	.endif
                      	     6M 
                      	     7M 	# MOV reg to Sreg
                      	     8M 	.ifc cs, cs
                      	     9M 	realModeFaultTest EX_UD, "mov %dx", cs # test for #UD
                      	     1M 	realModeExcInit EX_UD,continue25
04:0000052F B80090    	     1M 	mov $IDT_SEG_REAL,%ax
04:00000532 8ED8      	     2M 	mov %ax,%ds
04:00000534 C70618004D	     3M 	movw $continue25,EX_UD*4
04:00000539 05
04:0000053A C7061A0000	     4M 	movw $C_SEG_REAL,EX_UD*4+2
04:0000053F F0
04:00000540 B800C0    	     2M 	mov $S_SEG_REAL,%ax
04:00000543 8ED0      	     3M 	mov %ax,%ss
04:00000545 BCFC7F    	     4M 	mov $ESP_REAL,%sp
                      	     5M test25:
04:00000548 8ECA      	     6M 	mov %dx,%cs
04:0000054A E9621F    	     7M 	jmp error
                      	     8M continue25:
                      	     9M 	realModeExcCheck EX_UD,test25
04:0000054D 81FCF67F  	     1M 	cmp $ESP_REAL-6,%sp
04:00000551 0F855A1F  	     2M 	jne error
04:00000555 36813EF87F	     3M 	cmpw $C_SEG_REAL,%ss:ESP_REAL-4
04:0000055A 00F0
04:0000055C 0F854F1F  	     4M 	jne error
04:00000560 36813EF67F	     5M 	cmpw $test25,%ss:ESP_REAL-6
04:00000565 4805
04:00000567 0F85441F  	     6M 	jne error
04:0000056B B80000    	     7M 	mov $0,%ax
04:0000056E 8ED8      	     8M 	mov %ax,%ds
04:00000570 C7061800AF	     9M 	movw $error,EX_UD*4
04:00000575 24
04:00000576 C7061A0000	    10M 	movw $C_SEG_REAL,EX_UD*4+2
04:0000057B F0
                      	    10M 	.else
                      	    11M 	mov %dx,%cs
                      	    12M 	.endif
                      	    13M 
                      	    14M 	# MOV Sreg to 16 bit reg
04:0000057C 31C0      	    15M 	xor %ax,%ax
04:0000057E 8CC8      	    16M 	mov %cs,%ax
04:00000580 39D0      	    17M 	cmp %dx,%ax
04:00000582 0F85291F  	    18M 	jne error
                      	    19M 
                      	    20M 	# MOV Sreg to 32 bit reg
04:00000586 66B8FFFFFF	    21M 	mov $-1,%eax
04:0000058B FF
04:0000058C 668CC8    	    22M 	mov %cs,%eax
                      	    23M 	# bits 31:16 are undefined for Pentium and earlier processors.
                      	    24M 	# TODO: verify on real hw and check TEST_UNDEF
04:0000058F 39D0      	    25M 	cmp %dx,%ax
04:00000591 0F851A1F  	    26M 	jne error
                      	    27M 
                      	    28M 	# MOV Sreg to word mem
04:00000595 C7060000EF	    29M 	movw $0xbeef,0
04:0000059A BE
04:0000059B 8C0E0000  	    30M 	mov %cs,0
04:0000059F 39160000  	    31M 	cmp %dx,0
04:000005A3 0F85081F  	    32M 	jne error
                      	    33M 
                      	    34M 	# MOV word mem to Sreg
                      	    35M 	.ifc cs, cs
                      	    36M 	realModeFaultTest EX_UD, "mov 0", cs # test for #UD
                      	     1M 	realModeExcInit EX_UD,continue28
04:000005A7 B80090    	     1M 	mov $IDT_SEG_REAL,%ax
04:000005AA 8ED8      	     2M 	mov %ax,%ds
04:000005AC C7061800C7	     3M 	movw $continue28,EX_UD*4
04:000005B1 05
04:000005B2 C7061A0000	     4M 	movw $C_SEG_REAL,EX_UD*4+2
04:000005B7 F0
04:000005B8 B800C0    	     2M 	mov $S_SEG_REAL,%ax
04:000005BB 8ED0      	     3M 	mov %ax,%ss
04:000005BD BCFC7F    	     4M 	mov $ESP_REAL,%sp
                      	     5M test28:
04:000005C0 8E0E0000  	     6M 	mov 0,%cs
04:000005C4 E9E81E    	     7M 	jmp error
                      	     8M continue28:
                      	     9M 	realModeExcCheck EX_UD,test28
04:000005C7 81FCF67F  	     1M 	cmp $ESP_REAL-6,%sp
04:000005CB 0F85E01E  	     2M 	jne error
04:000005CF 36813EF87F	     3M 	cmpw $C_SEG_REAL,%ss:ESP_REAL-4
04:000005D4 00F0
04:000005D6 0F85D51E  	     4M 	jne error
04:000005DA 36813EF67F	     5M 	cmpw $test28,%ss:ESP_REAL-6
04:000005DF C005
04:000005E1 0F85CA1E  	     6M 	jne error
04:000005E5 B80000    	     7M 	mov $0,%ax
04:000005E8 8ED8      	     8M 	mov %ax,%ds
04:000005EA C7061800AF	     9M 	movw $error,EX_UD*4
04:000005EF 24
04:000005F0 C7061A0000	    10M 	movw $C_SEG_REAL,EX_UD*4+2
04:000005F5 F0
                      	    37M 	.else
                      	    38M 	mov %ds,%cx	 	# save current DS in CX
                      	    39M 	xor %ax,%ax
                      	    40M 	mov %ax,%cs
                      	    41M 	.ifc cs, ds
                      	    42M 	mov %cx,%es
                      	    43M 	mov %es:0,%cs
                      	    44M 	.else
                      	    45M 	mov 0,%cs
                      	    46M 	.endif
                      	    47M 	mov %cs,%ax
                      	    48M 	cmp %dx,%ax
                      	    49M 	jne error
                      	    50M 	.endif
                      	    51M 
                      	   223: 
                      	   224: 	advTestSegReal
                      	     1M 	advTestBase
                      	     1M 	.set TEST_BASE1,TEST_BASE1+0x1000
                      	     2M 	.set TEST_BASE2,TEST_BASE2+0x1000
                      	     2M 	.set D1_SEG_REAL,TEST_BASE1 >> 4
                      	     3M 	.set D2_SEG_REAL,TEST_BASE2 >> 4
04:000005F6 C7C200C1  	     4M 	mov $D1_SEG_REAL,%dx
04:000005FA 8EDA      	     5M 	mov %dx,%ds
04:000005FC C7C200C3  	     6M 	mov $D2_SEG_REAL,%dx
04:00000600 8EC2      	     7M 	mov %dx,%es
                      	   225: 
                      	   226: .include "string_m.asm"

Source: "string_m.asm"
                      	     1: #
                      	     2: #   Tests store, compare, scan, and move string operands
                      	     3: #   %1 data size b=byte, w=word, d=dword
                      	     4: #   %2 direction 0=increment, 1=decrement
                      	     5: #   %3 addressing a16=16-bit, a32=32-bit
                      	     6: #   DS test segment 1
                      	     7: #   ES test segment 2
                      	     8: #
                      	     9: .macro testStringOps arg1,arg2,arg3
                      	    10: 
                      	    11: 	.set value,0x12345678
                      	    12: 	.if \arg1 = b
                      	    13: 		.set val_size,1
                      	    14: 		.set val_mask,0x000000ff
                      	    15: 	.endif
                      	    16: 	.if \arg1 = w
                      	    17: 		.set val_size,2
                      	    18: 		.set val_mask,0x0000ffff
                      	    19: 	.endif
                      	    20: 	.if \arg1 = d
                      	    21: 		.set val_size,4
                      	    22: 		.set val_mask,0xffffffff
                      	    23: 	.endif
                      	    24: 
                      	    25: 	.if \arg2 == 0
                      	    26: 		cld
                      	    27: 		.set off_value,0x0001ffff-(val_size-1)
                      	    28: 		.if \arg3 = 16
                      	    29: 			# 16-bit addressing
                      	    30: 			.set off_cmp,0x00010000
                      	    31: 		.else
                      	    32: 			# 32-bit addressing
                      	    33: 			.set off_cmp,0x00020000
                      	    34: 		.endif
                      	    35: 	.else
                      	    36: 		std
                      	    37: 		.set off_value,0x00010000
                      	    38: 		.if \arg3 = 16
                      	    39: 			# 16-bit addressing
                      	    40: 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    41: 		.else
                      	    42: 			# 32-bit addressing
                      	    43: 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    44: 		.endif
                      	    45: 	.endif
                      	    46: 
                      	    47: 	.if \arg3 = 16
                      	    48: 		.set off_mask,0x0000ffff
                      	    49: 	.else
                      	    50: 		.set off_mask,0xffffffff
                      	    51: 	.endif
                      	    52: 
                      	    53: 	# VERIFY string operands
                      	    54: 	.if \arg1 = b
                      	    55: 		mov $off_value,%edi
                      	    56: 		mov $off_value & off_mask,%ebx
                      	    57: 		mov $0,%al
                      	    58: 		mov %al,%es:(%ebx)
                      	    59: 		mov $value,%al
                      	    60: #		addr\arg3
                      	    61: 		stosb		 	# STORE EAX in ES:EDI
                      	    62: 		.if \arg3 = 16
                      	    63: 			cmp %al,%es:(%ebx)
                      	    64: 		.else
                      	    65: 			cmp %al,%es:(%ebx)
                      	    66: 		.endif
                      	    67: 		jne error
                      	    68: 		cmp $off_cmp,%edi
                      	    69: 		jne error
                      	    70: 
                      	    71: 		mov $off_value,%esi
                      	    72: 		mov $off_value,%edi
                      	    73: 		mov $off_value & off_mask,%ebx
                      	    74: 		mov %al,%ds:(%ebx)
                      	    75: 		mov %al,%es:(%ebx)
                      	    76: 		cmp $0,%al
                      	    77: 		je error
                      	    78: #		addr\arg3
                      	    79: 		cmpsb     # COMPARE ES:EDI with DS:ESI
                      	    80: 		jne error
                      	    81: 		cmp $off_cmp,%edi
                      	    82: 		jne error
                      	    83: 		cmp $off_cmp,%esi
                      	    84: 		jne error
                      	    85: 
                      	    86: 		mov $off_value,%edi
                      	    87: 		mov $value,%al
                      	    88: 		mov %al,%es:(%ebx)
                      	    89: 		cmp $0,%al
                      	    90: #		addr\arg3
                      	    91: 		scasb     # SCAN/COMPARE ES:EDI with EAX
                      	    92: 		jne error
                      	    93: 		cmp $off_cmp,%edi
                      	    94: 		jne error
                      	    95: 
                      	    96: 		mov $off_value,%esi
                      	    97: 		mov $off_value,%edi
                      	    98: 		mov $value,%al
                      	    99: 		mov %al,%ds:(%ebx)
                      	   100: 		mov $0,%al
                      	   101: 		mov %al,%es:(%ebx)
                      	   102: #		addr\arg3
                      	   103: 		movsb        # MOVE data from DS:ESI to ES:EDI
                      	   104: 		mov $value,%al
                      	   105: 		.if \arg3 = 16
                      	   106: 			cmp %al,%es:(%ebx)
                      	   107: 		.else
                      	   108: 			cmp %al,%es:(%ebx)
                      	   109: 		.endif
                      	   110: 		jne error
                      	   111: 		cmp $off_cmp,%edi
                      	   112: 		jne error
                      	   113: 		cmp $off_cmp,%esi
                      	   114: 		jne error
                      	   115: 
                      	   116: 		mov $off_value,%esi
                      	   117: 		mov $value,%al
                      	   118: 		mov %al,%es:(%ebx)
                      	   119: 		xor %eax,%eax
                      	   120: #		addr\arg3
                      	   121: 		lodsb       # LOAD data from DS:ESI into EAX
                      	   122: 		cmp $value & val_mask,%al
                      	   123: 		jne error
                      	   124: 		cmp $off_cmp,%esi
                      	   125: 		jne error
                      	   126: 	.endif
                      	   127: 
                      	   128: 	.if \arg1 = w
                      	   129: 		mov $off_value,%edi
                      	   130: 		mov $off_value & off_mask,%ebx
                      	   131: 		mov $0,%ax
                      	   132: 		mov %ax,%es:(%ebx)
                      	   133: 		mov $value,%ax
                      	   134: #		addr\arg3
                      	   135: 		stosw     # STORE EAX in ES:EDI
                      	   136: 		.if \arg3 = 16
                      	   137: 			cmp %ax,%es:(%ebx)
                      	   138: 		.else
                      	   139: 			cmp %ax,%es:(%ebx)
                      	   140: 		.endif
                      	   141: 		jne error
                      	   142: 		cmp $off_cmp,%edi
                      	   143: 		jne error
                      	   144: 
                      	   145: 		mov $off_value,%esi
                      	   146: 		mov $off_value,%edi
                      	   147: 		mov $off_value & off_mask,%ebx
                      	   148: 		mov %ax,%ds:(%ebx)
                      	   149: 		mov %ax,%es:(%ebx)
                      	   150: 		cmp $0,%ax
                      	   151: 		je error
                      	   152: #		addr\arg3
                      	   153: 		cmpsw     # COMPARE ES:EDI with DS:ESI
                      	   154: 		jne error
                      	   155: 		cmp $off_cmp,%edi
                      	   156: 		jne error
                      	   157: 		cmp $off_cmp,%esi
                      	   158: 		jne error
                      	   159: 
                      	   160: 		mov $off_value,%edi
                      	   161: 		mov $value,%ax
                      	   162: 		mov %ax,%es:(%ebx)
                      	   163: 		cmp $0,%ax
                      	   164: #		addr\arg3
                      	   165: 		scasw     # SCAN/COMPARE ES:EDI with EAX
                      	   166: 		jne error
                      	   167: 		cmp $off_cmp,%edi
                      	   168: 		jne error
                      	   169: 
                      	   170: 		mov $off_value,%esi
                      	   171: 		mov $off_value,%edi
                      	   172: 		mov $value,%ax
                      	   173: 		mov %ax,%ds:(%ebx)
                      	   174: 		mov $0,%ax
                      	   175: 		mov %ax,%es:(%ebx)
                      	   176: #		addr\arg3
                      	   177: 		movsw 					# MOVE data from DS:ESI to ES:EDI
                      	   178: 		mov $value,%ax
                      	   179: 		.if \arg3 = 16
                      	   180: 			cmp %ax,%es:(%ebx)
                      	   181: 		.else
                      	   182: 			cmp %ax,%es:(%ebx)
                      	   183: 		.endif
                      	   184: 		jne error
                      	   185: 		cmp $off_cmp,%edi
                      	   186: 		jne error
                      	   187: 		cmp $off_cmp,%esi
                      	   188: 		jne error
                      	   189: 
                      	   190: 		mov $off_value,%esi
                      	   191: 		mov $value,%ax
                      	   192: 		mov %ax,%es:(%ebx)
                      	   193: 		xor %eax,%eax
                      	   194: #		addr\arg3
                      	   195: 		lodsw       # LOAD data from DS:ESI into EAX
                      	   196: 		cmp $value & val_mask,%ax
                      	   197: 		jne error
                      	   198: 		cmp $off_cmp,%esi
                      	   199: 		jne error
                      	   200: 	.endif
                      	   201: 
                      	   202: 	.if \arg1 = d
                      	   203: 		mov $off_value,%edi
                      	   204: 		mov $off_value & off_mask,%ebx
                      	   205: 		mov $0,%eax
                      	   206: 		mov %eax,%es:(%ebx)
                      	   207: 		mov $value,%eax
                      	   208: #		addr\arg3
                      	   209: 		stosl     # STORE EAX in ES:EDI
                      	   210: 		.if \arg3 = 16
                      	   211: 			cmp %eax,%es:(%ebx)
                      	   212: 		.else
                      	   213: 			cmp %eax,%es:(%ebx)
                      	   214: 		.endif
                      	   215: 		jne error
                      	   216: 		cmp $off_cmp,%edi
                      	   217: 		jne error
                      	   218: 
                      	   219: 		mov $off_value,%esi
                      	   220: 		mov $off_value,%edi
                      	   221: 		mov $off_value & off_mask,%ebx
                      	   222: 		mov %eax,%ds:(%ebx)
                      	   223: 		mov %eax,%es:(%ebx)
                      	   224: 		cmp $0,%eax
                      	   225: 		je error
                      	   226: #		addr\arg3
                      	   227: 		cmpsl     # COMPARE ES:EDI with DS:ESI
                      	   228: 		jne error
                      	   229: 		cmp $off_cmp,%edi
                      	   230: 		jne error
                      	   231: 		cmp $off_cmp,%esi
                      	   232: 		jne error
                      	   233: 
                      	   234: 		mov $off_value,%edi
                      	   235: 		mov $value,%eax
                      	   236: 		mov %eax,%es:(%ebx)
                      	   237: 		cmp $0,%eax
                      	   238: #		addr\arg3
                      	   239: 		scasl     # SCAN/COMPARE ES:EDI with EAX
                      	   240: 		jne error
                      	   241: 		cmp $off_cmp,%edi
                      	   242: 		jne error
                      	   243: 
                      	   244: 		mov $off_value,%esi
                      	   245: 		mov $off_value,%edi
                      	   246: 		mov $value,%eax
                      	   247: 		mov %eax,%ds:(%ebx)
                      	   248: 		mov $0,%eax
                      	   249: 		mov %eax,%es:(%ebx)
                      	   250: #		addr\arg3
                      	   251: 		movsl        # MOVE data from DS:ESI to ES:EDI
                      	   252: 		mov $value,%eax
                      	   253: 		.if \arg3 = 16
                      	   254: 			cmp %eax,%es:(%ebx)
                      	   255: 		.else
                      	   256: 			cmp %eax,%es:(%ebx)
                      	   257: 		.endif
                      	   258: 		jne error
                      	   259: 		cmp $off_cmp,%edi
                      	   260: 		jne error
                      	   261: 		cmp $off_cmp,%esi
                      	   262: 		jne error
                      	   263: 
                      	   264: 		mov $off_value,%esi
                      	   265: 		mov $value,%eax
                      	   266: 		mov %eax,%es:(%ebx)
                      	   267: 		xor %eax,%eax
                      	   268: #		addr\arg3
                      	   269: 		lodsl       # LOAD data from DS:ESI into EAX
                      	   270: 		cmp $value & val_mask,%eax
                      	   271: 		jne error
                      	   272: 		cmp $off_cmp,%esi
                      	   273: 		jne error
                      	   274: 	.endif
                      	   275: 
                      	   276: .endm
                      	   277: 
                      	   278: #
                      	   279: #   Tests store, compare, scan, and move string operands with repetitions
                      	   280: #   %1 element size b=byte, w=word, d=dword
                      	   281: #   %2 direction 0=increment, 1=decrement
                      	   282: #   %3 addressing a16=16-bit, a32=32-bit
                      	   283: #   DS test segment 1
                      	   284: #   ES test segment 2
                      	   285: #
                      	   286: .macro testStringReps arg1,arg2,arg3
                      	   287: 
                      	   288: 	.set bytes,0x100
                      	   289: 
                      	   290: 	.if \arg1 = b
                      	   291: 		.set items,bytes
                      	   292: 	.endif
                      	   293: 	.if \arg1 = w
                      	   294: 		.set items,bytes/2
                      	   295: 	.endif
                      	   296: 	.if \arg1 = d
                      	   297: 		.set items,bytes/4
                      	   298: 	.endif
                      	   299: 
                      	   300: 	.if \arg2 == 0
                      	   301: 		cld
                      	   302: 		.set off_value,0x0001ff00
                      	   303: 		.if \arg3 = 16
                      	   304: 			# 16-bit addressing
                      	   305: 			.set off_cmp,0x00010000
                      	   306: 		.else
                      	   307: 			# 32-bit addressing
                      	   308: 			.set off_cmp,0x00020000
                      	   309: 		.endif
                      	   310: 	.else
                      	   311: 		std
                      	   312: 		.set off_value,0x000100ff
                      	   313: 		.if \arg3 = 16
                      	   314: 			# 16-bit addressing
                      	   315: 			.set off_cmp,0x0001ffff
                      	   316: 		.else
                      	   317: 			# 32-bit addressing
                      	   318: 			.set off_cmp,0x0000ffff
                      	   319: 		.endif
                      	   320: 	.endif
                      	   321: 
                      	   322: 	mov $0x12345678,%eax
                      	   323: 	mov $off_value,%esi
                      	   324: 	mov $off_value,%edi
                      	   325: 
                      	   326: 	# VERIFY REPs on memory buffers
                      	   327: 
                      	   328: 	# STORE buffers with pattern in EAX
                      	   329: 	mov $0x12345678,%eax
                      	   330: 	mov $off_value,%esi
                      	   331: 	mov $off_value,%edi
                      	   332: 	mov $items,%ecx
                      	   333: 	.if \arg1 = b
                      	   334: #		addr\arg3
                      	   335: 		rep
                      	   336: 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	   337: 	.endif
                      	   338: 	.if \arg1 = w
                      	   339: #		addr\arg3
                      	   340: 		rep
                      	   341: 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	   342: 	.endif
                      	   343: 	.if \arg1 = d
                      	   344: #		addr\arg3
                      	   345: 		rep
                      	   346: 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	   347: 	.endif
                      	   348: 	cmp $0,%ecx
                      	   349: 	jnz error           		# ECX must be 0
                      	   350: 	cmp $off_cmp,%edi
                      	   351: 	jnz error
                      	   352: 	mov $off_value,%edi  # reset EDI
                      	   353: 	# now switch ES:EDI with DS:ESI
                      	   354: 	mov %es,%dx
                      	   355: 	mov %ds,%cx
                      	   356: 	xchg %cx,%dx
                      	   357: 	mov %dx,%es
                      	   358: 	mov %cx,%ds
                      	   359: 	xchg %esi,%edi
                      	   360: 	# store again ES:EDI with pattern in EAX
                      	   361: 	mov $items,%ecx      	# reset ECX
                      	   362: 	.if \arg1 = b
                      	   363: #		addr\arg3
                      	   364: 		rep
                      	   365: 		stosb
                      	   366: 	.endif
                      	   367: 	.if \arg1 = w
                      	   368: #		addr\arg3
                      	   369: 		rep
                      	   370: 		stosw
                      	   371: 	.endif
                      	   372: 	.if \arg1 = d
                      	   373: #		addr\arg3
                      	   374: 		rep
                      	   375: 		stosl
                      	   376: 	.endif
                      	   377: 	mov $off_value,%edi  	# reset EDI
                      	   378: 
                      	   379: 	# COMPARE two buffers
                      	   380: 	mov $items,%ecx      # reset ECX
                      	   381: 	.if \arg1 = b
                      	   382: #		addr\arg3
                      	   383: 		repe
                      	   384: 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	   385: 	.endif
                      	   386: 	.if \arg1 = w
                      	   387: #		addr\arg3
                      	   388: 		repe
                      	   389: 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   390: 	.endif
                      	   391: 	.if \arg1 = d
                      	   392: #		addr\arg3
                      	   393: 		repe
                      	   394: 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   395: 	.endif
                      	   396: 	cmp $0,%ecx
                      	   397: 	jnz error           		# ECX must be 0
                      	   398: 	cmp $off_cmp,%esi
                      	   399: 	jne error
                      	   400: 	cmp $off_cmp,%edi
                      	   401: 	jne error
                      	   402: 	mov $off_value,%edi  # reset EDI
                      	   403: 	mov $off_value,%esi  # reset ESI
                      	   404: 
                      	   405: 	# SCAN buffer for pattern
                      	   406: 	mov $items,%ecx      # reset ECX
                      	   407: 	.if \arg1 = b
                      	   408: #		addr\arg3
                      	   409: 		repe
                      	   410: 		scasb         # SCAN first dword not equal to EAX
                      	   411: 	.endif
                      	   412: 	.if \arg1 = w
                      	   413: #		addr\arg3
                      	   414: 		repe
                      	   415: 		scasw         # SCAN first dword not equal to EAX
                      	   416: 	.endif
                      	   417: 	.if \arg1 = d
                      	   418: #		addr\arg3
                      	   419: 		repe
                      	   420: 		scasl         # SCAN first dword not equal to EAX
                      	   421: 	.endif
                      	   422: 	cmp $0,%ecx
                      	   423: 	jne error           		# ECX must be 0
                      	   424: 	cmp $off_cmp,%edi
                      	   425: 	jne error
                      	   426: 	mov $off_value,%edi  		# rewind EDI
                      	   427: 
                      	   428: 	# MOVE and COMPARE data between buffers
                      	   429: 	# first zero-fill ES:EDI so that we can compare the moved data later
                      	   430: 	mov $0,%eax
                      	   431: 	mov $items,%ecx      # reset ECX
                      	   432: 	.if \arg1 = b
                      	   433: #		addr\arg3
                      	   434: 		rep
                      	   435: 		stosb          # zero fill ES:EDI
                      	   436: 	.endif
                      	   437: 	.if \arg1 = w
                      	   438: #		addr\arg3
                      	   439: 		rep
                      	   440: 		stosw          # zero fill ES:EDI
                      	   441: 	.endif
                      	   442: 	.if \arg1 = d
                      	   443: #		addr\arg3
                      	   444: 		rep
                      	   445: 		stosl          # zero fill ES:EDI
                      	   446: 	.endif
                      	   447: 	mov $off_value,%edi  # reset EDI
                      	   448: 	mov $items,%ecx      # reset ECX
                      	   449: 	.if \arg1 = b
                      	   450: #		addr\arg3
                      	   451: 		rep
                      	   452: 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   453: 	.endif
                      	   454: 	.if \arg1 = w
                      	   455: #		addr\arg3
                      	   456: 		rep
                      	   457: 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   458: 	.endif
                      	   459: 	.if \arg1 = d
                      	   460: #		addr\arg3
                      	   461: 		rep
                      	   462: 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   463: 	.endif
                      	   464: 	cmp $0,%ecx
                      	   465: 	jne error           	# ECX must be 0
                      	   466: 	cmp $off_cmp,%esi
                      	   467: 	jne error
                      	   468: 	cmp $off_cmp,%edi
                      	   469: 	jne error
                      	   470: 	mov $items,%ecx      	# reset ECX
                      	   471: 	mov $off_value,%edi  	# reset EDI
                      	   472: 	mov $off_value,%esi  	# reset ESI
                      	   473: 	.if \arg1 = b
                      	   474: #		addr\arg3
                      	   475: 		repe
                      	   476: 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   477: 	.endif
                      	   478: 	.if \arg1 = w
                      	   479: #		addr\arg3
                      	   480: 		repe
                      	   481: 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   482: 	.endif
                      	   483: 	.if \arg1 = d
                      	   484: #		addr\arg3
                      	   485: 		repe
                      	   486: 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   487: 	.endif
                      	   488: 	cmp $0,%ecx
                      	   489: 	jne error           # ECX must be 0
                      	   490: 	cmp $off_cmp,%esi
                      	   491: 	jne error
                      	   492: 	cmp $off_cmp,%edi
                      	   493: 	jne error
                      	   494: .endm
                      	   495: 

Source: "t386.asm"
                      	   227: #-------------------------------------------------------------------------------
                      	   228: 	POST $0x04
04:00000602 B004      	     1M 	movb $0x04,%al
04:00000604 BA9001    	     2M 	movw $POST_PORT,%dx
04:00000607 EE        	     3M 	out %al,%dx
                      	   229: #-------------------------------------------------------------------------------
                      	   230: #
                      	   231: #   Test store, move, scan, and compare string data
                      	   232: #
                      	   233: .set b,0
                      	   234: .set w,1
                      	   235: .set d,2
                      	   236: 
                      	   237: 	testStringOps b,0,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if b = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if b = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if b = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 0 == 0
04:00000608 FC        	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
                      	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if b = b
04:00000609 66BFFFFF01	    46M 		mov $off_value,%edi
04:0000060E 00
04:0000060F 66BBFFFF00	    47M 		mov $off_value & off_mask,%ebx
04:00000614 00
04:00000615 B000      	    48M 		mov $0,%al
04:00000617 67268803  	    49M 		mov %al,%es:(%ebx)
04:0000061B C6C078    	    50M 		mov $value,%al
                      	    51M #		addr16
04:0000061E AA        	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
04:0000061F 67263803  	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
04:00000623 0F85881E  	    58M 		jne error
04:00000627 6681FF0000	    59M 		cmp $off_cmp,%edi
04:0000062C 0100
04:0000062E 0F857D1E  	    60M 		jne error
                      	    61M 
04:00000632 66BEFFFF01	    62M 		mov $off_value,%esi
04:00000637 00
04:00000638 66BFFFFF01	    63M 		mov $off_value,%edi
04:0000063D 00
04:0000063E 66BBFFFF00	    64M 		mov $off_value & off_mask,%ebx
04:00000643 00
04:00000644 678803    	    65M 		mov %al,%ds:(%ebx)
04:00000647 67268803  	    66M 		mov %al,%es:(%ebx)
04:0000064B 3C00      	    67M 		cmp $0,%al
04:0000064D 0F845E1E  	    68M 		je error
                      	    69M #		addr16
04:00000651 A6        	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
04:00000652 0F85591E  	    71M 		jne error
04:00000656 6681FF0000	    72M 		cmp $off_cmp,%edi
04:0000065B 0100
04:0000065D 0F854E1E  	    73M 		jne error
04:00000661 6681FE0000	    74M 		cmp $off_cmp,%esi
04:00000666 0100
04:00000668 0F85431E  	    75M 		jne error
                      	    76M 
04:0000066C 66BFFFFF01	    77M 		mov $off_value,%edi
04:00000671 00
04:00000672 C6C078    	    78M 		mov $value,%al
04:00000675 67268803  	    79M 		mov %al,%es:(%ebx)
04:00000679 3C00      	    80M 		cmp $0,%al
                      	    81M #		addr16
04:0000067B AE        	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
04:0000067C 0F852F1E  	    83M 		jne error
04:00000680 6681FF0000	    84M 		cmp $off_cmp,%edi
04:00000685 0100
04:00000687 0F85241E  	    85M 		jne error
                      	    86M 
04:0000068B 66BEFFFF01	    87M 		mov $off_value,%esi
04:00000690 00
04:00000691 66BFFFFF01	    88M 		mov $off_value,%edi
04:00000696 00
04:00000697 C6C078    	    89M 		mov $value,%al
04:0000069A 678803    	    90M 		mov %al,%ds:(%ebx)
04:0000069D B000      	    91M 		mov $0,%al
04:0000069F 67268803  	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
04:000006A3 A4        	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
04:000006A4 C6C078    	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
04:000006A7 67263803  	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
04:000006AB 0F85001E  	   101M 		jne error
04:000006AF 6681FF0000	   102M 		cmp $off_cmp,%edi
04:000006B4 0100
04:000006B6 0F85F51D  	   103M 		jne error
04:000006BA 6681FE0000	   104M 		cmp $off_cmp,%esi
04:000006BF 0100
04:000006C1 0F85EA1D  	   105M 		jne error
                      	   106M 
04:000006C5 66BEFFFF01	   107M 		mov $off_value,%esi
04:000006CA 00
04:000006CB C6C078    	   108M 		mov $value,%al
04:000006CE 67268803  	   109M 		mov %al,%es:(%ebx)
04:000006D2 6631C0    	   110M 		xor %eax,%eax
                      	   111M #		addr16
04:000006D5 AC        	   112M 		lodsb       # LOAD data from DS:ESI into EAX
04:000006D6 3C78      	   113M 		cmp $value & val_mask,%al
04:000006D8 0F85D31D  	   114M 		jne error
04:000006DC 6681FE0000	   115M 		cmp $off_cmp,%esi
04:000006E1 0100
04:000006E3 0F85C81D  	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if b = w
                      	   120M 		mov $off_value,%edi
                      	   121M 		mov $off_value & off_mask,%ebx
                      	   122M 		mov $0,%ax
                      	   123M 		mov %ax,%es:(%ebx)
                      	   124M 		mov $value,%ax
                      	   125M #		addr16
                      	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
                      	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
                      	   132M 		jne error
                      	   133M 		cmp $off_cmp,%edi
                      	   134M 		jne error
                      	   135M 
                      	   136M 		mov $off_value,%esi
                      	   137M 		mov $off_value,%edi
                      	   138M 		mov $off_value & off_mask,%ebx
                      	   139M 		mov %ax,%ds:(%ebx)
                      	   140M 		mov %ax,%es:(%ebx)
                      	   141M 		cmp $0,%ax
                      	   142M 		je error
                      	   143M #		addr16
                      	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
                      	   145M 		jne error
                      	   146M 		cmp $off_cmp,%edi
                      	   147M 		jne error
                      	   148M 		cmp $off_cmp,%esi
                      	   149M 		jne error
                      	   150M 
                      	   151M 		mov $off_value,%edi
                      	   152M 		mov $value,%ax
                      	   153M 		mov %ax,%es:(%ebx)
                      	   154M 		cmp $0,%ax
                      	   155M #		addr16
                      	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
                      	   157M 		jne error
                      	   158M 		cmp $off_cmp,%edi
                      	   159M 		jne error
                      	   160M 
                      	   161M 		mov $off_value,%esi
                      	   162M 		mov $off_value,%edi
                      	   163M 		mov $value,%ax
                      	   164M 		mov %ax,%ds:(%ebx)
                      	   165M 		mov $0,%ax
                      	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
                      	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
                      	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
                      	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
                      	   175M 		jne error
                      	   176M 		cmp $off_cmp,%edi
                      	   177M 		jne error
                      	   178M 		cmp $off_cmp,%esi
                      	   179M 		jne error
                      	   180M 
                      	   181M 		mov $off_value,%esi
                      	   182M 		mov $value,%ax
                      	   183M 		mov %ax,%es:(%ebx)
                      	   184M 		xor %eax,%eax
                      	   185M #		addr16
                      	   186M 		lodsw       # LOAD data from DS:ESI into EAX
                      	   187M 		cmp $value & val_mask,%ax
                      	   188M 		jne error
                      	   189M 		cmp $off_cmp,%esi
                      	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if b = d
                      	   194M 		mov $off_value,%edi
                      	   195M 		mov $off_value & off_mask,%ebx
                      	   196M 		mov $0,%eax
                      	   197M 		mov %eax,%es:(%ebx)
                      	   198M 		mov $value,%eax
                      	   199M #		addr16
                      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
                      	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
                      	   206M 		jne error
                      	   207M 		cmp $off_cmp,%edi
                      	   208M 		jne error
                      	   209M 
                      	   210M 		mov $off_value,%esi
                      	   211M 		mov $off_value,%edi
                      	   212M 		mov $off_value & off_mask,%ebx
                      	   213M 		mov %eax,%ds:(%ebx)
                      	   214M 		mov %eax,%es:(%ebx)
                      	   215M 		cmp $0,%eax
                      	   216M 		je error
                      	   217M #		addr16
                      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
                      	   219M 		jne error
                      	   220M 		cmp $off_cmp,%edi
                      	   221M 		jne error
                      	   222M 		cmp $off_cmp,%esi
                      	   223M 		jne error
                      	   224M 
                      	   225M 		mov $off_value,%edi
                      	   226M 		mov $value,%eax
                      	   227M 		mov %eax,%es:(%ebx)
                      	   228M 		cmp $0,%eax
                      	   229M #		addr16
                      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
                      	   231M 		jne error
                      	   232M 		cmp $off_cmp,%edi
                      	   233M 		jne error
                      	   234M 
                      	   235M 		mov $off_value,%esi
                      	   236M 		mov $off_value,%edi
                      	   237M 		mov $value,%eax
                      	   238M 		mov %eax,%ds:(%ebx)
                      	   239M 		mov $0,%eax
                      	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
                      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
                      	   243M 		mov $value,%eax
                      	   244M 		.if 16 = 16
                      	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
                      	   249M 		jne error
                      	   250M 		cmp $off_cmp,%edi
                      	   251M 		jne error
                      	   252M 		cmp $off_cmp,%esi
                      	   253M 		jne error
                      	   254M 
                      	   255M 		mov $off_value,%esi
                      	   256M 		mov $value,%eax
                      	   257M 		mov %eax,%es:(%ebx)
                      	   258M 		xor %eax,%eax
                      	   259M #		addr16
                      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
                      	   261M 		cmp $value & val_mask,%eax
                      	   262M 		jne error
                      	   263M 		cmp $off_cmp,%esi
                      	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   238: 	testStringOps w,0,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if w = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if w = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if w = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 0 == 0
04:000006E7 FC        	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
                      	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if w = b
                      	    46M 		mov $off_value,%edi
                      	    47M 		mov $off_value & off_mask,%ebx
                      	    48M 		mov $0,%al
                      	    49M 		mov %al,%es:(%ebx)
                      	    50M 		mov $value,%al
                      	    51M #		addr16
                      	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
                      	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
                      	    58M 		jne error
                      	    59M 		cmp $off_cmp,%edi
                      	    60M 		jne error
                      	    61M 
                      	    62M 		mov $off_value,%esi
                      	    63M 		mov $off_value,%edi
                      	    64M 		mov $off_value & off_mask,%ebx
                      	    65M 		mov %al,%ds:(%ebx)
                      	    66M 		mov %al,%es:(%ebx)
                      	    67M 		cmp $0,%al
                      	    68M 		je error
                      	    69M #		addr16
                      	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
                      	    71M 		jne error
                      	    72M 		cmp $off_cmp,%edi
                      	    73M 		jne error
                      	    74M 		cmp $off_cmp,%esi
                      	    75M 		jne error
                      	    76M 
                      	    77M 		mov $off_value,%edi
                      	    78M 		mov $value,%al
                      	    79M 		mov %al,%es:(%ebx)
                      	    80M 		cmp $0,%al
                      	    81M #		addr16
                      	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
                      	    83M 		jne error
                      	    84M 		cmp $off_cmp,%edi
                      	    85M 		jne error
                      	    86M 
                      	    87M 		mov $off_value,%esi
                      	    88M 		mov $off_value,%edi
                      	    89M 		mov $value,%al
                      	    90M 		mov %al,%ds:(%ebx)
                      	    91M 		mov $0,%al
                      	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
                      	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
                      	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
                      	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
                      	   101M 		jne error
                      	   102M 		cmp $off_cmp,%edi
                      	   103M 		jne error
                      	   104M 		cmp $off_cmp,%esi
                      	   105M 		jne error
                      	   106M 
                      	   107M 		mov $off_value,%esi
                      	   108M 		mov $value,%al
                      	   109M 		mov %al,%es:(%ebx)
                      	   110M 		xor %eax,%eax
                      	   111M #		addr16
                      	   112M 		lodsb       # LOAD data from DS:ESI into EAX
                      	   113M 		cmp $value & val_mask,%al
                      	   114M 		jne error
                      	   115M 		cmp $off_cmp,%esi
                      	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if w = w
04:000006E8 66BFFEFF01	   120M 		mov $off_value,%edi
04:000006ED 00
04:000006EE 66BBFEFF00	   121M 		mov $off_value & off_mask,%ebx
04:000006F3 00
04:000006F4 B80000    	   122M 		mov $0,%ax
04:000006F7 67268903  	   123M 		mov %ax,%es:(%ebx)
04:000006FB C7C07856  	   124M 		mov $value,%ax
                      	   125M #		addr16
04:000006FF AB        	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
04:00000700 67263903  	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
04:00000704 0F85A71D  	   132M 		jne error
04:00000708 6681FF0000	   133M 		cmp $off_cmp,%edi
04:0000070D 0100
04:0000070F 0F859C1D  	   134M 		jne error
                      	   135M 
04:00000713 66BEFEFF01	   136M 		mov $off_value,%esi
04:00000718 00
04:00000719 66BFFEFF01	   137M 		mov $off_value,%edi
04:0000071E 00
04:0000071F 66BBFEFF00	   138M 		mov $off_value & off_mask,%ebx
04:00000724 00
04:00000725 678903    	   139M 		mov %ax,%ds:(%ebx)
04:00000728 67268903  	   140M 		mov %ax,%es:(%ebx)
04:0000072C 83F800    	   141M 		cmp $0,%ax
04:0000072F 0F847C1D  	   142M 		je error
                      	   143M #		addr16
04:00000733 A7        	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
04:00000734 0F85771D  	   145M 		jne error
04:00000738 6681FF0000	   146M 		cmp $off_cmp,%edi
04:0000073D 0100
04:0000073F 0F856C1D  	   147M 		jne error
04:00000743 6681FE0000	   148M 		cmp $off_cmp,%esi
04:00000748 0100
04:0000074A 0F85611D  	   149M 		jne error
                      	   150M 
04:0000074E 66BFFEFF01	   151M 		mov $off_value,%edi
04:00000753 00
04:00000754 C7C07856  	   152M 		mov $value,%ax
04:00000758 67268903  	   153M 		mov %ax,%es:(%ebx)
04:0000075C 83F800    	   154M 		cmp $0,%ax
                      	   155M #		addr16
04:0000075F AF        	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
04:00000760 0F854B1D  	   157M 		jne error
04:00000764 6681FF0000	   158M 		cmp $off_cmp,%edi
04:00000769 0100
04:0000076B 0F85401D  	   159M 		jne error
                      	   160M 
04:0000076F 66BEFEFF01	   161M 		mov $off_value,%esi
04:00000774 00
04:00000775 66BFFEFF01	   162M 		mov $off_value,%edi
04:0000077A 00
04:0000077B C7C07856  	   163M 		mov $value,%ax
04:0000077F 678903    	   164M 		mov %ax,%ds:(%ebx)
04:00000782 B80000    	   165M 		mov $0,%ax
04:00000785 67268903  	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
04:00000789 A5        	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
04:0000078A C7C07856  	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
04:0000078E 67263903  	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
04:00000792 0F85191D  	   175M 		jne error
04:00000796 6681FF0000	   176M 		cmp $off_cmp,%edi
04:0000079B 0100
04:0000079D 0F850E1D  	   177M 		jne error
04:000007A1 6681FE0000	   178M 		cmp $off_cmp,%esi
04:000007A6 0100
04:000007A8 0F85031D  	   179M 		jne error
                      	   180M 
04:000007AC 66BEFEFF01	   181M 		mov $off_value,%esi
04:000007B1 00
04:000007B2 C7C07856  	   182M 		mov $value,%ax
04:000007B6 67268903  	   183M 		mov %ax,%es:(%ebx)
04:000007BA 6631C0    	   184M 		xor %eax,%eax
                      	   185M #		addr16
04:000007BD AD        	   186M 		lodsw       # LOAD data from DS:ESI into EAX
04:000007BE 3D7856    	   187M 		cmp $value & val_mask,%ax
04:000007C1 0F85EA1C  	   188M 		jne error
04:000007C5 6681FE0000	   189M 		cmp $off_cmp,%esi
04:000007CA 0100
04:000007CC 0F85DF1C  	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if w = d
                      	   194M 		mov $off_value,%edi
                      	   195M 		mov $off_value & off_mask,%ebx
                      	   196M 		mov $0,%eax
                      	   197M 		mov %eax,%es:(%ebx)
                      	   198M 		mov $value,%eax
                      	   199M #		addr16
                      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
                      	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
                      	   206M 		jne error
                      	   207M 		cmp $off_cmp,%edi
                      	   208M 		jne error
                      	   209M 
                      	   210M 		mov $off_value,%esi
                      	   211M 		mov $off_value,%edi
                      	   212M 		mov $off_value & off_mask,%ebx
                      	   213M 		mov %eax,%ds:(%ebx)
                      	   214M 		mov %eax,%es:(%ebx)
                      	   215M 		cmp $0,%eax
                      	   216M 		je error
                      	   217M #		addr16
                      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
                      	   219M 		jne error
                      	   220M 		cmp $off_cmp,%edi
                      	   221M 		jne error
                      	   222M 		cmp $off_cmp,%esi
                      	   223M 		jne error
                      	   224M 
                      	   225M 		mov $off_value,%edi
                      	   226M 		mov $value,%eax
                      	   227M 		mov %eax,%es:(%ebx)
                      	   228M 		cmp $0,%eax
                      	   229M #		addr16
                      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
                      	   231M 		jne error
                      	   232M 		cmp $off_cmp,%edi
                      	   233M 		jne error
                      	   234M 
                      	   235M 		mov $off_value,%esi
                      	   236M 		mov $off_value,%edi
                      	   237M 		mov $value,%eax
                      	   238M 		mov %eax,%ds:(%ebx)
                      	   239M 		mov $0,%eax
                      	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
                      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
                      	   243M 		mov $value,%eax
                      	   244M 		.if 16 = 16
                      	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
                      	   249M 		jne error
                      	   250M 		cmp $off_cmp,%edi
                      	   251M 		jne error
                      	   252M 		cmp $off_cmp,%esi
                      	   253M 		jne error
                      	   254M 
                      	   255M 		mov $off_value,%esi
                      	   256M 		mov $value,%eax
                      	   257M 		mov %eax,%es:(%ebx)
                      	   258M 		xor %eax,%eax
                      	   259M #		addr16
                      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
                      	   261M 		cmp $value & val_mask,%eax
                      	   262M 		jne error
                      	   263M 		cmp $off_cmp,%esi
                      	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   239: 	testStringOps d,0,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if d = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if d = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if d = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 0 == 0
04:000007D0 FC        	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
                      	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if d = b
                      	    46M 		mov $off_value,%edi
                      	    47M 		mov $off_value & off_mask,%ebx
                      	    48M 		mov $0,%al
                      	    49M 		mov %al,%es:(%ebx)
                      	    50M 		mov $value,%al
                      	    51M #		addr16
                      	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
                      	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
                      	    58M 		jne error
                      	    59M 		cmp $off_cmp,%edi
                      	    60M 		jne error
                      	    61M 
                      	    62M 		mov $off_value,%esi
                      	    63M 		mov $off_value,%edi
                      	    64M 		mov $off_value & off_mask,%ebx
                      	    65M 		mov %al,%ds:(%ebx)
                      	    66M 		mov %al,%es:(%ebx)
                      	    67M 		cmp $0,%al
                      	    68M 		je error
                      	    69M #		addr16
                      	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
                      	    71M 		jne error
                      	    72M 		cmp $off_cmp,%edi
                      	    73M 		jne error
                      	    74M 		cmp $off_cmp,%esi
                      	    75M 		jne error
                      	    76M 
                      	    77M 		mov $off_value,%edi
                      	    78M 		mov $value,%al
                      	    79M 		mov %al,%es:(%ebx)
                      	    80M 		cmp $0,%al
                      	    81M #		addr16
                      	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
                      	    83M 		jne error
                      	    84M 		cmp $off_cmp,%edi
                      	    85M 		jne error
                      	    86M 
                      	    87M 		mov $off_value,%esi
                      	    88M 		mov $off_value,%edi
                      	    89M 		mov $value,%al
                      	    90M 		mov %al,%ds:(%ebx)
                      	    91M 		mov $0,%al
                      	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
                      	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
                      	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
                      	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
                      	   101M 		jne error
                      	   102M 		cmp $off_cmp,%edi
                      	   103M 		jne error
                      	   104M 		cmp $off_cmp,%esi
                      	   105M 		jne error
                      	   106M 
                      	   107M 		mov $off_value,%esi
                      	   108M 		mov $value,%al
                      	   109M 		mov %al,%es:(%ebx)
                      	   110M 		xor %eax,%eax
                      	   111M #		addr16
                      	   112M 		lodsb       # LOAD data from DS:ESI into EAX
                      	   113M 		cmp $value & val_mask,%al
                      	   114M 		jne error
                      	   115M 		cmp $off_cmp,%esi
                      	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if d = w
                      	   120M 		mov $off_value,%edi
                      	   121M 		mov $off_value & off_mask,%ebx
                      	   122M 		mov $0,%ax
                      	   123M 		mov %ax,%es:(%ebx)
                      	   124M 		mov $value,%ax
                      	   125M #		addr16
                      	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
                      	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
                      	   132M 		jne error
                      	   133M 		cmp $off_cmp,%edi
                      	   134M 		jne error
                      	   135M 
                      	   136M 		mov $off_value,%esi
                      	   137M 		mov $off_value,%edi
                      	   138M 		mov $off_value & off_mask,%ebx
                      	   139M 		mov %ax,%ds:(%ebx)
                      	   140M 		mov %ax,%es:(%ebx)
                      	   141M 		cmp $0,%ax
                      	   142M 		je error
                      	   143M #		addr16
                      	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
                      	   145M 		jne error
                      	   146M 		cmp $off_cmp,%edi
                      	   147M 		jne error
                      	   148M 		cmp $off_cmp,%esi
                      	   149M 		jne error
                      	   150M 
                      	   151M 		mov $off_value,%edi
                      	   152M 		mov $value,%ax
                      	   153M 		mov %ax,%es:(%ebx)
                      	   154M 		cmp $0,%ax
                      	   155M #		addr16
                      	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
                      	   157M 		jne error
                      	   158M 		cmp $off_cmp,%edi
                      	   159M 		jne error
                      	   160M 
                      	   161M 		mov $off_value,%esi
                      	   162M 		mov $off_value,%edi
                      	   163M 		mov $value,%ax
                      	   164M 		mov %ax,%ds:(%ebx)
                      	   165M 		mov $0,%ax
                      	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
                      	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
                      	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
                      	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
                      	   175M 		jne error
                      	   176M 		cmp $off_cmp,%edi
                      	   177M 		jne error
                      	   178M 		cmp $off_cmp,%esi
                      	   179M 		jne error
                      	   180M 
                      	   181M 		mov $off_value,%esi
                      	   182M 		mov $value,%ax
                      	   183M 		mov %ax,%es:(%ebx)
                      	   184M 		xor %eax,%eax
                      	   185M #		addr16
                      	   186M 		lodsw       # LOAD data from DS:ESI into EAX
                      	   187M 		cmp $value & val_mask,%ax
                      	   188M 		jne error
                      	   189M 		cmp $off_cmp,%esi
                      	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if d = d
04:000007D1 66BFFCFF01	   194M 		mov $off_value,%edi
04:000007D6 00
04:000007D7 66BBFCFF00	   195M 		mov $off_value & off_mask,%ebx
04:000007DC 00
04:000007DD 66B8000000	   196M 		mov $0,%eax
04:000007E2 00
04:000007E3 6766268903	   197M 		mov %eax,%es:(%ebx)
04:000007E8 66B8785634	   198M 		mov $value,%eax
04:000007ED 12
                      	   199M #		addr16
04:000007EE 66AB      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
04:000007F0 6766263903	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
04:000007F5 0F85B61C  	   206M 		jne error
04:000007F9 6681FF0000	   207M 		cmp $off_cmp,%edi
04:000007FE 0100
04:00000800 0F85AB1C  	   208M 		jne error
                      	   209M 
04:00000804 66BEFCFF01	   210M 		mov $off_value,%esi
04:00000809 00
04:0000080A 66BFFCFF01	   211M 		mov $off_value,%edi
04:0000080F 00
04:00000810 66BBFCFF00	   212M 		mov $off_value & off_mask,%ebx
04:00000815 00
04:00000816 67668903  	   213M 		mov %eax,%ds:(%ebx)
04:0000081A 6766268903	   214M 		mov %eax,%es:(%ebx)
04:0000081F 6683F800  	   215M 		cmp $0,%eax
04:00000823 0F84881C  	   216M 		je error
                      	   217M #		addr16
04:00000827 66A7      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
04:00000829 0F85821C  	   219M 		jne error
04:0000082D 6681FF0000	   220M 		cmp $off_cmp,%edi
04:00000832 0100
04:00000834 0F85771C  	   221M 		jne error
04:00000838 6681FE0000	   222M 		cmp $off_cmp,%esi
04:0000083D 0100
04:0000083F 0F856C1C  	   223M 		jne error
                      	   224M 
04:00000843 66BFFCFF01	   225M 		mov $off_value,%edi
04:00000848 00
04:00000849 66B8785634	   226M 		mov $value,%eax
04:0000084E 12
04:0000084F 6766268903	   227M 		mov %eax,%es:(%ebx)
04:00000854 6683F800  	   228M 		cmp $0,%eax
                      	   229M #		addr16
04:00000858 66AF      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
04:0000085A 0F85511C  	   231M 		jne error
04:0000085E 6681FF0000	   232M 		cmp $off_cmp,%edi
04:00000863 0100
04:00000865 0F85461C  	   233M 		jne error
                      	   234M 
04:00000869 66BEFCFF01	   235M 		mov $off_value,%esi
04:0000086E 00
04:0000086F 66BFFCFF01	   236M 		mov $off_value,%edi
04:00000874 00
04:00000875 66B8785634	   237M 		mov $value,%eax
04:0000087A 12
04:0000087B 67668903  	   238M 		mov %eax,%ds:(%ebx)
04:0000087F 66B8000000	   239M 		mov $0,%eax
04:00000884 00
04:00000885 6766268903	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
04:0000088A 66A5      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
04:0000088C 66B8785634	   243M 		mov $value,%eax
04:00000891 12
                      	   244M 		.if 16 = 16
04:00000892 6766263903	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
04:00000897 0F85141C  	   249M 		jne error
04:0000089B 6681FF0000	   250M 		cmp $off_cmp,%edi
04:000008A0 0100
04:000008A2 0F85091C  	   251M 		jne error
04:000008A6 6681FE0000	   252M 		cmp $off_cmp,%esi
04:000008AB 0100
04:000008AD 0F85FE1B  	   253M 		jne error
                      	   254M 
04:000008B1 66BEFCFF01	   255M 		mov $off_value,%esi
04:000008B6 00
04:000008B7 66B8785634	   256M 		mov $value,%eax
04:000008BC 12
04:000008BD 6766268903	   257M 		mov %eax,%es:(%ebx)
04:000008C2 6631C0    	   258M 		xor %eax,%eax
                      	   259M #		addr16
04:000008C5 66AD      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
04:000008C7 663D785634	   261M 		cmp $value & val_mask,%eax
04:000008CC 12
04:000008CD 0F85DE1B  	   262M 		jne error
04:000008D1 6681FE0000	   263M 		cmp $off_cmp,%esi
04:000008D6 0100
04:000008D8 0F85D31B  	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   240: 	testStringOps b,1,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if b = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if b = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if b = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 1 == 0
                      	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
04:000008DC FD        	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if b = b
04:000008DD 66BF000001	    46M 		mov $off_value,%edi
04:000008E2 00
04:000008E3 66BB000000	    47M 		mov $off_value & off_mask,%ebx
04:000008E8 00
04:000008E9 B000      	    48M 		mov $0,%al
04:000008EB 67268803  	    49M 		mov %al,%es:(%ebx)
04:000008EF C6C078    	    50M 		mov $value,%al
                      	    51M #		addr16
04:000008F2 AA        	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
04:000008F3 67263803  	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
04:000008F7 0F85B41B  	    58M 		jne error
04:000008FB 6681FFFFFF	    59M 		cmp $off_cmp,%edi
04:00000900 0100
04:00000902 0F85A91B  	    60M 		jne error
                      	    61M 
04:00000906 66BE000001	    62M 		mov $off_value,%esi
04:0000090B 00
04:0000090C 66BF000001	    63M 		mov $off_value,%edi
04:00000911 00
04:00000912 66BB000000	    64M 		mov $off_value & off_mask,%ebx
04:00000917 00
04:00000918 678803    	    65M 		mov %al,%ds:(%ebx)
04:0000091B 67268803  	    66M 		mov %al,%es:(%ebx)
04:0000091F 3C00      	    67M 		cmp $0,%al
04:00000921 0F848A1B  	    68M 		je error
                      	    69M #		addr16
04:00000925 A6        	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
04:00000926 0F85851B  	    71M 		jne error
04:0000092A 6681FFFFFF	    72M 		cmp $off_cmp,%edi
04:0000092F 0100
04:00000931 0F857A1B  	    73M 		jne error
04:00000935 6681FEFFFF	    74M 		cmp $off_cmp,%esi
04:0000093A 0100
04:0000093C 0F856F1B  	    75M 		jne error
                      	    76M 
04:00000940 66BF000001	    77M 		mov $off_value,%edi
04:00000945 00
04:00000946 C6C078    	    78M 		mov $value,%al
04:00000949 67268803  	    79M 		mov %al,%es:(%ebx)
04:0000094D 3C00      	    80M 		cmp $0,%al
                      	    81M #		addr16
04:0000094F AE        	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
04:00000950 0F855B1B  	    83M 		jne error
04:00000954 6681FFFFFF	    84M 		cmp $off_cmp,%edi
04:00000959 0100
04:0000095B 0F85501B  	    85M 		jne error
                      	    86M 
04:0000095F 66BE000001	    87M 		mov $off_value,%esi
04:00000964 00
04:00000965 66BF000001	    88M 		mov $off_value,%edi
04:0000096A 00
04:0000096B C6C078    	    89M 		mov $value,%al
04:0000096E 678803    	    90M 		mov %al,%ds:(%ebx)
04:00000971 B000      	    91M 		mov $0,%al
04:00000973 67268803  	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
04:00000977 A4        	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
04:00000978 C6C078    	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
04:0000097B 67263803  	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
04:0000097F 0F852C1B  	   101M 		jne error
04:00000983 6681FFFFFF	   102M 		cmp $off_cmp,%edi
04:00000988 0100
04:0000098A 0F85211B  	   103M 		jne error
04:0000098E 6681FEFFFF	   104M 		cmp $off_cmp,%esi
04:00000993 0100
04:00000995 0F85161B  	   105M 		jne error
                      	   106M 
04:00000999 66BE000001	   107M 		mov $off_value,%esi
04:0000099E 00
04:0000099F C6C078    	   108M 		mov $value,%al
04:000009A2 67268803  	   109M 		mov %al,%es:(%ebx)
04:000009A6 6631C0    	   110M 		xor %eax,%eax
                      	   111M #		addr16
04:000009A9 AC        	   112M 		lodsb       # LOAD data from DS:ESI into EAX
04:000009AA 3C78      	   113M 		cmp $value & val_mask,%al
04:000009AC 0F85FF1A  	   114M 		jne error
04:000009B0 6681FEFFFF	   115M 		cmp $off_cmp,%esi
04:000009B5 0100
04:000009B7 0F85F41A  	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if b = w
                      	   120M 		mov $off_value,%edi
                      	   121M 		mov $off_value & off_mask,%ebx
                      	   122M 		mov $0,%ax
                      	   123M 		mov %ax,%es:(%ebx)
                      	   124M 		mov $value,%ax
                      	   125M #		addr16
                      	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
                      	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
                      	   132M 		jne error
                      	   133M 		cmp $off_cmp,%edi
                      	   134M 		jne error
                      	   135M 
                      	   136M 		mov $off_value,%esi
                      	   137M 		mov $off_value,%edi
                      	   138M 		mov $off_value & off_mask,%ebx
                      	   139M 		mov %ax,%ds:(%ebx)
                      	   140M 		mov %ax,%es:(%ebx)
                      	   141M 		cmp $0,%ax
                      	   142M 		je error
                      	   143M #		addr16
                      	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
                      	   145M 		jne error
                      	   146M 		cmp $off_cmp,%edi
                      	   147M 		jne error
                      	   148M 		cmp $off_cmp,%esi
                      	   149M 		jne error
                      	   150M 
                      	   151M 		mov $off_value,%edi
                      	   152M 		mov $value,%ax
                      	   153M 		mov %ax,%es:(%ebx)
                      	   154M 		cmp $0,%ax
                      	   155M #		addr16
                      	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
                      	   157M 		jne error
                      	   158M 		cmp $off_cmp,%edi
                      	   159M 		jne error
                      	   160M 
                      	   161M 		mov $off_value,%esi
                      	   162M 		mov $off_value,%edi
                      	   163M 		mov $value,%ax
                      	   164M 		mov %ax,%ds:(%ebx)
                      	   165M 		mov $0,%ax
                      	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
                      	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
                      	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
                      	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
                      	   175M 		jne error
                      	   176M 		cmp $off_cmp,%edi
                      	   177M 		jne error
                      	   178M 		cmp $off_cmp,%esi
                      	   179M 		jne error
                      	   180M 
                      	   181M 		mov $off_value,%esi
                      	   182M 		mov $value,%ax
                      	   183M 		mov %ax,%es:(%ebx)
                      	   184M 		xor %eax,%eax
                      	   185M #		addr16
                      	   186M 		lodsw       # LOAD data from DS:ESI into EAX
                      	   187M 		cmp $value & val_mask,%ax
                      	   188M 		jne error
                      	   189M 		cmp $off_cmp,%esi
                      	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if b = d
                      	   194M 		mov $off_value,%edi
                      	   195M 		mov $off_value & off_mask,%ebx
                      	   196M 		mov $0,%eax
                      	   197M 		mov %eax,%es:(%ebx)
                      	   198M 		mov $value,%eax
                      	   199M #		addr16
                      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
                      	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
                      	   206M 		jne error
                      	   207M 		cmp $off_cmp,%edi
                      	   208M 		jne error
                      	   209M 
                      	   210M 		mov $off_value,%esi
                      	   211M 		mov $off_value,%edi
                      	   212M 		mov $off_value & off_mask,%ebx
                      	   213M 		mov %eax,%ds:(%ebx)
                      	   214M 		mov %eax,%es:(%ebx)
                      	   215M 		cmp $0,%eax
                      	   216M 		je error
                      	   217M #		addr16
                      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
                      	   219M 		jne error
                      	   220M 		cmp $off_cmp,%edi
                      	   221M 		jne error
                      	   222M 		cmp $off_cmp,%esi
                      	   223M 		jne error
                      	   224M 
                      	   225M 		mov $off_value,%edi
                      	   226M 		mov $value,%eax
                      	   227M 		mov %eax,%es:(%ebx)
                      	   228M 		cmp $0,%eax
                      	   229M #		addr16
                      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
                      	   231M 		jne error
                      	   232M 		cmp $off_cmp,%edi
                      	   233M 		jne error
                      	   234M 
                      	   235M 		mov $off_value,%esi
                      	   236M 		mov $off_value,%edi
                      	   237M 		mov $value,%eax
                      	   238M 		mov %eax,%ds:(%ebx)
                      	   239M 		mov $0,%eax
                      	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
                      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
                      	   243M 		mov $value,%eax
                      	   244M 		.if 16 = 16
                      	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
                      	   249M 		jne error
                      	   250M 		cmp $off_cmp,%edi
                      	   251M 		jne error
                      	   252M 		cmp $off_cmp,%esi
                      	   253M 		jne error
                      	   254M 
                      	   255M 		mov $off_value,%esi
                      	   256M 		mov $value,%eax
                      	   257M 		mov %eax,%es:(%ebx)
                      	   258M 		xor %eax,%eax
                      	   259M #		addr16
                      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
                      	   261M 		cmp $value & val_mask,%eax
                      	   262M 		jne error
                      	   263M 		cmp $off_cmp,%esi
                      	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   241: 	testStringOps w,1,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if w = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if w = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if w = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 1 == 0
                      	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
04:000009BB FD        	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if w = b
                      	    46M 		mov $off_value,%edi
                      	    47M 		mov $off_value & off_mask,%ebx
                      	    48M 		mov $0,%al
                      	    49M 		mov %al,%es:(%ebx)
                      	    50M 		mov $value,%al
                      	    51M #		addr16
                      	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
                      	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
                      	    58M 		jne error
                      	    59M 		cmp $off_cmp,%edi
                      	    60M 		jne error
                      	    61M 
                      	    62M 		mov $off_value,%esi
                      	    63M 		mov $off_value,%edi
                      	    64M 		mov $off_value & off_mask,%ebx
                      	    65M 		mov %al,%ds:(%ebx)
                      	    66M 		mov %al,%es:(%ebx)
                      	    67M 		cmp $0,%al
                      	    68M 		je error
                      	    69M #		addr16
                      	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
                      	    71M 		jne error
                      	    72M 		cmp $off_cmp,%edi
                      	    73M 		jne error
                      	    74M 		cmp $off_cmp,%esi
                      	    75M 		jne error
                      	    76M 
                      	    77M 		mov $off_value,%edi
                      	    78M 		mov $value,%al
                      	    79M 		mov %al,%es:(%ebx)
                      	    80M 		cmp $0,%al
                      	    81M #		addr16
                      	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
                      	    83M 		jne error
                      	    84M 		cmp $off_cmp,%edi
                      	    85M 		jne error
                      	    86M 
                      	    87M 		mov $off_value,%esi
                      	    88M 		mov $off_value,%edi
                      	    89M 		mov $value,%al
                      	    90M 		mov %al,%ds:(%ebx)
                      	    91M 		mov $0,%al
                      	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
                      	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
                      	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
                      	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
                      	   101M 		jne error
                      	   102M 		cmp $off_cmp,%edi
                      	   103M 		jne error
                      	   104M 		cmp $off_cmp,%esi
                      	   105M 		jne error
                      	   106M 
                      	   107M 		mov $off_value,%esi
                      	   108M 		mov $value,%al
                      	   109M 		mov %al,%es:(%ebx)
                      	   110M 		xor %eax,%eax
                      	   111M #		addr16
                      	   112M 		lodsb       # LOAD data from DS:ESI into EAX
                      	   113M 		cmp $value & val_mask,%al
                      	   114M 		jne error
                      	   115M 		cmp $off_cmp,%esi
                      	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if w = w
04:000009BC 66BF000001	   120M 		mov $off_value,%edi
04:000009C1 00
04:000009C2 66BB000000	   121M 		mov $off_value & off_mask,%ebx
04:000009C7 00
04:000009C8 B80000    	   122M 		mov $0,%ax
04:000009CB 67268903  	   123M 		mov %ax,%es:(%ebx)
04:000009CF C7C07856  	   124M 		mov $value,%ax
                      	   125M #		addr16
04:000009D3 AB        	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
04:000009D4 67263903  	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
04:000009D8 0F85D31A  	   132M 		jne error
04:000009DC 6681FFFEFF	   133M 		cmp $off_cmp,%edi
04:000009E1 0100
04:000009E3 0F85C81A  	   134M 		jne error
                      	   135M 
04:000009E7 66BE000001	   136M 		mov $off_value,%esi
04:000009EC 00
04:000009ED 66BF000001	   137M 		mov $off_value,%edi
04:000009F2 00
04:000009F3 66BB000000	   138M 		mov $off_value & off_mask,%ebx
04:000009F8 00
04:000009F9 678903    	   139M 		mov %ax,%ds:(%ebx)
04:000009FC 67268903  	   140M 		mov %ax,%es:(%ebx)
04:00000A00 83F800    	   141M 		cmp $0,%ax
04:00000A03 0F84A81A  	   142M 		je error
                      	   143M #		addr16
04:00000A07 A7        	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
04:00000A08 0F85A31A  	   145M 		jne error
04:00000A0C 6681FFFEFF	   146M 		cmp $off_cmp,%edi
04:00000A11 0100
04:00000A13 0F85981A  	   147M 		jne error
04:00000A17 6681FEFEFF	   148M 		cmp $off_cmp,%esi
04:00000A1C 0100
04:00000A1E 0F858D1A  	   149M 		jne error
                      	   150M 
04:00000A22 66BF000001	   151M 		mov $off_value,%edi
04:00000A27 00
04:00000A28 C7C07856  	   152M 		mov $value,%ax
04:00000A2C 67268903  	   153M 		mov %ax,%es:(%ebx)
04:00000A30 83F800    	   154M 		cmp $0,%ax
                      	   155M #		addr16
04:00000A33 AF        	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
04:00000A34 0F85771A  	   157M 		jne error
04:00000A38 6681FFFEFF	   158M 		cmp $off_cmp,%edi
04:00000A3D 0100
04:00000A3F 0F856C1A  	   159M 		jne error
                      	   160M 
04:00000A43 66BE000001	   161M 		mov $off_value,%esi
04:00000A48 00
04:00000A49 66BF000001	   162M 		mov $off_value,%edi
04:00000A4E 00
04:00000A4F C7C07856  	   163M 		mov $value,%ax
04:00000A53 678903    	   164M 		mov %ax,%ds:(%ebx)
04:00000A56 B80000    	   165M 		mov $0,%ax
04:00000A59 67268903  	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
04:00000A5D A5        	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
04:00000A5E C7C07856  	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
04:00000A62 67263903  	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
04:00000A66 0F85451A  	   175M 		jne error
04:00000A6A 6681FFFEFF	   176M 		cmp $off_cmp,%edi
04:00000A6F 0100
04:00000A71 0F853A1A  	   177M 		jne error
04:00000A75 6681FEFEFF	   178M 		cmp $off_cmp,%esi
04:00000A7A 0100
04:00000A7C 0F852F1A  	   179M 		jne error
                      	   180M 
04:00000A80 66BE000001	   181M 		mov $off_value,%esi
04:00000A85 00
04:00000A86 C7C07856  	   182M 		mov $value,%ax
04:00000A8A 67268903  	   183M 		mov %ax,%es:(%ebx)
04:00000A8E 6631C0    	   184M 		xor %eax,%eax
                      	   185M #		addr16
04:00000A91 AD        	   186M 		lodsw       # LOAD data from DS:ESI into EAX
04:00000A92 3D7856    	   187M 		cmp $value & val_mask,%ax
04:00000A95 0F85161A  	   188M 		jne error
04:00000A99 6681FEFEFF	   189M 		cmp $off_cmp,%esi
04:00000A9E 0100
04:00000AA0 0F850B1A  	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if w = d
                      	   194M 		mov $off_value,%edi
                      	   195M 		mov $off_value & off_mask,%ebx
                      	   196M 		mov $0,%eax
                      	   197M 		mov %eax,%es:(%ebx)
                      	   198M 		mov $value,%eax
                      	   199M #		addr16
                      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
                      	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
                      	   206M 		jne error
                      	   207M 		cmp $off_cmp,%edi
                      	   208M 		jne error
                      	   209M 
                      	   210M 		mov $off_value,%esi
                      	   211M 		mov $off_value,%edi
                      	   212M 		mov $off_value & off_mask,%ebx
                      	   213M 		mov %eax,%ds:(%ebx)
                      	   214M 		mov %eax,%es:(%ebx)
                      	   215M 		cmp $0,%eax
                      	   216M 		je error
                      	   217M #		addr16
                      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
                      	   219M 		jne error
                      	   220M 		cmp $off_cmp,%edi
                      	   221M 		jne error
                      	   222M 		cmp $off_cmp,%esi
                      	   223M 		jne error
                      	   224M 
                      	   225M 		mov $off_value,%edi
                      	   226M 		mov $value,%eax
                      	   227M 		mov %eax,%es:(%ebx)
                      	   228M 		cmp $0,%eax
                      	   229M #		addr16
                      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
                      	   231M 		jne error
                      	   232M 		cmp $off_cmp,%edi
                      	   233M 		jne error
                      	   234M 
                      	   235M 		mov $off_value,%esi
                      	   236M 		mov $off_value,%edi
                      	   237M 		mov $value,%eax
                      	   238M 		mov %eax,%ds:(%ebx)
                      	   239M 		mov $0,%eax
                      	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
                      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
                      	   243M 		mov $value,%eax
                      	   244M 		.if 16 = 16
                      	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
                      	   249M 		jne error
                      	   250M 		cmp $off_cmp,%edi
                      	   251M 		jne error
                      	   252M 		cmp $off_cmp,%esi
                      	   253M 		jne error
                      	   254M 
                      	   255M 		mov $off_value,%esi
                      	   256M 		mov $value,%eax
                      	   257M 		mov %eax,%es:(%ebx)
                      	   258M 		xor %eax,%eax
                      	   259M #		addr16
                      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
                      	   261M 		cmp $value & val_mask,%eax
                      	   262M 		jne error
                      	   263M 		cmp $off_cmp,%esi
                      	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   242: 	testStringOps d,1,16
                      	     1M 
                      	     2M 	.set value,0x12345678
                      	     3M 	.if d = b
                      	     4M 		.set val_size,1
                      	     5M 		.set val_mask,0x000000ff
                      	     6M 	.endif
                      	     7M 	.if d = w
                      	     8M 		.set val_size,2
                      	     9M 		.set val_mask,0x0000ffff
                      	    10M 	.endif
                      	    11M 	.if d = d
                      	    12M 		.set val_size,4
                      	    13M 		.set val_mask,0xffffffff
                      	    14M 	.endif
                      	    15M 
                      	    16M 	.if 1 == 0
                      	    17M 		cld
                      	    18M 		.set off_value,0x0001ffff-(val_size-1)
                      	    19M 		.if 16 = 16
                      	    20M 			# 16-bit addressing
                      	    21M 			.set off_cmp,0x00010000
                      	    22M 		.else
                      	    23M 			# 32-bit addressing
                      	    24M 			.set off_cmp,0x00020000
                      	    25M 		.endif
                      	    26M 	.else
04:00000AA4 FD        	    27M 		std
                      	    28M 		.set off_value,0x00010000
                      	    29M 		.if 16 = 16
                      	    30M 			# 16-bit addressing
                      	    31M 			.set off_cmp,0x0001ffff-(val_size-1)
                      	    32M 		.else
                      	    33M 			# 32-bit addressing
                      	    34M 			.set off_cmp,0x0000ffff-(val_size-1)
                      	    35M 		.endif
                      	    36M 	.endif
                      	    37M 
                      	    38M 	.if 16 = 16
                      	    39M 		.set off_mask,0x0000ffff
                      	    40M 	.else
                      	    41M 		.set off_mask,0xffffffff
                      	    42M 	.endif
                      	    43M 
                      	    44M 	# VERIFY string operands
                      	    45M 	.if d = b
                      	    46M 		mov $off_value,%edi
                      	    47M 		mov $off_value & off_mask,%ebx
                      	    48M 		mov $0,%al
                      	    49M 		mov %al,%es:(%ebx)
                      	    50M 		mov $value,%al
                      	    51M #		addr16
                      	    52M 		stosb		 	# STORE EAX in ES:EDI
                      	    53M 		.if 16 = 16
                      	    54M 			cmp %al,%es:(%ebx)
                      	    55M 		.else
                      	    56M 			cmp %al,%es:(%ebx)
                      	    57M 		.endif
                      	    58M 		jne error
                      	    59M 		cmp $off_cmp,%edi
                      	    60M 		jne error
                      	    61M 
                      	    62M 		mov $off_value,%esi
                      	    63M 		mov $off_value,%edi
                      	    64M 		mov $off_value & off_mask,%ebx
                      	    65M 		mov %al,%ds:(%ebx)
                      	    66M 		mov %al,%es:(%ebx)
                      	    67M 		cmp $0,%al
                      	    68M 		je error
                      	    69M #		addr16
                      	    70M 		cmpsb     # COMPARE ES:EDI with DS:ESI
                      	    71M 		jne error
                      	    72M 		cmp $off_cmp,%edi
                      	    73M 		jne error
                      	    74M 		cmp $off_cmp,%esi
                      	    75M 		jne error
                      	    76M 
                      	    77M 		mov $off_value,%edi
                      	    78M 		mov $value,%al
                      	    79M 		mov %al,%es:(%ebx)
                      	    80M 		cmp $0,%al
                      	    81M #		addr16
                      	    82M 		scasb     # SCAN/COMPARE ES:EDI with EAX
                      	    83M 		jne error
                      	    84M 		cmp $off_cmp,%edi
                      	    85M 		jne error
                      	    86M 
                      	    87M 		mov $off_value,%esi
                      	    88M 		mov $off_value,%edi
                      	    89M 		mov $value,%al
                      	    90M 		mov %al,%ds:(%ebx)
                      	    91M 		mov $0,%al
                      	    92M 		mov %al,%es:(%ebx)
                      	    93M #		addr16
                      	    94M 		movsb        # MOVE data from DS:ESI to ES:EDI
                      	    95M 		mov $value,%al
                      	    96M 		.if 16 = 16
                      	    97M 			cmp %al,%es:(%ebx)
                      	    98M 		.else
                      	    99M 			cmp %al,%es:(%ebx)
                      	   100M 		.endif
                      	   101M 		jne error
                      	   102M 		cmp $off_cmp,%edi
                      	   103M 		jne error
                      	   104M 		cmp $off_cmp,%esi
                      	   105M 		jne error
                      	   106M 
                      	   107M 		mov $off_value,%esi
                      	   108M 		mov $value,%al
                      	   109M 		mov %al,%es:(%ebx)
                      	   110M 		xor %eax,%eax
                      	   111M #		addr16
                      	   112M 		lodsb       # LOAD data from DS:ESI into EAX
                      	   113M 		cmp $value & val_mask,%al
                      	   114M 		jne error
                      	   115M 		cmp $off_cmp,%esi
                      	   116M 		jne error
                      	   117M 	.endif
                      	   118M 
                      	   119M 	.if d = w
                      	   120M 		mov $off_value,%edi
                      	   121M 		mov $off_value & off_mask,%ebx
                      	   122M 		mov $0,%ax
                      	   123M 		mov %ax,%es:(%ebx)
                      	   124M 		mov $value,%ax
                      	   125M #		addr16
                      	   126M 		stosw     # STORE EAX in ES:EDI
                      	   127M 		.if 16 = 16
                      	   128M 			cmp %ax,%es:(%ebx)
                      	   129M 		.else
                      	   130M 			cmp %ax,%es:(%ebx)
                      	   131M 		.endif
                      	   132M 		jne error
                      	   133M 		cmp $off_cmp,%edi
                      	   134M 		jne error
                      	   135M 
                      	   136M 		mov $off_value,%esi
                      	   137M 		mov $off_value,%edi
                      	   138M 		mov $off_value & off_mask,%ebx
                      	   139M 		mov %ax,%ds:(%ebx)
                      	   140M 		mov %ax,%es:(%ebx)
                      	   141M 		cmp $0,%ax
                      	   142M 		je error
                      	   143M #		addr16
                      	   144M 		cmpsw     # COMPARE ES:EDI with DS:ESI
                      	   145M 		jne error
                      	   146M 		cmp $off_cmp,%edi
                      	   147M 		jne error
                      	   148M 		cmp $off_cmp,%esi
                      	   149M 		jne error
                      	   150M 
                      	   151M 		mov $off_value,%edi
                      	   152M 		mov $value,%ax
                      	   153M 		mov %ax,%es:(%ebx)
                      	   154M 		cmp $0,%ax
                      	   155M #		addr16
                      	   156M 		scasw     # SCAN/COMPARE ES:EDI with EAX
                      	   157M 		jne error
                      	   158M 		cmp $off_cmp,%edi
                      	   159M 		jne error
                      	   160M 
                      	   161M 		mov $off_value,%esi
                      	   162M 		mov $off_value,%edi
                      	   163M 		mov $value,%ax
                      	   164M 		mov %ax,%ds:(%ebx)
                      	   165M 		mov $0,%ax
                      	   166M 		mov %ax,%es:(%ebx)
                      	   167M #		addr16
                      	   168M 		movsw 					# MOVE data from DS:ESI to ES:EDI
                      	   169M 		mov $value,%ax
                      	   170M 		.if 16 = 16
                      	   171M 			cmp %ax,%es:(%ebx)
                      	   172M 		.else
                      	   173M 			cmp %ax,%es:(%ebx)
                      	   174M 		.endif
                      	   175M 		jne error
                      	   176M 		cmp $off_cmp,%edi
                      	   177M 		jne error
                      	   178M 		cmp $off_cmp,%esi
                      	   179M 		jne error
                      	   180M 
                      	   181M 		mov $off_value,%esi
                      	   182M 		mov $value,%ax
                      	   183M 		mov %ax,%es:(%ebx)
                      	   184M 		xor %eax,%eax
                      	   185M #		addr16
                      	   186M 		lodsw       # LOAD data from DS:ESI into EAX
                      	   187M 		cmp $value & val_mask,%ax
                      	   188M 		jne error
                      	   189M 		cmp $off_cmp,%esi
                      	   190M 		jne error
                      	   191M 	.endif
                      	   192M 
                      	   193M 	.if d = d
04:00000AA5 66BF000001	   194M 		mov $off_value,%edi
04:00000AAA 00
04:00000AAB 66BB000000	   195M 		mov $off_value & off_mask,%ebx
04:00000AB0 00
04:00000AB1 66B8000000	   196M 		mov $0,%eax
04:00000AB6 00
04:00000AB7 6766268903	   197M 		mov %eax,%es:(%ebx)
04:00000ABC 66B8785634	   198M 		mov $value,%eax
04:00000AC1 12
                      	   199M #		addr16
04:00000AC2 66AB      	   200M 		stosl     # STORE EAX in ES:EDI
                      	   201M 		.if 16 = 16
04:00000AC4 6766263903	   202M 			cmp %eax,%es:(%ebx)
                      	   203M 		.else
                      	   204M 			cmp %eax,%es:(%ebx)
                      	   205M 		.endif
04:00000AC9 0F85E219  	   206M 		jne error
04:00000ACD 6681FFFCFF	   207M 		cmp $off_cmp,%edi
04:00000AD2 0100
04:00000AD4 0F85D719  	   208M 		jne error
                      	   209M 
04:00000AD8 66BE000001	   210M 		mov $off_value,%esi
04:00000ADD 00
04:00000ADE 66BF000001	   211M 		mov $off_value,%edi
04:00000AE3 00
04:00000AE4 66BB000000	   212M 		mov $off_value & off_mask,%ebx
04:00000AE9 00
04:00000AEA 67668903  	   213M 		mov %eax,%ds:(%ebx)
04:00000AEE 6766268903	   214M 		mov %eax,%es:(%ebx)
04:00000AF3 6683F800  	   215M 		cmp $0,%eax
04:00000AF7 0F84B419  	   216M 		je error
                      	   217M #		addr16
04:00000AFB 66A7      	   218M 		cmpsl     # COMPARE ES:EDI with DS:ESI
04:00000AFD 0F85AE19  	   219M 		jne error
04:00000B01 6681FFFCFF	   220M 		cmp $off_cmp,%edi
04:00000B06 0100
04:00000B08 0F85A319  	   221M 		jne error
04:00000B0C 6681FEFCFF	   222M 		cmp $off_cmp,%esi
04:00000B11 0100
04:00000B13 0F859819  	   223M 		jne error
                      	   224M 
04:00000B17 66BF000001	   225M 		mov $off_value,%edi
04:00000B1C 00
04:00000B1D 66B8785634	   226M 		mov $value,%eax
04:00000B22 12
04:00000B23 6766268903	   227M 		mov %eax,%es:(%ebx)
04:00000B28 6683F800  	   228M 		cmp $0,%eax
                      	   229M #		addr16
04:00000B2C 66AF      	   230M 		scasl     # SCAN/COMPARE ES:EDI with EAX
04:00000B2E 0F857D19  	   231M 		jne error
04:00000B32 6681FFFCFF	   232M 		cmp $off_cmp,%edi
04:00000B37 0100
04:00000B39 0F857219  	   233M 		jne error
                      	   234M 
04:00000B3D 66BE000001	   235M 		mov $off_value,%esi
04:00000B42 00
04:00000B43 66BF000001	   236M 		mov $off_value,%edi
04:00000B48 00
04:00000B49 66B8785634	   237M 		mov $value,%eax
04:00000B4E 12
04:00000B4F 67668903  	   238M 		mov %eax,%ds:(%ebx)
04:00000B53 66B8000000	   239M 		mov $0,%eax
04:00000B58 00
04:00000B59 6766268903	   240M 		mov %eax,%es:(%ebx)
                      	   241M #		addr16
04:00000B5E 66A5      	   242M 		movsl        # MOVE data from DS:ESI to ES:EDI
04:00000B60 66B8785634	   243M 		mov $value,%eax
04:00000B65 12
                      	   244M 		.if 16 = 16
04:00000B66 6766263903	   245M 			cmp %eax,%es:(%ebx)
                      	   246M 		.else
                      	   247M 			cmp %eax,%es:(%ebx)
                      	   248M 		.endif
04:00000B6B 0F854019  	   249M 		jne error
04:00000B6F 6681FFFCFF	   250M 		cmp $off_cmp,%edi
04:00000B74 0100
04:00000B76 0F853519  	   251M 		jne error
04:00000B7A 6681FEFCFF	   252M 		cmp $off_cmp,%esi
04:00000B7F 0100
04:00000B81 0F852A19  	   253M 		jne error
                      	   254M 
04:00000B85 66BE000001	   255M 		mov $off_value,%esi
04:00000B8A 00
04:00000B8B 66B8785634	   256M 		mov $value,%eax
04:00000B90 12
04:00000B91 6766268903	   257M 		mov %eax,%es:(%ebx)
04:00000B96 6631C0    	   258M 		xor %eax,%eax
                      	   259M #		addr16
04:00000B99 66AD      	   260M 		lodsl       # LOAD data from DS:ESI into EAX
04:00000B9B 663D785634	   261M 		cmp $value & val_mask,%eax
04:00000BA0 12
04:00000BA1 0F850A19  	   262M 		jne error
04:00000BA5 6681FEFCFF	   263M 		cmp $off_cmp,%esi
04:00000BAA 0100
04:00000BAC 0F85FF18  	   264M 		jne error
                      	   265M 	.endif
                      	   266M 
                      	   243: 	testStringReps b,0,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if b = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if b = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if b = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 0 == 0
04:00000BB0 FC        	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
                      	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00000BB1 66B8785634	    36M 	mov $0x12345678,%eax
04:00000BB6 12
04:00000BB7 66BE00FF01	    37M 	mov $off_value,%esi
04:00000BBC 00
04:00000BBD 66BF00FF01	    38M 	mov $off_value,%edi
04:00000BC2 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:00000BC3 66B8785634	    43M 	mov $0x12345678,%eax
04:00000BC8 12
04:00000BC9 66BE00FF01	    44M 	mov $off_value,%esi
04:00000BCE 00
04:00000BCF 66BF00FF01	    45M 	mov $off_value,%edi
04:00000BD4 00
04:00000BD5 66B9000100	    46M 	mov $items,%ecx
04:00000BDA 00
                      	    47M 	.if b = b
                      	    48M #		addr16
04:00000BDB F3        	    49M 		rep
04:00000BDC AA        	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if b = w
                      	    53M #		addr16
                      	    54M 		rep
                      	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if b = d
                      	    58M #		addr16
                      	    59M 		rep
                      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00000BDD 6683F900  	    62M 	cmp $0,%ecx
04:00000BE1 0F85CA18  	    63M 	jnz error           		# ECX must be 0
04:00000BE5 6681FF0000	    64M 	cmp $off_cmp,%edi
04:00000BEA 0100
04:00000BEC 0F85BF18  	    65M 	jnz error
04:00000BF0 66BF00FF01	    66M 	mov $off_value,%edi  # reset EDI
04:00000BF5 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:00000BF6 8CC2      	    68M 	mov %es,%dx
04:00000BF8 8CD9      	    69M 	mov %ds,%cx
04:00000BFA 87CA      	    70M 	xchg %cx,%dx
04:00000BFC 8EC2      	    71M 	mov %dx,%es
04:00000BFE 8ED9      	    72M 	mov %cx,%ds
04:00000C00 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:00000C03 66B9000100	    75M 	mov $items,%ecx      	# reset ECX
04:00000C08 00
                      	    76M 	.if b = b
                      	    77M #		addr16
04:00000C09 F3        	    78M 		rep
04:00000C0A AA        	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if b = w
                      	    82M #		addr16
                      	    83M 		rep
                      	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if b = d
                      	    87M #		addr16
                      	    88M 		rep
                      	    89M 		stosl
                      	    90M 	.endif
04:00000C0B 66BF00FF01	    91M 	mov $off_value,%edi  	# reset EDI
04:00000C10 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:00000C11 66B9000100	    94M 	mov $items,%ecx      # reset ECX
04:00000C16 00
                      	    95M 	.if b = b
                      	    96M #		addr16
04:00000C17 F3        	    97M 		repe
04:00000C18 A6        	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if b = w
                      	   101M #		addr16
                      	   102M 		repe
                      	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if b = d
                      	   106M #		addr16
                      	   107M 		repe
                      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:00000C19 6683F900  	   110M 	cmp $0,%ecx
04:00000C1D 0F858E18  	   111M 	jnz error           		# ECX must be 0
04:00000C21 6681FE0000	   112M 	cmp $off_cmp,%esi
04:00000C26 0100
04:00000C28 0F858318  	   113M 	jne error
04:00000C2C 6681FF0000	   114M 	cmp $off_cmp,%edi
04:00000C31 0100
04:00000C33 0F857818  	   115M 	jne error
04:00000C37 66BF00FF01	   116M 	mov $off_value,%edi  # reset EDI
04:00000C3C 00
04:00000C3D 66BE00FF01	   117M 	mov $off_value,%esi  # reset ESI
04:00000C42 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:00000C43 66B9000100	   120M 	mov $items,%ecx      # reset ECX
04:00000C48 00
                      	   121M 	.if b = b
                      	   122M #		addr16
04:00000C49 F3        	   123M 		repe
04:00000C4A AE        	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if b = w
                      	   127M #		addr16
                      	   128M 		repe
                      	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if b = d
                      	   132M #		addr16
                      	   133M 		repe
                      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:00000C4B 6683F900  	   136M 	cmp $0,%ecx
04:00000C4F 0F855C18  	   137M 	jne error           		# ECX must be 0
04:00000C53 6681FF0000	   138M 	cmp $off_cmp,%edi
04:00000C58 0100
04:00000C5A 0F855118  	   139M 	jne error
04:00000C5E 66BF00FF01	   140M 	mov $off_value,%edi  		# rewind EDI
04:00000C63 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:00000C64 66B8000000	   144M 	mov $0,%eax
04:00000C69 00
04:00000C6A 66B9000100	   145M 	mov $items,%ecx      # reset ECX
04:00000C6F 00
                      	   146M 	.if b = b
                      	   147M #		addr16
04:00000C70 F3        	   148M 		rep
04:00000C71 AA        	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if b = w
                      	   152M #		addr16
                      	   153M 		rep
                      	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if b = d
                      	   157M #		addr16
                      	   158M 		rep
                      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:00000C72 66BF00FF01	   161M 	mov $off_value,%edi  # reset EDI
04:00000C77 00
04:00000C78 66B9000100	   162M 	mov $items,%ecx      # reset ECX
04:00000C7D 00
                      	   163M 	.if b = b
                      	   164M #		addr16
04:00000C7E F3        	   165M 		rep
04:00000C7F A4        	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if b = w
                      	   169M #		addr16
                      	   170M 		rep
                      	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if b = d
                      	   174M #		addr16
                      	   175M 		rep
                      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:00000C80 6683F900  	   178M 	cmp $0,%ecx
04:00000C84 0F852718  	   179M 	jne error           	# ECX must be 0
04:00000C88 6681FE0000	   180M 	cmp $off_cmp,%esi
04:00000C8D 0100
04:00000C8F 0F851C18  	   181M 	jne error
04:00000C93 6681FF0000	   182M 	cmp $off_cmp,%edi
04:00000C98 0100
04:00000C9A 0F851118  	   183M 	jne error
04:00000C9E 66B9000100	   184M 	mov $items,%ecx      	# reset ECX
04:00000CA3 00
04:00000CA4 66BF00FF01	   185M 	mov $off_value,%edi  	# reset EDI
04:00000CA9 00
04:00000CAA 66BE00FF01	   186M 	mov $off_value,%esi  	# reset ESI
04:00000CAF 00
                      	   187M 	.if b = b
                      	   188M #		addr16
04:00000CB0 F3        	   189M 		repe
04:00000CB1 A6        	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if b = w
                      	   193M #		addr16
                      	   194M 		repe
                      	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if b = d
                      	   198M #		addr16
                      	   199M 		repe
                      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00000CB2 6683F900  	   202M 	cmp $0,%ecx
04:00000CB6 0F85F517  	   203M 	jne error           # ECX must be 0
04:00000CBA 6681FE0000	   204M 	cmp $off_cmp,%esi
04:00000CBF 0100
04:00000CC1 0F85EA17  	   205M 	jne error
04:00000CC5 6681FF0000	   206M 	cmp $off_cmp,%edi
04:00000CCA 0100
04:00000CCC 0F85DF17  	   207M 	jne error
                      	   244: 	testStringReps w,0,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if w = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if w = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if w = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 0 == 0
04:00000CD0 FC        	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
                      	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00000CD1 66B8785634	    36M 	mov $0x12345678,%eax
04:00000CD6 12
04:00000CD7 66BE00FF01	    37M 	mov $off_value,%esi
04:00000CDC 00
04:00000CDD 66BF00FF01	    38M 	mov $off_value,%edi
04:00000CE2 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:00000CE3 66B8785634	    43M 	mov $0x12345678,%eax
04:00000CE8 12
04:00000CE9 66BE00FF01	    44M 	mov $off_value,%esi
04:00000CEE 00
04:00000CEF 66BF00FF01	    45M 	mov $off_value,%edi
04:00000CF4 00
04:00000CF5 66B9800000	    46M 	mov $items,%ecx
04:00000CFA 00
                      	    47M 	.if w = b
                      	    48M #		addr16
                      	    49M 		rep
                      	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if w = w
                      	    53M #		addr16
04:00000CFB F3        	    54M 		rep
04:00000CFC AB        	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if w = d
                      	    58M #		addr16
                      	    59M 		rep
                      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00000CFD 6683F900  	    62M 	cmp $0,%ecx
04:00000D01 0F85AA17  	    63M 	jnz error           		# ECX must be 0
04:00000D05 6681FF0000	    64M 	cmp $off_cmp,%edi
04:00000D0A 0100
04:00000D0C 0F859F17  	    65M 	jnz error
04:00000D10 66BF00FF01	    66M 	mov $off_value,%edi  # reset EDI
04:00000D15 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:00000D16 8CC2      	    68M 	mov %es,%dx
04:00000D18 8CD9      	    69M 	mov %ds,%cx
04:00000D1A 87CA      	    70M 	xchg %cx,%dx
04:00000D1C 8EC2      	    71M 	mov %dx,%es
04:00000D1E 8ED9      	    72M 	mov %cx,%ds
04:00000D20 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:00000D23 66B9800000	    75M 	mov $items,%ecx      	# reset ECX
04:00000D28 00
                      	    76M 	.if w = b
                      	    77M #		addr16
                      	    78M 		rep
                      	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if w = w
                      	    82M #		addr16
04:00000D29 F3        	    83M 		rep
04:00000D2A AB        	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if w = d
                      	    87M #		addr16
                      	    88M 		rep
                      	    89M 		stosl
                      	    90M 	.endif
04:00000D2B 66BF00FF01	    91M 	mov $off_value,%edi  	# reset EDI
04:00000D30 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:00000D31 66B9800000	    94M 	mov $items,%ecx      # reset ECX
04:00000D36 00
                      	    95M 	.if w = b
                      	    96M #		addr16
                      	    97M 		repe
                      	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if w = w
                      	   101M #		addr16
04:00000D37 F3        	   102M 		repe
04:00000D38 A7        	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if w = d
                      	   106M #		addr16
                      	   107M 		repe
                      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:00000D39 6683F900  	   110M 	cmp $0,%ecx
04:00000D3D 0F856E17  	   111M 	jnz error           		# ECX must be 0
04:00000D41 6681FE0000	   112M 	cmp $off_cmp,%esi
04:00000D46 0100
04:00000D48 0F856317  	   113M 	jne error
04:00000D4C 6681FF0000	   114M 	cmp $off_cmp,%edi
04:00000D51 0100
04:00000D53 0F855817  	   115M 	jne error
04:00000D57 66BF00FF01	   116M 	mov $off_value,%edi  # reset EDI
04:00000D5C 00
04:00000D5D 66BE00FF01	   117M 	mov $off_value,%esi  # reset ESI
04:00000D62 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:00000D63 66B9800000	   120M 	mov $items,%ecx      # reset ECX
04:00000D68 00
                      	   121M 	.if w = b
                      	   122M #		addr16
                      	   123M 		repe
                      	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if w = w
                      	   127M #		addr16
04:00000D69 F3        	   128M 		repe
04:00000D6A AF        	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if w = d
                      	   132M #		addr16
                      	   133M 		repe
                      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:00000D6B 6683F900  	   136M 	cmp $0,%ecx
04:00000D6F 0F853C17  	   137M 	jne error           		# ECX must be 0
04:00000D73 6681FF0000	   138M 	cmp $off_cmp,%edi
04:00000D78 0100
04:00000D7A 0F853117  	   139M 	jne error
04:00000D7E 66BF00FF01	   140M 	mov $off_value,%edi  		# rewind EDI
04:00000D83 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:00000D84 66B8000000	   144M 	mov $0,%eax
04:00000D89 00
04:00000D8A 66B9800000	   145M 	mov $items,%ecx      # reset ECX
04:00000D8F 00
                      	   146M 	.if w = b
                      	   147M #		addr16
                      	   148M 		rep
                      	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if w = w
                      	   152M #		addr16
04:00000D90 F3        	   153M 		rep
04:00000D91 AB        	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if w = d
                      	   157M #		addr16
                      	   158M 		rep
                      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:00000D92 66BF00FF01	   161M 	mov $off_value,%edi  # reset EDI
04:00000D97 00
04:00000D98 66B9800000	   162M 	mov $items,%ecx      # reset ECX
04:00000D9D 00
                      	   163M 	.if w = b
                      	   164M #		addr16
                      	   165M 		rep
                      	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if w = w
                      	   169M #		addr16
04:00000D9E F3        	   170M 		rep
04:00000D9F A5        	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if w = d
                      	   174M #		addr16
                      	   175M 		rep
                      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:00000DA0 6683F900  	   178M 	cmp $0,%ecx
04:00000DA4 0F850717  	   179M 	jne error           	# ECX must be 0
04:00000DA8 6681FE0000	   180M 	cmp $off_cmp,%esi
04:00000DAD 0100
04:00000DAF 0F85FC16  	   181M 	jne error
04:00000DB3 6681FF0000	   182M 	cmp $off_cmp,%edi
04:00000DB8 0100
04:00000DBA 0F85F116  	   183M 	jne error
04:00000DBE 66B9800000	   184M 	mov $items,%ecx      	# reset ECX
04:00000DC3 00
04:00000DC4 66BF00FF01	   185M 	mov $off_value,%edi  	# reset EDI
04:00000DC9 00
04:00000DCA 66BE00FF01	   186M 	mov $off_value,%esi  	# reset ESI
04:00000DCF 00
                      	   187M 	.if w = b
                      	   188M #		addr16
                      	   189M 		repe
                      	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if w = w
                      	   193M #		addr16
04:00000DD0 F3        	   194M 		repe
04:00000DD1 A7        	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if w = d
                      	   198M #		addr16
                      	   199M 		repe
                      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00000DD2 6683F900  	   202M 	cmp $0,%ecx
04:00000DD6 0F85D516  	   203M 	jne error           # ECX must be 0
04:00000DDA 6681FE0000	   204M 	cmp $off_cmp,%esi
04:00000DDF 0100
04:00000DE1 0F85CA16  	   205M 	jne error
04:00000DE5 6681FF0000	   206M 	cmp $off_cmp,%edi
04:00000DEA 0100
04:00000DEC 0F85BF16  	   207M 	jne error
                      	   245: 	testStringReps d,0,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if d = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if d = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if d = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 0 == 0
04:00000DF0 FC        	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
                      	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00000DF1 66B8785634	    36M 	mov $0x12345678,%eax
04:00000DF6 12
04:00000DF7 66BE00FF01	    37M 	mov $off_value,%esi
04:00000DFC 00
04:00000DFD 66BF00FF01	    38M 	mov $off_value,%edi
04:00000E02 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:00000E03 66B8785634	    43M 	mov $0x12345678,%eax
04:00000E08 12
04:00000E09 66BE00FF01	    44M 	mov $off_value,%esi
04:00000E0E 00
04:00000E0F 66BF00FF01	    45M 	mov $off_value,%edi
04:00000E14 00
04:00000E15 66B9400000	    46M 	mov $items,%ecx
04:00000E1A 00
                      	    47M 	.if d = b
                      	    48M #		addr16
                      	    49M 		rep
                      	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if d = w
                      	    53M #		addr16
                      	    54M 		rep
                      	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if d = d
                      	    58M #		addr16
04:00000E1B F3        	    59M 		rep
04:00000E1C 66AB      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00000E1E 6683F900  	    62M 	cmp $0,%ecx
04:00000E22 0F858916  	    63M 	jnz error           		# ECX must be 0
04:00000E26 6681FF0000	    64M 	cmp $off_cmp,%edi
04:00000E2B 0100
04:00000E2D 0F857E16  	    65M 	jnz error
04:00000E31 66BF00FF01	    66M 	mov $off_value,%edi  # reset EDI
04:00000E36 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:00000E37 8CC2      	    68M 	mov %es,%dx
04:00000E39 8CD9      	    69M 	mov %ds,%cx
04:00000E3B 87CA      	    70M 	xchg %cx,%dx
04:00000E3D 8EC2      	    71M 	mov %dx,%es
04:00000E3F 8ED9      	    72M 	mov %cx,%ds
04:00000E41 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:00000E44 66B9400000	    75M 	mov $items,%ecx      	# reset ECX
04:00000E49 00
                      	    76M 	.if d = b
                      	    77M #		addr16
                      	    78M 		rep
                      	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if d = w
                      	    82M #		addr16
                      	    83M 		rep
                      	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if d = d
                      	    87M #		addr16
04:00000E4A F3        	    88M 		rep
04:00000E4B 66AB      	    89M 		stosl
                      	    90M 	.endif
04:00000E4D 66BF00FF01	    91M 	mov $off_value,%edi  	# reset EDI
04:00000E52 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:00000E53 66B9400000	    94M 	mov $items,%ecx      # reset ECX
04:00000E58 00
                      	    95M 	.if d = b
                      	    96M #		addr16
                      	    97M 		repe
                      	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if d = w
                      	   101M #		addr16
                      	   102M 		repe
                      	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if d = d
                      	   106M #		addr16
04:00000E59 F3        	   107M 		repe
04:00000E5A 66A7      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:00000E5C 6683F900  	   110M 	cmp $0,%ecx
04:00000E60 0F854B16  	   111M 	jnz error           		# ECX must be 0
04:00000E64 6681FE0000	   112M 	cmp $off_cmp,%esi
04:00000E69 0100
04:00000E6B 0F854016  	   113M 	jne error
04:00000E6F 6681FF0000	   114M 	cmp $off_cmp,%edi
04:00000E74 0100
04:00000E76 0F853516  	   115M 	jne error
04:00000E7A 66BF00FF01	   116M 	mov $off_value,%edi  # reset EDI
04:00000E7F 00
04:00000E80 66BE00FF01	   117M 	mov $off_value,%esi  # reset ESI
04:00000E85 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:00000E86 66B9400000	   120M 	mov $items,%ecx      # reset ECX
04:00000E8B 00
                      	   121M 	.if d = b
                      	   122M #		addr16
                      	   123M 		repe
                      	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if d = w
                      	   127M #		addr16
                      	   128M 		repe
                      	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if d = d
                      	   132M #		addr16
04:00000E8C F3        	   133M 		repe
04:00000E8D 66AF      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:00000E8F 6683F900  	   136M 	cmp $0,%ecx
04:00000E93 0F851816  	   137M 	jne error           		# ECX must be 0
04:00000E97 6681FF0000	   138M 	cmp $off_cmp,%edi
04:00000E9C 0100
04:00000E9E 0F850D16  	   139M 	jne error
04:00000EA2 66BF00FF01	   140M 	mov $off_value,%edi  		# rewind EDI
04:00000EA7 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:00000EA8 66B8000000	   144M 	mov $0,%eax
04:00000EAD 00
04:00000EAE 66B9400000	   145M 	mov $items,%ecx      # reset ECX
04:00000EB3 00
                      	   146M 	.if d = b
                      	   147M #		addr16
                      	   148M 		rep
                      	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if d = w
                      	   152M #		addr16
                      	   153M 		rep
                      	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if d = d
                      	   157M #		addr16
04:00000EB4 F3        	   158M 		rep
04:00000EB5 66AB      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:00000EB7 66BF00FF01	   161M 	mov $off_value,%edi  # reset EDI
04:00000EBC 00
04:00000EBD 66B9400000	   162M 	mov $items,%ecx      # reset ECX
04:00000EC2 00
                      	   163M 	.if d = b
                      	   164M #		addr16
                      	   165M 		rep
                      	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if d = w
                      	   169M #		addr16
                      	   170M 		rep
                      	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if d = d
                      	   174M #		addr16
04:00000EC3 F3        	   175M 		rep
04:00000EC4 66A5      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:00000EC6 6683F900  	   178M 	cmp $0,%ecx
04:00000ECA 0F85E115  	   179M 	jne error           	# ECX must be 0
04:00000ECE 6681FE0000	   180M 	cmp $off_cmp,%esi
04:00000ED3 0100
04:00000ED5 0F85D615  	   181M 	jne error
04:00000ED9 6681FF0000	   182M 	cmp $off_cmp,%edi
04:00000EDE 0100
04:00000EE0 0F85CB15  	   183M 	jne error
04:00000EE4 66B9400000	   184M 	mov $items,%ecx      	# reset ECX
04:00000EE9 00
04:00000EEA 66BF00FF01	   185M 	mov $off_value,%edi  	# reset EDI
04:00000EEF 00
04:00000EF0 66BE00FF01	   186M 	mov $off_value,%esi  	# reset ESI
04:00000EF5 00
                      	   187M 	.if d = b
                      	   188M #		addr16
                      	   189M 		repe
                      	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if d = w
                      	   193M #		addr16
                      	   194M 		repe
                      	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if d = d
                      	   198M #		addr16
04:00000EF6 F3        	   199M 		repe
04:00000EF7 66A7      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00000EF9 6683F900  	   202M 	cmp $0,%ecx
04:00000EFD 0F85AE15  	   203M 	jne error           # ECX must be 0
04:00000F01 6681FE0000	   204M 	cmp $off_cmp,%esi
04:00000F06 0100
04:00000F08 0F85A315  	   205M 	jne error
04:00000F0C 6681FF0000	   206M 	cmp $off_cmp,%edi
04:00000F11 0100
04:00000F13 0F859815  	   207M 	jne error
                      	   246: 	testStringReps b,1,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if b = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if b = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if b = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 1 == 0
                      	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
04:00000F17 FD        	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00000F18 66B8785634	    36M 	mov $0x12345678,%eax
04:00000F1D 12
04:00000F1E 66BEFF0001	    37M 	mov $off_value,%esi
04:00000F23 00
04:00000F24 66BFFF0001	    38M 	mov $off_value,%edi
04:00000F29 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:00000F2A 66B8785634	    43M 	mov $0x12345678,%eax
04:00000F2F 12
04:00000F30 66BEFF0001	    44M 	mov $off_value,%esi
04:00000F35 00
04:00000F36 66BFFF0001	    45M 	mov $off_value,%edi
04:00000F3B 00
04:00000F3C 66B9000100	    46M 	mov $items,%ecx
04:00000F41 00
                      	    47M 	.if b = b
                      	    48M #		addr16
04:00000F42 F3        	    49M 		rep
04:00000F43 AA        	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if b = w
                      	    53M #		addr16
                      	    54M 		rep
                      	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if b = d
                      	    58M #		addr16
                      	    59M 		rep
                      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00000F44 6683F900  	    62M 	cmp $0,%ecx
04:00000F48 0F856315  	    63M 	jnz error           		# ECX must be 0
04:00000F4C 6681FFFFFF	    64M 	cmp $off_cmp,%edi
04:00000F51 0100
04:00000F53 0F855815  	    65M 	jnz error
04:00000F57 66BFFF0001	    66M 	mov $off_value,%edi  # reset EDI
04:00000F5C 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:00000F5D 8CC2      	    68M 	mov %es,%dx
04:00000F5F 8CD9      	    69M 	mov %ds,%cx
04:00000F61 87CA      	    70M 	xchg %cx,%dx
04:00000F63 8EC2      	    71M 	mov %dx,%es
04:00000F65 8ED9      	    72M 	mov %cx,%ds
04:00000F67 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:00000F6A 66B9000100	    75M 	mov $items,%ecx      	# reset ECX
04:00000F6F 00
                      	    76M 	.if b = b
                      	    77M #		addr16
04:00000F70 F3        	    78M 		rep
04:00000F71 AA        	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if b = w
                      	    82M #		addr16
                      	    83M 		rep
                      	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if b = d
                      	    87M #		addr16
                      	    88M 		rep
                      	    89M 		stosl
                      	    90M 	.endif
04:00000F72 66BFFF0001	    91M 	mov $off_value,%edi  	# reset EDI
04:00000F77 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:00000F78 66B9000100	    94M 	mov $items,%ecx      # reset ECX
04:00000F7D 00
                      	    95M 	.if b = b
                      	    96M #		addr16
04:00000F7E F3        	    97M 		repe
04:00000F7F A6        	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if b = w
                      	   101M #		addr16
                      	   102M 		repe
                      	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if b = d
                      	   106M #		addr16
                      	   107M 		repe
                      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:00000F80 6683F900  	   110M 	cmp $0,%ecx
04:00000F84 0F852715  	   111M 	jnz error           		# ECX must be 0
04:00000F88 6681FEFFFF	   112M 	cmp $off_cmp,%esi
04:00000F8D 0100
04:00000F8F 0F851C15  	   113M 	jne error
04:00000F93 6681FFFFFF	   114M 	cmp $off_cmp,%edi
04:00000F98 0100
04:00000F9A 0F851115  	   115M 	jne error
04:00000F9E 66BFFF0001	   116M 	mov $off_value,%edi  # reset EDI
04:00000FA3 00
04:00000FA4 66BEFF0001	   117M 	mov $off_value,%esi  # reset ESI
04:00000FA9 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:00000FAA 66B9000100	   120M 	mov $items,%ecx      # reset ECX
04:00000FAF 00
                      	   121M 	.if b = b
                      	   122M #		addr16
04:00000FB0 F3        	   123M 		repe
04:00000FB1 AE        	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if b = w
                      	   127M #		addr16
                      	   128M 		repe
                      	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if b = d
                      	   132M #		addr16
                      	   133M 		repe
                      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:00000FB2 6683F900  	   136M 	cmp $0,%ecx
04:00000FB6 0F85F514  	   137M 	jne error           		# ECX must be 0
04:00000FBA 6681FFFFFF	   138M 	cmp $off_cmp,%edi
04:00000FBF 0100
04:00000FC1 0F85EA14  	   139M 	jne error
04:00000FC5 66BFFF0001	   140M 	mov $off_value,%edi  		# rewind EDI
04:00000FCA 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:00000FCB 66B8000000	   144M 	mov $0,%eax
04:00000FD0 00
04:00000FD1 66B9000100	   145M 	mov $items,%ecx      # reset ECX
04:00000FD6 00
                      	   146M 	.if b = b
                      	   147M #		addr16
04:00000FD7 F3        	   148M 		rep
04:00000FD8 AA        	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if b = w
                      	   152M #		addr16
                      	   153M 		rep
                      	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if b = d
                      	   157M #		addr16
                      	   158M 		rep
                      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:00000FD9 66BFFF0001	   161M 	mov $off_value,%edi  # reset EDI
04:00000FDE 00
04:00000FDF 66B9000100	   162M 	mov $items,%ecx      # reset ECX
04:00000FE4 00
                      	   163M 	.if b = b
                      	   164M #		addr16
04:00000FE5 F3        	   165M 		rep
04:00000FE6 A4        	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if b = w
                      	   169M #		addr16
                      	   170M 		rep
                      	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if b = d
                      	   174M #		addr16
                      	   175M 		rep
                      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:00000FE7 6683F900  	   178M 	cmp $0,%ecx
04:00000FEB 0F85C014  	   179M 	jne error           	# ECX must be 0
04:00000FEF 6681FEFFFF	   180M 	cmp $off_cmp,%esi
04:00000FF4 0100
04:00000FF6 0F85B514  	   181M 	jne error
04:00000FFA 6681FFFFFF	   182M 	cmp $off_cmp,%edi
04:00000FFF 0100
04:00001001 0F85AA14  	   183M 	jne error
04:00001005 66B9000100	   184M 	mov $items,%ecx      	# reset ECX
04:0000100A 00
04:0000100B 66BFFF0001	   185M 	mov $off_value,%edi  	# reset EDI
04:00001010 00
04:00001011 66BEFF0001	   186M 	mov $off_value,%esi  	# reset ESI
04:00001016 00
                      	   187M 	.if b = b
                      	   188M #		addr16
04:00001017 F3        	   189M 		repe
04:00001018 A6        	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if b = w
                      	   193M #		addr16
                      	   194M 		repe
                      	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if b = d
                      	   198M #		addr16
                      	   199M 		repe
                      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00001019 6683F900  	   202M 	cmp $0,%ecx
04:0000101D 0F858E14  	   203M 	jne error           # ECX must be 0
04:00001021 6681FEFFFF	   204M 	cmp $off_cmp,%esi
04:00001026 0100
04:00001028 0F858314  	   205M 	jne error
04:0000102C 6681FFFFFF	   206M 	cmp $off_cmp,%edi
04:00001031 0100
04:00001033 0F857814  	   207M 	jne error
                      	   247: 	testStringReps w,1,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if w = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if w = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if w = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 1 == 0
                      	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
04:00001037 FD        	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00001038 66B8785634	    36M 	mov $0x12345678,%eax
04:0000103D 12
04:0000103E 66BEFF0001	    37M 	mov $off_value,%esi
04:00001043 00
04:00001044 66BFFF0001	    38M 	mov $off_value,%edi
04:00001049 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:0000104A 66B8785634	    43M 	mov $0x12345678,%eax
04:0000104F 12
04:00001050 66BEFF0001	    44M 	mov $off_value,%esi
04:00001055 00
04:00001056 66BFFF0001	    45M 	mov $off_value,%edi
04:0000105B 00
04:0000105C 66B9800000	    46M 	mov $items,%ecx
04:00001061 00
                      	    47M 	.if w = b
                      	    48M #		addr16
                      	    49M 		rep
                      	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if w = w
                      	    53M #		addr16
04:00001062 F3        	    54M 		rep
04:00001063 AB        	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if w = d
                      	    58M #		addr16
                      	    59M 		rep
                      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00001064 6683F900  	    62M 	cmp $0,%ecx
04:00001068 0F854314  	    63M 	jnz error           		# ECX must be 0
04:0000106C 6681FFFFFF	    64M 	cmp $off_cmp,%edi
04:00001071 0100
04:00001073 0F853814  	    65M 	jnz error
04:00001077 66BFFF0001	    66M 	mov $off_value,%edi  # reset EDI
04:0000107C 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:0000107D 8CC2      	    68M 	mov %es,%dx
04:0000107F 8CD9      	    69M 	mov %ds,%cx
04:00001081 87CA      	    70M 	xchg %cx,%dx
04:00001083 8EC2      	    71M 	mov %dx,%es
04:00001085 8ED9      	    72M 	mov %cx,%ds
04:00001087 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:0000108A 66B9800000	    75M 	mov $items,%ecx      	# reset ECX
04:0000108F 00
                      	    76M 	.if w = b
                      	    77M #		addr16
                      	    78M 		rep
                      	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if w = w
                      	    82M #		addr16
04:00001090 F3        	    83M 		rep
04:00001091 AB        	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if w = d
                      	    87M #		addr16
                      	    88M 		rep
                      	    89M 		stosl
                      	    90M 	.endif
04:00001092 66BFFF0001	    91M 	mov $off_value,%edi  	# reset EDI
04:00001097 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:00001098 66B9800000	    94M 	mov $items,%ecx      # reset ECX
04:0000109D 00
                      	    95M 	.if w = b
                      	    96M #		addr16
                      	    97M 		repe
                      	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if w = w
                      	   101M #		addr16
04:0000109E F3        	   102M 		repe
04:0000109F A7        	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if w = d
                      	   106M #		addr16
                      	   107M 		repe
                      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:000010A0 6683F900  	   110M 	cmp $0,%ecx
04:000010A4 0F850714  	   111M 	jnz error           		# ECX must be 0
04:000010A8 6681FEFFFF	   112M 	cmp $off_cmp,%esi
04:000010AD 0100
04:000010AF 0F85FC13  	   113M 	jne error
04:000010B3 6681FFFFFF	   114M 	cmp $off_cmp,%edi
04:000010B8 0100
04:000010BA 0F85F113  	   115M 	jne error
04:000010BE 66BFFF0001	   116M 	mov $off_value,%edi  # reset EDI
04:000010C3 00
04:000010C4 66BEFF0001	   117M 	mov $off_value,%esi  # reset ESI
04:000010C9 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:000010CA 66B9800000	   120M 	mov $items,%ecx      # reset ECX
04:000010CF 00
                      	   121M 	.if w = b
                      	   122M #		addr16
                      	   123M 		repe
                      	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if w = w
                      	   127M #		addr16
04:000010D0 F3        	   128M 		repe
04:000010D1 AF        	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if w = d
                      	   132M #		addr16
                      	   133M 		repe
                      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:000010D2 6683F900  	   136M 	cmp $0,%ecx
04:000010D6 0F85D513  	   137M 	jne error           		# ECX must be 0
04:000010DA 6681FFFFFF	   138M 	cmp $off_cmp,%edi
04:000010DF 0100
04:000010E1 0F85CA13  	   139M 	jne error
04:000010E5 66BFFF0001	   140M 	mov $off_value,%edi  		# rewind EDI
04:000010EA 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:000010EB 66B8000000	   144M 	mov $0,%eax
04:000010F0 00
04:000010F1 66B9800000	   145M 	mov $items,%ecx      # reset ECX
04:000010F6 00
                      	   146M 	.if w = b
                      	   147M #		addr16
                      	   148M 		rep
                      	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if w = w
                      	   152M #		addr16
04:000010F7 F3        	   153M 		rep
04:000010F8 AB        	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if w = d
                      	   157M #		addr16
                      	   158M 		rep
                      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:000010F9 66BFFF0001	   161M 	mov $off_value,%edi  # reset EDI
04:000010FE 00
04:000010FF 66B9800000	   162M 	mov $items,%ecx      # reset ECX
04:00001104 00
                      	   163M 	.if w = b
                      	   164M #		addr16
                      	   165M 		rep
                      	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if w = w
                      	   169M #		addr16
04:00001105 F3        	   170M 		rep
04:00001106 A5        	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if w = d
                      	   174M #		addr16
                      	   175M 		rep
                      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:00001107 6683F900  	   178M 	cmp $0,%ecx
04:0000110B 0F85A013  	   179M 	jne error           	# ECX must be 0
04:0000110F 6681FEFFFF	   180M 	cmp $off_cmp,%esi
04:00001114 0100
04:00001116 0F859513  	   181M 	jne error
04:0000111A 6681FFFFFF	   182M 	cmp $off_cmp,%edi
04:0000111F 0100
04:00001121 0F858A13  	   183M 	jne error
04:00001125 66B9800000	   184M 	mov $items,%ecx      	# reset ECX
04:0000112A 00
04:0000112B 66BFFF0001	   185M 	mov $off_value,%edi  	# reset EDI
04:00001130 00
04:00001131 66BEFF0001	   186M 	mov $off_value,%esi  	# reset ESI
04:00001136 00
                      	   187M 	.if w = b
                      	   188M #		addr16
                      	   189M 		repe
                      	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if w = w
                      	   193M #		addr16
04:00001137 F3        	   194M 		repe
04:00001138 A7        	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if w = d
                      	   198M #		addr16
                      	   199M 		repe
                      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00001139 6683F900  	   202M 	cmp $0,%ecx
04:0000113D 0F856E13  	   203M 	jne error           # ECX must be 0
04:00001141 6681FEFFFF	   204M 	cmp $off_cmp,%esi
04:00001146 0100
04:00001148 0F856313  	   205M 	jne error
04:0000114C 6681FFFFFF	   206M 	cmp $off_cmp,%edi
04:00001151 0100
04:00001153 0F855813  	   207M 	jne error
                      	   248: 	testStringReps d,1,16
                      	     1M 
                      	     2M 	.set bytes,0x100
                      	     3M 
                      	     4M 	.if d = b
                      	     5M 		.set items,bytes
                      	     6M 	.endif
                      	     7M 	.if d = w
                      	     8M 		.set items,bytes/2
                      	     9M 	.endif
                      	    10M 	.if d = d
                      	    11M 		.set items,bytes/4
                      	    12M 	.endif
                      	    13M 
                      	    14M 	.if 1 == 0
                      	    15M 		cld
                      	    16M 		.set off_value,0x0001ff00
                      	    17M 		.if 16 = 16
                      	    18M 			# 16-bit addressing
                      	    19M 			.set off_cmp,0x00010000
                      	    20M 		.else
                      	    21M 			# 32-bit addressing
                      	    22M 			.set off_cmp,0x00020000
                      	    23M 		.endif
                      	    24M 	.else
04:00001157 FD        	    25M 		std
                      	    26M 		.set off_value,0x000100ff
                      	    27M 		.if 16 = 16
                      	    28M 			# 16-bit addressing
                      	    29M 			.set off_cmp,0x0001ffff
                      	    30M 		.else
                      	    31M 			# 32-bit addressing
                      	    32M 			.set off_cmp,0x0000ffff
                      	    33M 		.endif
                      	    34M 	.endif
                      	    35M 
04:00001158 66B8785634	    36M 	mov $0x12345678,%eax
04:0000115D 12
04:0000115E 66BEFF0001	    37M 	mov $off_value,%esi
04:00001163 00
04:00001164 66BFFF0001	    38M 	mov $off_value,%edi
04:00001169 00
                      	    39M 
                      	    40M 	# VERIFY REPs on memory buffers
                      	    41M 
                      	    42M 	# STORE buffers with pattern in EAX
04:0000116A 66B8785634	    43M 	mov $0x12345678,%eax
04:0000116F 12
04:00001170 66BEFF0001	    44M 	mov $off_value,%esi
04:00001175 00
04:00001176 66BFFF0001	    45M 	mov $off_value,%edi
04:0000117B 00
04:0000117C 66B9400000	    46M 	mov $items,%ecx
04:00001181 00
                      	    47M 	.if d = b
                      	    48M #		addr16
                      	    49M 		rep
                      	    50M 		stosb    # store ECX items at ES:EDI with the value in EAX
                      	    51M 	.endif
                      	    52M 	.if d = w
                      	    53M #		addr16
                      	    54M 		rep
                      	    55M 		stosw    # store ECX items at ES:EDI with the value in EAX
                      	    56M 	.endif
                      	    57M 	.if d = d
                      	    58M #		addr16
04:00001182 F3        	    59M 		rep
04:00001183 66AB      	    60M 		stosl    # store ECX items at ES:EDI with the value in EAX
                      	    61M 	.endif
04:00001185 6683F900  	    62M 	cmp $0,%ecx
04:00001189 0F852213  	    63M 	jnz error           		# ECX must be 0
04:0000118D 6681FFFFFF	    64M 	cmp $off_cmp,%edi
04:00001192 0100
04:00001194 0F851713  	    65M 	jnz error
04:00001198 66BFFF0001	    66M 	mov $off_value,%edi  # reset EDI
04:0000119D 00
                      	    67M 	# now switch ES:EDI with DS:ESI
04:0000119E 8CC2      	    68M 	mov %es,%dx
04:000011A0 8CD9      	    69M 	mov %ds,%cx
04:000011A2 87CA      	    70M 	xchg %cx,%dx
04:000011A4 8EC2      	    71M 	mov %dx,%es
04:000011A6 8ED9      	    72M 	mov %cx,%ds
04:000011A8 6687F7    	    73M 	xchg %esi,%edi
                      	    74M 	# store again ES:EDI with pattern in EAX
04:000011AB 66B9400000	    75M 	mov $items,%ecx      	# reset ECX
04:000011B0 00
                      	    76M 	.if d = b
                      	    77M #		addr16
                      	    78M 		rep
                      	    79M 		stosb
                      	    80M 	.endif
                      	    81M 	.if d = w
                      	    82M #		addr16
                      	    83M 		rep
                      	    84M 		stosw
                      	    85M 	.endif
                      	    86M 	.if d = d
                      	    87M #		addr16
04:000011B1 F3        	    88M 		rep
04:000011B2 66AB      	    89M 		stosl
                      	    90M 	.endif
04:000011B4 66BFFF0001	    91M 	mov $off_value,%edi  	# reset EDI
04:000011B9 00
                      	    92M 
                      	    93M 	# COMPARE two buffers
04:000011BA 66B9400000	    94M 	mov $items,%ecx      # reset ECX
04:000011BF 00
                      	    95M 	.if d = b
                      	    96M #		addr16
                      	    97M 		repe
                      	    98M 		cmpsb # find nonmatching items in ES:EDI and DS:ESI
                      	    99M 	.endif
                      	   100M 	.if d = w
                      	   101M #		addr16
                      	   102M 		repe
                      	   103M 		cmpsw # find nonmatching items in ES:EDI and DS:ESI
                      	   104M 	.endif
                      	   105M 	.if d = d
                      	   106M #		addr16
04:000011C0 F3        	   107M 		repe
04:000011C1 66A7      	   108M 		cmpsl # find nonmatching items in ES:EDI and DS:ESI
                      	   109M 	.endif
04:000011C3 6683F900  	   110M 	cmp $0,%ecx
04:000011C7 0F85E412  	   111M 	jnz error           		# ECX must be 0
04:000011CB 6681FEFFFF	   112M 	cmp $off_cmp,%esi
04:000011D0 0100
04:000011D2 0F85D912  	   113M 	jne error
04:000011D6 6681FFFFFF	   114M 	cmp $off_cmp,%edi
04:000011DB 0100
04:000011DD 0F85CE12  	   115M 	jne error
04:000011E1 66BFFF0001	   116M 	mov $off_value,%edi  # reset EDI
04:000011E6 00
04:000011E7 66BEFF0001	   117M 	mov $off_value,%esi  # reset ESI
04:000011EC 00
                      	   118M 
                      	   119M 	# SCAN buffer for pattern
04:000011ED 66B9400000	   120M 	mov $items,%ecx      # reset ECX
04:000011F2 00
                      	   121M 	.if d = b
                      	   122M #		addr16
                      	   123M 		repe
                      	   124M 		scasb         # SCAN first dword not equal to EAX
                      	   125M 	.endif
                      	   126M 	.if d = w
                      	   127M #		addr16
                      	   128M 		repe
                      	   129M 		scasw         # SCAN first dword not equal to EAX
                      	   130M 	.endif
                      	   131M 	.if d = d
                      	   132M #		addr16
04:000011F3 F3        	   133M 		repe
04:000011F4 66AF      	   134M 		scasl         # SCAN first dword not equal to EAX
                      	   135M 	.endif
04:000011F6 6683F900  	   136M 	cmp $0,%ecx
04:000011FA 0F85B112  	   137M 	jne error           		# ECX must be 0
04:000011FE 6681FFFFFF	   138M 	cmp $off_cmp,%edi
04:00001203 0100
04:00001205 0F85A612  	   139M 	jne error
04:00001209 66BFFF0001	   140M 	mov $off_value,%edi  		# rewind EDI
04:0000120E 00
                      	   141M 
                      	   142M 	# MOVE and COMPARE data between buffers
                      	   143M 	# first zero-fill ES:EDI so that we can compare the moved data later
04:0000120F 66B8000000	   144M 	mov $0,%eax
04:00001214 00
04:00001215 66B9400000	   145M 	mov $items,%ecx      # reset ECX
04:0000121A 00
                      	   146M 	.if d = b
                      	   147M #		addr16
                      	   148M 		rep
                      	   149M 		stosb          # zero fill ES:EDI
                      	   150M 	.endif
                      	   151M 	.if d = w
                      	   152M #		addr16
                      	   153M 		rep
                      	   154M 		stosw          # zero fill ES:EDI
                      	   155M 	.endif
                      	   156M 	.if d = d
                      	   157M #		addr16
04:0000121B F3        	   158M 		rep
04:0000121C 66AB      	   159M 		stosl          # zero fill ES:EDI
                      	   160M 	.endif
04:0000121E 66BFFF0001	   161M 	mov $off_value,%edi  # reset EDI
04:00001223 00
04:00001224 66B9400000	   162M 	mov $items,%ecx      # reset ECX
04:00001229 00
                      	   163M 	.if d = b
                      	   164M #		addr16
                      	   165M 		rep
                      	   166M 		movsb          # MOVE data from DS:ESI to ES:EDI
                      	   167M 	.endif
                      	   168M 	.if d = w
                      	   169M #		addr16
                      	   170M 		rep
                      	   171M 		movsw          # MOVE data from DS:ESI to ES:EDI
                      	   172M 	.endif
                      	   173M 	.if d = d
                      	   174M #		addr16
04:0000122A F3        	   175M 		rep
04:0000122B 66A5      	   176M 		movsl          # MOVE data from DS:ESI to ES:EDI
                      	   177M 	.endif
04:0000122D 6683F900  	   178M 	cmp $0,%ecx
04:00001231 0F857A12  	   179M 	jne error           	# ECX must be 0
04:00001235 6681FEFFFF	   180M 	cmp $off_cmp,%esi
04:0000123A 0100
04:0000123C 0F856F12  	   181M 	jne error
04:00001240 6681FFFFFF	   182M 	cmp $off_cmp,%edi
04:00001245 0100
04:00001247 0F856412  	   183M 	jne error
04:0000124B 66B9400000	   184M 	mov $items,%ecx      	# reset ECX
04:00001250 00
04:00001251 66BFFF0001	   185M 	mov $off_value,%edi  	# reset EDI
04:00001256 00
04:00001257 66BEFF0001	   186M 	mov $off_value,%esi  	# reset ESI
04:0000125C 00
                      	   187M 	.if d = b
                      	   188M #		addr16
                      	   189M 		repe
                      	   190M 		cmpsb  # COMPARE moved data in ES:EDI with DS:ESI
                      	   191M 	.endif
                      	   192M 	.if d = w
                      	   193M #		addr16
                      	   194M 		repe
                      	   195M 		cmpsw  # COMPARE moved data in ES:EDI with DS:ESI
                      	   196M 	.endif
                      	   197M 	.if d = d
                      	   198M #		addr16
04:0000125D F3        	   199M 		repe
04:0000125E 66A7      	   200M 		cmpsl  # COMPARE moved data in ES:EDI with DS:ESI
                      	   201M 	.endif
04:00001260 6683F900  	   202M 	cmp $0,%ecx
04:00001264 0F854712  	   203M 	jne error           # ECX must be 0
04:00001268 6681FEFFFF	   204M 	cmp $off_cmp,%esi
04:0000126D 0100
04:0000126F 0F853C12  	   205M 	jne error
04:00001273 6681FFFFFF	   206M 	cmp $off_cmp,%edi
04:00001278 0100
04:0000127A 0F853112  	   207M 	jne error
                      	   249: 
                      	   250: 	advTestSegReal
                      	     1M 	advTestBase
                      	     1M 	.set TEST_BASE1,TEST_BASE1+0x1000
                      	     2M 	.set TEST_BASE2,TEST_BASE2+0x1000
                      	     2M 	.set D1_SEG_REAL,TEST_BASE1 >> 4
                      	     3M 	.set D2_SEG_REAL,TEST_BASE2 >> 4
04:0000127E C7C200C2  	     4M 	mov $D1_SEG_REAL,%dx
04:00001282 8EDA      	     5M 	mov %dx,%ds
04:00001284 C7C200C4  	     6M 	mov $D2_SEG_REAL,%dx
04:00001288 8EC2      	     7M 	mov %dx,%es
                      	   251: 
                      	   252: .include "call_m.asm"

Source: "call_m.asm"
                      	     1: #
                      	     2: #   Tests Call near by displacement and register indirect
                      	     3: #   Stack must be initilized.
                      	     4: #   %1: stack pointer register
                      	     5: #   Uses: AX, EBX, Flags
                      	     6: #
                      	     7: .macro testCallNear arg1
                      	     8: 
                      	     9: 	.ifc \arg1, sp
                      	    10: 		mov %\arg1,%ax
                      	    11: rel16\@:
                      	    12: 		clc
                      	    13: #		data16
                      	    14: 		callw nearfn16\@
                      	    15: 		jnc error
                      	    16: 		jmp rel32\@
                      	    17: nearfn16\@:
                      	    18: 		sub $2,%ax
                      	    19: 		cmp %ax,%\arg1
                      	    20: 		jne error
                      	    21: 		add $2,%ax
                      	    22: 		stc
                      	    23: #		data16
                      	    24: 		ret
                      	    25: 		jmp error
                      	    26: 
                      	    27: rel32\@:
                      	    28: 		clc
                      	    29: 		data32
                      	    30: 		call nearfn32\@
                      	    31: 		jnc error
                      	    32: 		jmp rm16\@
                      	    33: nearfn32\@:
                      	    34: 		sub $4,%ax
                      	    35: 		cmp %ax,%\arg1
                      	    36: 		jne error
                      	    37: 		add $4,%ax
                      	    38: 		stc
                      	    39: 		data32
                      	    40: 		ret
                      	    41: 		jmp error
                      	    42: 
                      	    43: rm16\@:
                      	    44: 		clc
                      	    45: 		mov $nearfn16\@,%bx
                      	    46: #		data16
                      	    47: 		call %bx
                      	    48: 		jnc error
                      	    49: rm32\@:
                      	    50: 		clc
                      	    51: 		mov $nearfn32\@-TEST_CODE,%ebx
                      	    52: 		call %ebx
                      	    53: 		jnc error
                      	    54: 	.else
                      	    55: 		mov %\arg1,%eax
                      	    56: rel16\@:
                      	    57: 		clc
                      	    58: #		data16
                      	    59: 		callw nearfn16\@
                      	    60: 		jnc error
                      	    61: 		jmp rel32\@
                      	    62: nearfn16\@:
                      	    63: 		sub $2,%eax
                      	    64: 		cmp %eax,%\arg1
                      	    65: 		jne error
                      	    66: 		add $2,%eax
                      	    67: 		stc
                      	    68: #		data16
                      	    69: 		ret
                      	    70: 		jmp error
                      	    71: 
                      	    72: rel32\@:
                      	    73: 		clc
                      	    74: #		data32
                      	    75: 		calll nearfn32\@
                      	    76: 		jnc error
                      	    77: 		jmp rm16\@
                      	    78: nearfn32\@:
                      	    79: 		sub $4,%eax
                      	    80: 		cmp %eax,%\arg1
                      	    81: 		jne error
                      	    82: 		add $4,%eax
                      	    83: 		stc
                      	    84: 		data32
                      	    85: 		ret
                      	    86: 		jmp error
                      	    87: 
                      	    88: rm16\@:
                      	    89: 		clc
                      	    90: 		mov $nearfn16\@,%bx
                      	    91: #		data16
                      	    92: 		call %bx
                      	    93: 		jnc error
                      	    94: rm32\@:
                      	    95: 		clc
                      	    96: 		mov $nearfn32\@-TEST_CODE,%ebx
                      	    97: #		data32
                      	    98: 		call %ebx
                      	    99: 		jnc error
                      	   100: 	.endif
                      	   101: .endm
                      	   102: 
                      	   103: #
                      	   104: #   Tests Call far by immediate and memory pointers
                      	   105: #   Stack must be initilized
                      	   106: #   %1: code segment
                      	   107: #   Uses: AX, Flags, DS:SI as scratch memory
                      	   108: #
                      	   109: .macro testCallFar arg1
                      	   110: 	mov %sp,%ax
                      	   111: 
                      	   112: 	clc
                      	   113: #	data16
                      	   114: 	callw $\arg1,$farfn16\@
                      	   115: 	jnc error
                      	   116: 	jmp o32\@
                      	   117: farfn16\@:
                      	   118: 	sub $4,%ax
                      	   119: 	cmp %ax,%sp
                      	   120: 	jne error
                      	   121: 	add $4,%ax
                      	   122: 	stc
                      	   123: #	data16
                      	   124: 	retl
                      	   125: 	jmp error
                      	   126: 
                      	   127: o32\@:
                      	   128: 	clc
                      	   129: 	calll $\arg1,$farfn32\@
                      	   130: 	jnc error
                      	   131: 	jmp m1616\@
                      	   132: farfn32\@:
                      	   133: 	sub $8,%ax
                      	   134: 	cmp %ax,%sp
                      	   135: 	jne error
                      	   136: 	add $8,%ax
                      	   137: 	stc
                      	   138: 	retl
                      	   139: 	jmp error
                      	   140: 
                      	   141: m1616\@:
                      	   142: 	clc
                      	   143: 	movw $farfn16\@,(%si)
                      	   144: 	movw $\arg1,2(%si)
                      	   145: #	data16
                      	   146: 	calll (%si)
                      	   147: 	jnc error
                      	   148: m1632\@:
                      	   149: 	clc
                      	   150: 	movl $farfn32\@-TEST_CODE,(%si)
                      	   151: 	movw $\arg1,4(%si)
                      	   152: #	data32
                      	   153: 	calll (%si)
                      	   154: 	jnc error
                      	   155: exit\@:
                      	   156: .endm
                      	   157: 

Source: "t386.asm"
                      	   253: #-------------------------------------------------------------------------------
                      	   254: 	POST $0x05
04:0000128A B005      	     1M 	movb $0x05,%al
04:0000128C BA9001    	     2M 	movw $POST_PORT,%dx
04:0000128F EE        	     3M 	out %al,%dx
                      	   255: #-------------------------------------------------------------------------------
                      	   256: #
                      	   257: #   Calls in real mode
                      	   258: #
04:00001290 BE0000    	   259: 	mov $0,%si
                      	   260: 	testCallNear sp
                      	     1M 
                      	     2M 	.ifc sp, sp
04:00001293 89E0      	     3M 		mov %sp,%ax
                      	     4M rel1651:
04:00001295 F8        	     5M 		clc
                      	     6M #		data16
04:00001296 E80600    	     7M 		callw nearfn1651
04:00001299 0F831212  	     8M 		jnc error
04:0000129D EB11      	     9M 		jmp rel3251
                      	    10M nearfn1651:
04:0000129F 83E802    	    11M 		sub $2,%ax
04:000012A2 39C4      	    12M 		cmp %ax,%sp
04:000012A4 0F850712  	    13M 		jne error
04:000012A8 83C002    	    14M 		add $2,%ax
04:000012AB F9        	    15M 		stc
                      	    16M #		data16
04:000012AC C3        	    17M 		ret
04:000012AD E9FF11    	    18M 		jmp error
                      	    19M 
                      	    20M rel3251:
04:000012B0 F8        	    21M 		clc
04:000012B1 66        	    22M 		data32
04:000012B2 E80600    	    23M 		call nearfn3251
04:000012B5 0F83F611  	    24M 		jnc error
04:000012B9 EB12      	    25M 		jmp rm1651
                      	    26M nearfn3251:
04:000012BB 83E804    	    27M 		sub $4,%ax
04:000012BE 39C4      	    28M 		cmp %ax,%sp
04:000012C0 0F85EB11  	    29M 		jne error
04:000012C4 83C004    	    30M 		add $4,%ax
04:000012C7 F9        	    31M 		stc
04:000012C8 66        	    32M 		data32
04:000012C9 C3        	    33M 		ret
04:000012CA E9E211    	    34M 		jmp error
                      	    35M 
                      	    36M rm1651:
04:000012CD F8        	    37M 		clc
04:000012CE BB9F12    	    38M 		mov $nearfn1651,%bx
                      	    39M #		data16
04:000012D1 FFD3      	    40M 		call %bx
04:000012D3 0F83D811  	    41M 		jnc error
                      	    42M rm3251:
04:000012D7 F8        	    43M 		clc
04:000012D8 66BBBB1201	    44M 		mov $nearfn3251-TEST_CODE,%ebx
04:000012DD 00
04:000012DE 66FFD3    	    45M 		call %ebx
04:000012E1 0F83CA11  	    46M 		jnc error
                      	    47M 	.else
                      	    48M 		mov %sp,%eax
                      	    49M rel1651:
                      	    50M 		clc
                      	    51M #		data16
                      	    52M 		callw nearfn1651
                      	    53M 		jnc error
                      	    54M 		jmp rel3251
                      	    55M nearfn1651:
                      	    56M 		sub $2,%eax
                      	    57M 		cmp %eax,%sp
                      	    58M 		jne error
                      	    59M 		add $2,%eax
                      	    60M 		stc
                      	    61M #		data16
                      	    62M 		ret
                      	    63M 		jmp error
                      	    64M 
                      	    65M rel3251:
                      	    66M 		clc
                      	    67M #		data32
                      	    68M 		calll nearfn3251
                      	    69M 		jnc error
                      	    70M 		jmp rm1651
                      	    71M nearfn3251:
                      	    72M 		sub $4,%eax
                      	    73M 		cmp %eax,%sp
                      	    74M 		jne error
                      	    75M 		add $4,%eax
                      	    76M 		stc
                      	    77M 		data32
                      	    78M 		ret
                      	    79M 		jmp error
                      	    80M 
                      	    81M rm1651:
                      	    82M 		clc
                      	    83M 		mov $nearfn1651,%bx
                      	    84M #		data16
                      	    85M 		call %bx
                      	    86M 		jnc error
                      	    87M rm3251:
                      	    88M 		clc
                      	    89M 		mov $nearfn3251-TEST_CODE,%ebx
                      	    90M #		data32
                      	    91M 		call %ebx
                      	    92M 		jnc error
                      	    93M 	.endif
                      	   261: 	testCallFar C_SEG_REAL
04:000012E5 89E0      	     1M 	mov %sp,%ax
                      	     2M 
04:000012E7 F8        	     3M 	clc
                      	     4M #	data16
04:000012E8 9A00F0F312	     5M 	callw $C_SEG_REAL,$farfn1652
04:000012ED 0F83BE11  	     6M 	jnc error
04:000012F1 EB12      	     7M 	jmp o3252
                      	     8M farfn1652:
04:000012F3 83E804    	     9M 	sub $4,%ax
04:000012F6 39C4      	    10M 	cmp %ax,%sp
04:000012F8 0F85B311  	    11M 	jne error
04:000012FC 83C004    	    12M 	add $4,%ax
04:000012FF F9        	    13M 	stc
                      	    14M #	data16
04:00001300 66C3      	    15M 	retl
04:00001302 E9AA11    	    16M 	jmp error
                      	    17M 
                      	    18M o3252:
04:00001305 F8        	    19M 	clc
04:00001306 669A00F014	    20M 	calll $C_SEG_REAL,$farfn3252
04:0000130B 130000
04:0000130E 0F839D11  	    21M 	jnc error
04:00001312 EB12      	    22M 	jmp m161652
                      	    23M farfn3252:
04:00001314 83E808    	    24M 	sub $8,%ax
04:00001317 39C4      	    25M 	cmp %ax,%sp
04:00001319 0F859211  	    26M 	jne error
04:0000131D 83C008    	    27M 	add $8,%ax
04:00001320 F9        	    28M 	stc
04:00001321 66C3      	    29M 	retl
04:00001323 E98911    	    30M 	jmp error
                      	    31M 
                      	    32M m161652:
04:00001326 F8        	    33M 	clc
04:00001327 C704F312  	    34M 	movw $farfn1652,(%si)
04:0000132B C7440200F0	    35M 	movw $C_SEG_REAL,2(%si)
                      	    36M #	data16
04:00001330 66FF14    	    37M 	calll (%si)
04:00001333 0F837811  	    38M 	jnc error
                      	    39M m163252:
04:00001337 F8        	    40M 	clc
04:00001338 66C7041413	    41M 	movl $farfn3252-TEST_CODE,(%si)
04:0000133D 0100
04:0000133F C7440400F0	    42M 	movw $C_SEG_REAL,4(%si)
                      	    43M #	data32
04:00001344 66FF14    	    44M 	calll (%si)
04:00001347 0F836411  	    45M 	jnc error
                      	    46M exit52:
                      	   262: 
                      	   263: 	advTestSegReal
                      	     1M 	advTestBase
                      	     1M 	.set TEST_BASE1,TEST_BASE1+0x1000
                      	     2M 	.set TEST_BASE2,TEST_BASE2+0x1000
                      	     2M 	.set D1_SEG_REAL,TEST_BASE1 >> 4
                      	     3M 	.set D2_SEG_REAL,TEST_BASE2 >> 4
04:0000134B C7C200C3  	     4M 	mov $D1_SEG_REAL,%dx
04:0000134F 8EDA      	     5M 	mov %dx,%ds
04:00001351 C7C200C5  	     6M 	mov $D2_SEG_REAL,%dx
04:00001355 8EC2      	     7M 	mov %dx,%es
                      	   264: 
                      	   265: 
                      	   266: .include "load_ptr_m.asm"

Source: "load_ptr_m.asm"
                      	     1: #
                      	     2: #   Tests LSS,LDS,LES,LFS,LGS in 16 and 32 bit mode
                      	     3: #   %1 segment register name, one of ss,ds,es,fs,gs
                      	     4: #   [ed:di] memory address to use for the pointer
                      	     5: #   Uses: nothing
                      	     6: #
                      	     7: 
                      	     8: .macro testLoadPtr arg1
                      	     9: 	mov %\arg1,%cx
                      	    10: 	mov %es,%dx
                      	    11: 
                      	    12: 	movw $0x1234,%es:(%di)
                      	    13: 	movw $0xabcd,%es:2(%di)
                      	    14: 	l\arg1 %es:(%di),%bx
                      	    15: 	mov %\arg1,%ax
                      	    16: 	cmp $0xabcd,%ax
                      	    17: 	jne error
                      	    18: 	cmp $0x1234,%bx
                      	    19: 	jne error
                      	    20: 
                      	    21: 	mov %dx,%es
                      	    22: 
                      	    23: 	movl $0x12345678,%es:(%di)
                      	    24: 	movw $0xbcde,%es:4(%di)
                      	    25: 	l\arg1 %es:(%di),%ebx
                      	    26: 	mov %\arg1,%ax
                      	    27: 	cmp $0xbcde,%ax
                      	    28: 	jne error
                      	    29: 	cmp $0x12345678,%ebx
                      	    30: 	jne error
                      	    31: 
                      	    32: 	mov %dx,%es
                      	    33: 	mov %cx,%\arg1
                      	    34: .endm
                      	    35: 

Source: "t386.asm"
                      	   267: #-------------------------------------------------------------------------------
                      	   268: 	POST $0x06
04:00001357 B006      	     1M 	movb $0x06,%al
04:00001359 BA9001    	     2M 	movw $POST_PORT,%dx
04:0000135C EE        	     3M 	out %al,%dx
                      	   269: #-------------------------------------------------------------------------------
                      	   270: #
                      	   271: #   Load full pointer in real mode
                      	   272: #
04:0000135D BF0000    	   273: 	mov $0,%di
                      	   274: 	testLoadPtr ss
04:00001360 8CD1      	     1M 	mov %ss,%cx
04:00001362 8CC2      	     2M 	mov %es,%dx
                      	     3M 
04:00001364 26C7053412	     4M 	movw $0x1234,%es:(%di)
04:00001369 26C74502CD	     5M 	movw $0xabcd,%es:2(%di)
04:0000136E AB
04:0000136F 260FB21D  	     6M 	lss %es:(%di),%bx
04:00001373 8CD0      	     7M 	mov %ss,%ax
04:00001375 3DCDAB    	     8M 	cmp $0xabcd,%ax
04:00001378 0F853311  	     9M 	jne error
04:0000137C 81FB3412  	    10M 	cmp $0x1234,%bx
04:00001380 0F852B11  	    11M 	jne error
                      	    12M 
04:00001384 8EC2      	    13M 	mov %dx,%es
                      	    14M 
04:00001386 6626C70578	    15M 	movl $0x12345678,%es:(%di)
04:0000138B 563412
04:0000138E 26C74504DE	    16M 	movw $0xbcde,%es:4(%di)
04:00001393 BC
04:00001394 66260FB21D	    17M 	lss %es:(%di),%ebx
04:00001399 8CD0      	    18M 	mov %ss,%ax
04:0000139B 3DDEBC    	    19M 	cmp $0xbcde,%ax
04:0000139E 0F850D11  	    20M 	jne error
04:000013A2 6681FB7856	    21M 	cmp $0x12345678,%ebx
04:000013A7 3412
04:000013A9 0F850211  	    22M 	jne error
                      	    23M 
04:000013AD 8EC2      	    24M 	mov %dx,%es
04:000013AF 8ED1      	    25M 	mov %cx,%ss
                      	   275: 	testLoadPtr ds
04:000013B1 8CD9      	     1M 	mov %ds,%cx
04:000013B3 8CC2      	     2M 	mov %es,%dx
                      	     3M 
04:000013B5 26C7053412	     4M 	movw $0x1234,%es:(%di)
04:000013BA 26C74502CD	     5M 	movw $0xabcd,%es:2(%di)
04:000013BF AB
04:000013C0 26C51D    	     6M 	lds %es:(%di),%bx
04:000013C3 8CD8      	     7M 	mov %ds,%ax
04:000013C5 3DCDAB    	     8M 	cmp $0xabcd,%ax
04:000013C8 0F85E310  	     9M 	jne error
04:000013CC 81FB3412  	    10M 	cmp $0x1234,%bx
04:000013D0 0F85DB10  	    11M 	jne error
                      	    12M 
04:000013D4 8EC2      	    13M 	mov %dx,%es
                      	    14M 
04:000013D6 6626C70578	    15M 	movl $0x12345678,%es:(%di)
04:000013DB 563412
04:000013DE 26C74504DE	    16M 	movw $0xbcde,%es:4(%di)
04:000013E3 BC
04:000013E4 6626C51D  	    17M 	lds %es:(%di),%ebx
04:000013E8 8CD8      	    18M 	mov %ds,%ax
04:000013EA 3DDEBC    	    19M 	cmp $0xbcde,%ax
04:000013ED 0F85BE10  	    20M 	jne error
04:000013F1 6681FB7856	    21M 	cmp $0x12345678,%ebx
04:000013F6 3412
04:000013F8 0F85B310  	    22M 	jne error
                      	    23M 
04:000013FC 8EC2      	    24M 	mov %dx,%es
04:000013FE 8ED9      	    25M 	mov %cx,%ds
                      	   276: 	testLoadPtr es
04:00001400 8CC1      	     1M 	mov %es,%cx
04:00001402 8CC2      	     2M 	mov %es,%dx
                      	     3M 
04:00001404 26C7053412	     4M 	movw $0x1234,%es:(%di)
04:00001409 26C74502CD	     5M 	movw $0xabcd,%es:2(%di)
04:0000140E AB
04:0000140F 26C41D    	     6M 	les %es:(%di),%bx
04:00001412 8CC0      	     7M 	mov %es,%ax
04:00001414 3DCDAB    	     8M 	cmp $0xabcd,%ax
04:00001417 0F859410  	     9M 	jne error
04:0000141B 81FB3412  	    10M 	cmp $0x1234,%bx
04:0000141F 0F858C10  	    11M 	jne error
                      	    12M 
04:00001423 8EC2      	    13M 	mov %dx,%es
                      	    14M 
04:00001425 6626C70578	    15M 	movl $0x12345678,%es:(%di)
04:0000142A 563412
04:0000142D 26C74504DE	    16M 	movw $0xbcde,%es:4(%di)
04:00001432 BC
04:00001433 6626C41D  	    17M 	les %es:(%di),%ebx
04:00001437 8CC0      	    18M 	mov %es,%ax
04:00001439 3DDEBC    	    19M 	cmp $0xbcde,%ax
04:0000143C 0F856F10  	    20M 	jne error
04:00001440 6681FB7856	    21M 	cmp $0x12345678,%ebx
04:00001445 3412
04:00001447 0F856410  	    22M 	jne error
                      	    23M 
04:0000144B 8EC2      	    24M 	mov %dx,%es
04:0000144D 8EC1      	    25M 	mov %cx,%es
                      	   277: 	testLoadPtr fs
04:0000144F 8CE1      	     1M 	mov %fs,%cx
04:00001451 8CC2      	     2M 	mov %es,%dx
                      	     3M 
04:00001453 26C7053412	     4M 	movw $0x1234,%es:(%di)
04:00001458 26C74502CD	     5M 	movw $0xabcd,%es:2(%di)
04:0000145D AB
04:0000145E 260FB41D  	     6M 	lfs %es:(%di),%bx
04:00001462 8CE0      	     7M 	mov %fs,%ax
04:00001464 3DCDAB    	     8M 	cmp $0xabcd,%ax
04:00001467 0F854410  	     9M 	jne error
04:0000146B 81FB3412  	    10M 	cmp $0x1234,%bx
04:0000146F 0F853C10  	    11M 	jne error
                      	    12M 
04:00001473 8EC2      	    13M 	mov %dx,%es
                      	    14M 
04:00001475 6626C70578	    15M 	movl $0x12345678,%es:(%di)
04:0000147A 563412
04:0000147D 26C74504DE	    16M 	movw $0xbcde,%es:4(%di)
04:00001482 BC
04:00001483 66260FB41D	    17M 	lfs %es:(%di),%ebx
04:00001488 8CE0      	    18M 	mov %fs,%ax
04:0000148A 3DDEBC    	    19M 	cmp $0xbcde,%ax
04:0000148D 0F851E10  	    20M 	jne error
04:00001491 6681FB7856	    21M 	cmp $0x12345678,%ebx
04:00001496 3412
04:00001498 0F851310  	    22M 	jne error
                      	    23M 
04:0000149C 8EC2      	    24M 	mov %dx,%es
04:0000149E 8EE1      	    25M 	mov %cx,%fs
                      	   278: 	testLoadPtr gs
04:000014A0 8CE9      	     1M 	mov %gs,%cx
04:000014A2 8CC2      	     2M 	mov %es,%dx
                      	     3M 
04:000014A4 26C7053412	     4M 	movw $0x1234,%es:(%di)
04:000014A9 26C74502CD	     5M 	movw $0xabcd,%es:2(%di)
04:000014AE AB
04:000014AF 260FB51D  	     6M 	lgs %es:(%di),%bx
04:000014B3 8CE8      	     7M 	mov %gs,%ax
04:000014B5 3DCDAB    	     8M 	cmp $0xabcd,%ax
04:000014B8 0F85F30F  	     9M 	jne error
04:000014BC 81FB3412  	    10M 	cmp $0x1234,%bx
04:000014C0 0F85EB0F  	    11M 	jne error
                      	    12M 
04:000014C4 8EC2      	    13M 	mov %dx,%es
                      	    14M 
04:000014C6 6626C70578	    15M 	movl $0x12345678,%es:(%di)
04:000014CB 563412
04:000014CE 26C74504DE	    16M 	movw $0xbcde,%es:4(%di)
04:000014D3 BC
04:000014D4 66260FB51D	    17M 	lgs %es:(%di),%ebx
04:000014D9 8CE8      	    18M 	mov %gs,%ax
04:000014DB 3DDEBC    	    19M 	cmp $0xbcde,%ax
04:000014DE 0F85CD0F  	    20M 	jne error
04:000014E2 6681FB7856	    21M 	cmp $0x12345678,%ebx
04:000014E7 3412
04:000014E9 0F85C20F  	    22M 	jne error
                      	    23M 
04:000014ED 8EC2      	    24M 	mov %dx,%es
04:000014EF 8EE9      	    25M 	mov %cx,%gs
                      	   279: 
                      	   280: 	advTestSegReal
                      	     1M 	advTestBase
                      	     1M 	.set TEST_BASE1,TEST_BASE1+0x1000
                      	     2M 	.set TEST_BASE2,TEST_BASE2+0x1000
                      	     2M 	.set D1_SEG_REAL,TEST_BASE1 >> 4
                      	     3M 	.set D2_SEG_REAL,TEST_BASE2 >> 4
04:000014F1 C7C200C4  	     4M 	mov $D1_SEG_REAL,%dx
04:000014F5 8EDA      	     5M 	mov %dx,%ds
04:000014F7 C7C200C6  	     6M 	mov $D2_SEG_REAL,%dx
04:000014FB 8EC2      	     7M 	mov %dx,%es
                      	   281: 
                      	   282: # ==============================================================================
                      	   283: #	Protected mode tests
                      	   284: # ==============================================================================
                      	   285: 
                      	   286: #-------------------------------------------------------------------------------
                      	   287: 	POST $0x08
04:000014FD B008      	     1M 	movb $0x08,%al
04:000014FF BA9001    	     2M 	movw $POST_PORT,%dx
04:00001502 EE        	     3M 	out %al,%dx
                      	   288: #-------------------------------------------------------------------------------
                      	   289: #
                      	   290: #   GDT, LDT, PDT, and PT setup, enter protected mode
                      	   291: #
04:00001503 EB12      	   292: 	jmp initGDT
                      	   293: 
                      	   294: .set ESP_R0_PROT,0x0000FFFF
                      	   295: .set ESP_R3_PROT,0x00007FFF
                      	   296: 
                      	   297: .include "protected_m.asm"

Source: "protected_m.asm"
                      	     1: #
                      	     2: # Advances the base address of data segments used by tests, D1_SEG_PROT and
                      	     3: # D2_SEG_PROT.
                      	     4: #
                      	     5: # Loads DS with D1_SEG_PROT and ES with D2_SEG_PROT.
                      	     6: #
                      	     7: .macro advTestSegProt
                      	     8: 	advTestBase
                      	     9: 	updLDTDescBase D1_SEG_PROT,TEST_BASE1
                      	    10: 	updLDTDescBase D2_SEG_PROT,TEST_BASE2
                      	    11: 	mov $D1_SEG_PROT,%dx
                      	    12: 	mov %dx,%ds
                      	    13: 	mov $D2_SEG_PROT,%dx
                      	    14: 	mov %dx,%es
                      	    15: .endm
                      	    16: 
                      	    17: 
                      	    18: #
                      	    19: #   Defines an interrupt gate in ROM, given a selector (%1) and an offset (%2)
                      	    20: #
                      	    21: .macro defIntGate arg1,arg2
                      	    22: 	.2byte (\arg2 & 0xffff) # OFFSET 15-0
                      	    23: 	.2byte \arg1 	# SELECTOR
                      	    24: 	.2byte ACC_TYPE_GATE386_INT | ACC_PRESENT # acc byte
                      	    25: 	.2byte (\arg2 >> 16) & 0xffff # OFFSET 31-16
                      	    26: .endm
                      	    27: 
                      	    28: .set GDTSelDesc,0
                      	    29: #
                      	    30: #   Defines a GDT descriptor in ROM, given a name (%1), base (%2), limit (%3),
                      	    31: #   acc byte (%4), and ext nibble (%5)
                      	    32: #
                      	    33: .macro defGDTDescROM arg1,arg2,arg3,arg4,arg5
                      	    34: 	.ifnc \arg1, 0
                      	    35: 	.set \arg1,GDTSelDesc
                      	    36: 	.endif
                      	    37: 	.2byte (\arg3 & 0x0000ffff) # LIMIT 15-0
                      	    38: 	.2byte (\arg2 & 0x0000ffff) # BASE 15-0
                      	    39: 	.2byte ((\arg2 & 0x00ff0000) >> 16) | \arg4 # BASE 23-16 | acc byte
                      	    40: 	.2byte ((\arg3 & 0x000f0000) >> 16) | \arg5 | ((\arg2 & 0xff000000) >> 16) # LIMIT 19-16 | ext nibble | BASE 31-24
                      	    41: 	.ifnc \arg1, 0
                      	    42: 	.set GDTSelDesc,GDTSelDesc+8
                      	    43: 	.endif
                      	    44: .endm
                      	    45: #
                      	    46: #   Defines a GDT descriptor in RAM, given a name (%1), base (%2), limit (%3),
                      	    47: #   acc byte (%4), and ext nibble (%5)
                      	    48: #
                      	    49: .macro defGDTDesc arg1,arg2=0,arg3=0,arg4=0,arg5=0
                      	    50: 	.ifnc \arg1, 0
                      	    51: 	.set \arg1,GDTSelDesc
                      	    52: 	.endif
                      	    53: 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
                      	    54: 	mov $\arg1,%eax
                      	    55: 	mov $\arg2,%esi
                      	    56: 	mov $\arg3,%edi
                      	    57: 	mov $\arg4|\arg5,%dx
                      	    58: 	initDescriptor
                      	    59: 	.ifnc \arg1, 0
                      	    60: 	.set GDTSelDesc,GDTSelDesc+8
                      	    61: 	.endif
                      	    62: .endm
                      	    63: 
                      	    64: #
                      	    65: #   Defines a LDT descriptor, given a name (%1), base (%2), limit (%3), type (%4), and ext (%5)
                      	    66: #
                      	    67: .set LDTSelDesc,4
                      	    68: .macro defLDTDesc arg1,arg2,arg3,arg4,arg5=0
                      	    69: 	.set \arg1,LDTSelDesc
                      	    70: 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
                      	    71: 	mov $\arg1,%eax
                      	    72: 	mov $\arg2,%esi
                      	    73: 	mov $\arg3,%edi
                      	    74: 	mov $\arg4|\arg5,%dx
                      	    75: 	initDescriptor
                      	    76: 	.set LDTSelDesc,LDTSelDesc+8
                      	    77: .endm
                      	    78: 
                      	    79: #
                      	    80: #   Updates a LDT descriptor, given a name (%1), base (%2), limit (%3), type (%4), and ext (%5)
                      	    81: #
                      	    82: .macro updLDTDesc arg1,arg2,arg3,arg4,arg5
                      	    83: 	pushad
                      	    84: 	mov %ds,%ax
                      	    85: 	push %ax
                      	    86: 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
                      	    87: 	mov $\arg1,%eax
                      	    88: 	mov $\arg2,%esi
                      	    89: 	mov $\arg3,%edi
                      	    90: 	mov $\arg4|\arg5,%dx
                      	    91: 	call initDescriptorProt
                      	    92: 	pop %ax
                      	    93: 	mov %ax,%ds
                      	    94: 	popad
                      	    95: .endm
                      	    96: 
                      	    97: #
                      	    98: # Updates the access byte of a descriptor in the LDT
                      	    99: # %1 LDT selector
                      	   100: # %2 access byte new value (ACC_* or'd equs)
                      	   101: # Uses DS
                      	   102: 
                      	   103: .macro updLDTDescAcc arg1,arg2
                      	   104: 	pushad
                      	   105: 	pushf
                      	   106: 	lds %cs:ptrLDTprot,%ebx
                      	   107: 	add $(\arg1) & 0xFFF8,%ebx
                      	   108: 	movb $(\arg2)>>8,5(%ebx) # acc byte
                      	   109: 	popf
                      	   110: 	popad
                      	   111: .endm
                      	   112: 
                      	   113: #
                      	   114: # Updates the base of a descriptor in the LDT
                      	   115: # %1 LDT selector
                      	   116: # %2 new base
                      	   117: # Uses DS,EBX,flags
                      	   118: 
                      	   119: .macro updLDTDescBase arg1,arg2
                      	   120: 	lds %cs:ptrLDTprot,%ebx
                      	   121: 	add $(\arg1) & 0xFFF8,%ebx
                      	   122: 	movw $(\arg2)&0xFFFF,2(%ebx)      # BASE 15-0
                      	   123: 	movb $((\arg2)>>16)&0xFF,4(%ebx) 	# BASE 23-16
                      	   124: 	movb $((\arg2)>>24)&0xFF,7(%ebx) 	# BASE 31-24
                      	   125: .endm
                      	   126: 
                      	   127: #
                      	   128: # Updates the values of a GDT's entry with a Call Gate
                      	   129: # %1 GDT selector
                      	   130: # %2 destination selector
                      	   131: # %3 destination offset
                      	   132: # %4 word count
                      	   133: # %5 DPL
                      	   134: #
                      	   135: .macro updCallGate arg1,arg2,arg3,arg4,arg5
                      	   136: 	lfs %cs:ptrGDTprot,%ebx
                      	   137: 	mov $\arg1,%eax
                      	   138: 	mov $\arg2,%esi
                      	   139: 	mov $\arg3,%edi
                      	   140: 	mov $\arg4|\arg5,%dx
                      	   141: 	call initCallGate
                      	   142: .endm
                      	   143: 
                      	   144: 
                      	   145: 
                      	   146: 
                      	   147: #
                      	   148: # Loads SS:ESP with a pointer to the prot mode stack
                      	   149: #
                      	   150: .macro loadProtModeStack
                      	   151: 	lss %cs:ptrSSprot,%esp
                      	   152: .endm
                      	   153: 
                      	   154: 
                      	   155: #
                      	   156: # Set a int gate on the IDT in protected mode
                      	   157: #
                      	   158: # %1: vector
                      	   159: # %2: offset
                      	   160: # %3: DPL, use ACC_DPL_* equs (optional)
                      	   161: #
                      	   162: # the stack must be initialized
                      	   163: #
                      	   164: .macro setProtModeIntGate arg1,arg2,arg3
                      	   165: 	pushad
                      	   166: 	pushf
                      	   167: 	mov %ds,%ax  	# save ds
                      	   168: 	push %ax
                      	   169: 	mov $\arg1,%eax
                      	   170: 	mov $\arg2,%edi
                      	   171: 	.if \arg3 != -1
                      	   172: 	mov $\arg3,%dx
                      	   173: 	.else
                      	   174: 	mov %cs,%dx
                      	   175: 	and $7,%dx
                      	   176: 	shl $13,%dx
                      	   177: 	.endif
                      	   178: 	cmp $ACC_DPL_0,%dx
                      	   179: 	jne dpl3\@
                      	   180: dpl0\@:
                      	   181: 	mov $C_SEG_PROT32,%esi
                      	   182: 	jmp cont\@
                      	   183: dpl3\@:
                      	   184: 	mov $CU_SEG_PROT32,%esi
                      	   185: cont\@:
                      	   186: 	mov %cs,%cx
                      	   187: 	test $7,%cx
                      	   188: 	jnz ring3\@
                      	   189: ring0\@:
                      	   190: 	lds (%cs:ptrIDTprot),%ebx
                      	   191: 	jmp call\@
                      	   192: ring3\@:
                      	   193: 	lds (%cs:ptrIDTUprot),%ebx
                      	   194: call\@:
                      	   195: 	call initIntGateProt
                      	   196: 	pop %ax
                      	   197: 	mov %ax,%ds  # restore ds
                      	   198: 	popf
                      	   199: 	popad
                      	   200: .endm
                      	   201: 
                      	   202: #
                      	   203: # Tests a fault
                      	   204: #
                      	   205: # %1: vector
                      	   206: # %2: expected error code
                      	   207: # %3: fault causing instruction (can't be a call unless the call is the faulting instruction)
                      	   208: #
                      	   209: # the stack must be initialized
                      	   210: #
                      	   211: .macro protModeFaultTest arg1,arg2,arg3
                      	   212: 	setProtModeIntGate \arg1, continue\@
                      	   213: test\@:
                      	   214: 	\arg3
                      	   215: 	jmp error
                      	   216: continue\@:
                      	   217: 	protModeExcCheck \arg1, \arg2, test\@
                      	   218: 	setProtModeIntGate \arg1, DefaultExcHandler, ACC_DPL_0
                      	   219: .endm
                      	   220: 
                      	   221: # %1: vector
                      	   222: # %2: expected error code
                      	   223: # %3: the provilege level the test code will run in
                      	   224: # %4: the expected value of pushed EIP (specify if %5 is a call, otherwise use -1)
                      	   225: # %5: fault causing code (can be a call to procedure)
                      	   226: #
                      	   227: # The fault handler is executed in ring 0. The caller must reset the data segments.
                      	   228: #
                      	   229: .macro protModeFaultTestEx arg1,arg2,arg3,arg4,arg5
                      	   230: 	setProtModeIntGate \arg1, continue\@, ACC_DPL_0
                      	   231: test\@:
                      	   232: 	\arg5
                      	   233: 	jmp error
                      	   234: continue\@:
                      	   235: 	.if \arg3 = 0
                      	   236: 		.set expectedCS,C_SEG_PROT32
                      	   237: 	.else
                      	   238: 		.set expectedCS,CU_SEG_PROT32|3
                      	   239: 	.endif
                      	   240: 	.if \arg4 = -1
                      	   241: 		protModeExcCheck \arg1, \arg2, test\@, expectedCS
                      	   242: 	.else
                      	   243: 		protModeExcCheck \arg1, \arg2, \arg4, expectedCS
                      	   244: 	.endif
                      	   245: 	setProtModeIntGate \arg1, DefaultExcHandler, ACC_DPL_0
                      	   246: .endm
                      	   247: 
                      	   248: #
                      	   249: # Checks exception result and restores the previous handler
                      	   250: #
                      	   251: # %1: vector
                      	   252: # %2: expected error code
                      	   253: # %3: expected pushed value of EIP
                      	   254: # %4: expected pushed value of CS (optional)
                      	   255: #
                      	   256: .macro protModeExcCheck arg1,arg2,arg3,arg4
                      	   257: 	.if \arg1 == 8 || (\arg1 > 10 && \arg1 <= 14)
                      	   258: 	.set exc_errcode,4
                      	   259: 	cmpl $\arg2,(%ss:%esp)
                      	   260: 	jne error
                      	   261: 	.else
                      	   262: 	.set exc_errcode,0
                      	   263: 	.endif
                      	   264: 	.if \arg4 != -1
                      	   265: 		cmpl $\arg4,exc_errcode+4(%ss:esp)
                      	   266: 		jne error
                      	   267: 	.else
                      	   268: 		mov %cs,%bx
                      	   269: 		test $7,%bx
                      	   270: 		jnz ring3\@
                      	   271: 		ring0\@:
                      	   272: 		cmpl $C_SEG_PROT32,exc_errcode+4(%ss:%esp) 
                      	   273: 		jne error
                      	   274: 		jmp continue\@
                      	   275: 		ring3\@:
                      	   276: 		cmpl $CU_SEG_PROT32|3,exc_errcode+4(%ss:%esp)
                      	   277: 		jne error
                      	   278: 		continue\@:
                      	   279: 	.endif
                      	   280: 	cmpl $\arg3,exc_errcode(%ss:%esp)
                      	   281: 	jne error
                      	   282: 	add $12+exc_errcode,%esp
                      	   283: .endm
                      	   284: 

Source: "t386.asm"
                      	   298: 
                      	   299: 
                      	   300: #;; support for ROM based GDT (currently unused)
                      	   301: romGDT:
                      	   302: romGDTEnd:
                      	   303: romGDTaddr:
04:00001505 FFFF      	   304: 	.2byte romGDTEnd - romGDT - 1 	# 16-bit limit
04:00001507 05150000  	   305: 	.4byte romGDT  									# 32-bit base address
                      	   306: #;;
                      	   307: 
                      	   308: ptrGDTreal: # pointer to the pmode GDT for real mode code
04:0000150B 00000000  	   309: 	.4byte 0         			# 32-bit offset
04:0000150F 5090      	   310: 	.2byte GDT_SEG_REAL  	# 16-bit segment selector
                      	   311: ptrIDTreal: # pointer to the pmode IDT for real mode code
04:00001511 00000000  	   312: 	.4byte 0
04:00001515 0090      	   313: 	.2byte IDT_SEG_REAL
                      	   314: 
                      	   315: initGDT:
                      	   316: 	# the first descriptor in the GDT is always a dud (the null selector)
                      	   317: 	defGDTDesc 0,0,0,0,0
                      	     1M 	.ifnc 0, 0
                      	     2M 	.set 0,GDTSelDesc
                      	     3M 	.endif
04:00001517 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:0000151C 15
04:0000151D 66B8000000	     5M 	mov $0,%eax
04:00001522 00
04:00001523 66BE000000	     6M 	mov $0,%esi
04:00001528 00
04:00001529 66BF000000	     7M 	mov $0,%edi
04:0000152E 00
04:0000152F BA0000    	     8M 	mov $0|0,%dx
                      	     9M 	initDescriptor
04:00001532 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001537 00
04:00001538 6601C3    	     2M 	add %eax,%ebx
04:0000153B 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:0000153E 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001542 66C1EE10  	     5M 	shr $16,%esi
04:00001546 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001548 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:0000154C 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001550 66C1EF10  	     9M 	shr $16,%edi
04:00001554 89F9      	    10M 	mov %di,%cx
04:00001556 80E10F    	    11M 	and $0x0f,%cl
04:00001559 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:0000155D 80E2F0    	    13M 	and $0xf0,%dl
04:00001560 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001564 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc 0, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   318: 	defGDTDesc C_SEG_PROT16,  0xffff0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_PRESENT
                      	     1M 	.ifnc C_SEG_PROT16, 0
                      	     2M 	.set C_SEG_PROT16,GDTSelDesc
                      	     3M 	.endif
04:00001568 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:0000156D 15
04:0000156E 66B8000000	     5M 	mov $C_SEG_PROT16,%eax
04:00001573 00
04:00001574 66BE0000FF	     6M 	mov $0xffff0000,%esi
04:00001579 FF
04:0000157A 66BFFFFF00	     7M 	mov $0x0000ffff,%edi
04:0000157F 00
04:00001580 BA009A    	     8M 	mov $ACC_TYPE_CODE_R|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:00001583 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001588 00
04:00001589 6601C3    	     2M 	add %eax,%ebx
04:0000158C 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:0000158F 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001593 66C1EE10  	     5M 	shr $16,%esi
04:00001597 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001599 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:0000159D 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000015A1 66C1EF10  	     9M 	shr $16,%edi
04:000015A5 89F9      	    10M 	mov %di,%cx
04:000015A7 80E10F    	    11M 	and $0x0f,%cl
04:000015AA 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000015AE 80E2F0    	    13M 	and $0xf0,%dl
04:000015B1 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000015B5 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc C_SEG_PROT16, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   319: 	defGDTDesc C_SEG_PROT32,  0xffff0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_PRESENT,EXT_32BIT
                      	     1M 	.ifnc C_SEG_PROT32, 0
                      	     2M 	.set C_SEG_PROT32,GDTSelDesc
                      	     3M 	.endif
04:000015B9 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000015BE 15
04:000015BF 66B8080000	     5M 	mov $C_SEG_PROT32,%eax
04:000015C4 00
04:000015C5 66BE0000FF	     6M 	mov $0xffff0000,%esi
04:000015CA FF
04:000015CB 66BFFFFF00	     7M 	mov $0x0000ffff,%edi
04:000015D0 00
04:000015D1 BA409A    	     8M 	mov $ACC_TYPE_CODE_R|ACC_PRESENT|EXT_32BIT,%dx
                      	     9M 	initDescriptor
04:000015D4 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000015D9 00
04:000015DA 6601C3    	     2M 	add %eax,%ebx
04:000015DD 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000015E0 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000015E4 66C1EE10  	     5M 	shr $16,%esi
04:000015E8 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:000015EA 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:000015EE 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000015F2 66C1EF10  	     9M 	shr $16,%edi
04:000015F6 89F9      	    10M 	mov %di,%cx
04:000015F8 80E10F    	    11M 	and $0x0f,%cl
04:000015FB 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000015FF 80E2F0    	    13M 	and $0xf0,%dl
04:00001602 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001606 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc C_SEG_PROT32, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   320: 	defGDTDesc CU_SEG_PROT32, 0xffff0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_PRESENT|ACC_DPL_3,EXT_32BIT
                      	     1M 	.ifnc CU_SEG_PROT32, 0
                      	     2M 	.set CU_SEG_PROT32,GDTSelDesc
                      	     3M 	.endif
04:0000160A 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:0000160F 15
04:00001610 66B8100000	     5M 	mov $CU_SEG_PROT32,%eax
04:00001615 00
04:00001616 66BE0000FF	     6M 	mov $0xffff0000,%esi
04:0000161B FF
04:0000161C 66BFFFFF00	     7M 	mov $0x0000ffff,%edi
04:00001621 00
04:00001622 BA40FA    	     8M 	mov $ACC_TYPE_CODE_R|ACC_PRESENT|ACC_DPL_3|EXT_32BIT,%dx
                      	     9M 	initDescriptor
04:00001625 6625F8FF00	     1M 	and $0xFFF8,%eax
04:0000162A 00
04:0000162B 6601C3    	     2M 	add %eax,%ebx
04:0000162E 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001631 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001635 66C1EE10  	     5M 	shr $16,%esi
04:00001639 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:0000163B 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:0000163F 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001643 66C1EF10  	     9M 	shr $16,%edi
04:00001647 89F9      	    10M 	mov %di,%cx
04:00001649 80E10F    	    11M 	and $0x0f,%cl
04:0000164C 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001650 80E2F0    	    13M 	and $0xf0,%dl
04:00001653 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001657 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc CU_SEG_PROT32, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   321: 	defGDTDesc CC_SEG_PROT32, 0xffff0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_TYPE_CONFORMING|ACC_PRESENT|EXT_32BIT
                      	     1M 	.ifnc CC_SEG_PROT32, 0
                      	     2M 	.set CC_SEG_PROT32,GDTSelDesc
                      	     3M 	.endif
04:0000165B 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001660 15
04:00001661 66B8180000	     5M 	mov $CC_SEG_PROT32,%eax
04:00001666 00
04:00001667 66BE0000FF	     6M 	mov $0xffff0000,%esi
04:0000166C FF
04:0000166D 66BFFFFF00	     7M 	mov $0x0000ffff,%edi
04:00001672 00
04:00001673 BA409E    	     8M 	mov $ACC_TYPE_CODE_R|ACC_TYPE_CONFORMING|ACC_PRESENT|EXT_32BIT|0,%dx
                      	     9M 	initDescriptor
04:00001676 6625F8FF00	     1M 	and $0xFFF8,%eax
04:0000167B 00
04:0000167C 6601C3    	     2M 	add %eax,%ebx
04:0000167F 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001682 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001686 66C1EE10  	     5M 	shr $16,%esi
04:0000168A 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:0000168C 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001690 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001694 66C1EF10  	     9M 	shr $16,%edi
04:00001698 89F9      	    10M 	mov %di,%cx
04:0000169A 80E10F    	    11M 	and $0x0f,%cl
04:0000169D 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000016A1 80E2F0    	    13M 	and $0xf0,%dl
04:000016A4 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000016A8 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc CC_SEG_PROT32, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   322: 	defGDTDesc IDT_SEG_PROT,  0xFFF90400,0x000000ff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc IDT_SEG_PROT, 0
                      	     2M 	.set IDT_SEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:000016AC 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000016B1 15
04:000016B2 66B8200000	     5M 	mov $IDT_SEG_PROT,%eax
04:000016B7 00
04:000016B8 66BE0004F9	     6M 	mov $0xFFF90400,%esi
04:000016BD FF
04:000016BE 66BFFF0000	     7M 	mov $0x000000ff,%edi
04:000016C3 00
04:000016C4 BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:000016C7 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000016CC 00
04:000016CD 6601C3    	     2M 	add %eax,%ebx
04:000016D0 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000016D3 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000016D7 66C1EE10  	     5M 	shr $16,%esi
04:000016DB 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:000016DD 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:000016E1 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000016E5 66C1EF10  	     9M 	shr $16,%edi
04:000016E9 89F9      	    10M 	mov %di,%cx
04:000016EB 80E10F    	    11M 	and $0x0f,%cl
04:000016EE 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000016F2 80E2F0    	    13M 	and $0xf0,%dl
04:000016F5 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000016F9 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc IDT_SEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   323: 	defGDTDesc IDTU_SEG_PROT, 0xFFF90400,0x000000ff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3
                      	     1M 	.ifnc IDTU_SEG_PROT, 0
                      	     2M 	.set IDTU_SEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:000016FD 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001702 15
04:00001703 66B8280000	     5M 	mov $IDTU_SEG_PROT,%eax
04:00001708 00
04:00001709 66BE0004F9	     6M 	mov $0xFFF90400,%esi
04:0000170E FF
04:0000170F 66BFFF0000	     7M 	mov $0x000000ff,%edi
04:00001714 00
04:00001715 BA00F2    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3|0,%dx
                      	     9M 	initDescriptor
04:00001718 6625F8FF00	     1M 	and $0xFFF8,%eax
04:0000171D 00
04:0000171E 6601C3    	     2M 	add %eax,%ebx
04:00001721 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001724 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001728 66C1EE10  	     5M 	shr $16,%esi
04:0000172C 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:0000172E 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001732 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001736 66C1EF10  	     9M 	shr $16,%edi
04:0000173A 89F9      	    10M 	mov %di,%cx
04:0000173C 80E10F    	    11M 	and $0x0f,%cl
04:0000173F 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001743 80E2F0    	    13M 	and $0xf0,%dl
04:00001746 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:0000174A 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc IDTU_SEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   324: 	defGDTDesc GDT_DSEG_PROT, 0xFFF90500,0x000002ff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc GDT_DSEG_PROT, 0
                      	     2M 	.set GDT_DSEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:0000174E 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001753 15
04:00001754 66B8300000	     5M 	mov $GDT_DSEG_PROT,%eax
04:00001759 00
04:0000175A 66BE0005F9	     6M 	mov $0xFFF90500,%esi
04:0000175F FF
04:00001760 66BFFF0200	     7M 	mov $0x000002ff,%edi
04:00001765 00
04:00001766 BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:00001769 6625F8FF00	     1M 	and $0xFFF8,%eax
04:0000176E 00
04:0000176F 6601C3    	     2M 	add %eax,%ebx
04:00001772 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001775 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001779 66C1EE10  	     5M 	shr $16,%esi
04:0000177D 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:0000177F 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001783 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001787 66C1EF10  	     9M 	shr $16,%edi
04:0000178B 89F9      	    10M 	mov %di,%cx
04:0000178D 80E10F    	    11M 	and $0x0f,%cl
04:00001790 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001794 80E2F0    	    13M 	and $0xf0,%dl
04:00001797 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:0000179B 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc GDT_DSEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   325: 	defGDTDesc GDTU_DSEG_PROT,0xFFF90500,0x000002ff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3
                      	     1M 	.ifnc GDTU_DSEG_PROT, 0
                      	     2M 	.set GDTU_DSEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:0000179F 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000017A4 15
04:000017A5 66B8380000	     5M 	mov $GDTU_DSEG_PROT,%eax
04:000017AA 00
04:000017AB 66BE0005F9	     6M 	mov $0xFFF90500,%esi
04:000017B0 FF
04:000017B1 66BFFF0200	     7M 	mov $0x000002ff,%edi
04:000017B6 00
04:000017B7 BA00F2    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3|0,%dx
                      	     9M 	initDescriptor
04:000017BA 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000017BF 00
04:000017C0 6601C3    	     2M 	add %eax,%ebx
04:000017C3 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000017C6 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000017CA 66C1EE10  	     5M 	shr $16,%esi
04:000017CE 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:000017D0 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:000017D4 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000017D8 66C1EF10  	     9M 	shr $16,%edi
04:000017DC 89F9      	    10M 	mov %di,%cx
04:000017DE 80E10F    	    11M 	and $0x0f,%cl
04:000017E1 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000017E5 80E2F0    	    13M 	and $0xf0,%dl
04:000017E8 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000017EC 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc GDTU_DSEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   326: 	defGDTDesc LDT_SEG_PROT,  0xFFF90800,0x000007ff,ACC_TYPE_LDT|ACC_PRESENT
                      	     1M 	.ifnc LDT_SEG_PROT, 0
                      	     2M 	.set LDT_SEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:000017F0 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000017F5 15
04:000017F6 66B8400000	     5M 	mov $LDT_SEG_PROT,%eax
04:000017FB 00
04:000017FC 66BE0008F9	     6M 	mov $0xFFF90800,%esi
04:00001801 FF
04:00001802 66BFFF0700	     7M 	mov $0x000007ff,%edi
04:00001807 00
04:00001808 BA0082    	     8M 	mov $ACC_TYPE_LDT|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:0000180B 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001810 00
04:00001811 6601C3    	     2M 	add %eax,%ebx
04:00001814 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001817 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:0000181B 66C1EE10  	     5M 	shr $16,%esi
04:0000181F 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001821 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001825 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001829 66C1EF10  	     9M 	shr $16,%edi
04:0000182D 89F9      	    10M 	mov %di,%cx
04:0000182F 80E10F    	    11M 	and $0x0f,%cl
04:00001832 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001836 80E2F0    	    13M 	and $0xf0,%dl
04:00001839 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:0000183D 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc LDT_SEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   327: 	defGDTDesc LDT_DSEG_PROT, 0xFFF90800,0x000007ff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc LDT_DSEG_PROT, 0
                      	     2M 	.set LDT_DSEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:00001841 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001846 15
04:00001847 66B8480000	     5M 	mov $LDT_DSEG_PROT,%eax
04:0000184C 00
04:0000184D 66BE0008F9	     6M 	mov $0xFFF90800,%esi
04:00001852 FF
04:00001853 66BFFF0700	     7M 	mov $0x000007ff,%edi
04:00001858 00
04:00001859 BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:0000185C 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001861 00
04:00001862 6601C3    	     2M 	add %eax,%ebx
04:00001865 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001868 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:0000186C 66C1EE10  	     5M 	shr $16,%esi
04:00001870 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001872 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001876 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:0000187A 66C1EF10  	     9M 	shr $16,%edi
04:0000187E 89F9      	    10M 	mov %di,%cx
04:00001880 80E10F    	    11M 	and $0x0f,%cl
04:00001883 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001887 80E2F0    	    13M 	and $0xf0,%dl
04:0000188A 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:0000188E 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc LDT_DSEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   328: 	defGDTDesc PG_SEG_PROT,   0xfff80000,0x0002ffff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc PG_SEG_PROT, 0
                      	     2M 	.set PG_SEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:00001892 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001897 15
04:00001898 66B8500000	     5M 	mov $PG_SEG_PROT,%eax
04:0000189D 00
04:0000189E 66BE0000F8	     6M 	mov $0xfff80000,%esi
04:000018A3 FF
04:000018A4 66BFFFFF02	     7M 	mov $0x0002ffff,%edi
04:000018A9 00
04:000018AA BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:000018AD 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000018B2 00
04:000018B3 6601C3    	     2M 	add %eax,%ebx
04:000018B6 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000018B9 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000018BD 66C1EE10  	     5M 	shr $16,%esi
04:000018C1 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:000018C3 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:000018C7 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000018CB 66C1EF10  	     9M 	shr $16,%edi
04:000018CF 89F9      	    10M 	mov %di,%cx
04:000018D1 80E10F    	    11M 	and $0x0f,%cl
04:000018D4 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000018D8 80E2F0    	    13M 	and $0xf0,%dl
04:000018DB 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000018DF 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc PG_SEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   329: 	defGDTDesc S_SEG_PROT32,  0xfffc0000,0x0008ffff,ACC_TYPE_DATA_W|ACC_PRESENT,EXT_32BIT
                      	     1M 	.ifnc S_SEG_PROT32, 0
                      	     2M 	.set S_SEG_PROT32,GDTSelDesc
                      	     3M 	.endif
04:000018E3 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000018E8 15
04:000018E9 66B8580000	     5M 	mov $S_SEG_PROT32,%eax
04:000018EE 00
04:000018EF 66BE0000FC	     6M 	mov $0xfffc0000,%esi
04:000018F4 FF
04:000018F5 66BFFFFF08	     7M 	mov $0x0008ffff,%edi
04:000018FA 00
04:000018FB BA4092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|EXT_32BIT,%dx
                      	     9M 	initDescriptor
04:000018FE 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001903 00
04:00001904 6601C3    	     2M 	add %eax,%ebx
04:00001907 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:0000190A 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:0000190E 66C1EE10  	     5M 	shr $16,%esi
04:00001912 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001914 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001918 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:0000191C 66C1EF10  	     9M 	shr $16,%edi
04:00001920 89F9      	    10M 	mov %di,%cx
04:00001922 80E10F    	    11M 	and $0x0f,%cl
04:00001925 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001929 80E2F0    	    13M 	and $0xf0,%dl
04:0000192C 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001930 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc S_SEG_PROT32, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   330: 	defGDTDesc SU_SEG_PROT32, 0xfffc0000,0x0008ffff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3,EXT_32BIT
                      	     1M 	.ifnc SU_SEG_PROT32, 0
                      	     2M 	.set SU_SEG_PROT32,GDTSelDesc
                      	     3M 	.endif
04:00001934 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001939 15
04:0000193A 66B8600000	     5M 	mov $SU_SEG_PROT32,%eax
04:0000193F 00
04:00001940 66BE0000FC	     6M 	mov $0xfffc0000,%esi
04:00001945 FF
04:00001946 66BFFFFF08	     7M 	mov $0x0008ffff,%edi
04:0000194B 00
04:0000194C BA40F2    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3|EXT_32BIT,%dx
                      	     9M 	initDescriptor
04:0000194F 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001954 00
04:00001955 6601C3    	     2M 	add %eax,%ebx
04:00001958 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:0000195B 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:0000195F 66C1EE10  	     5M 	shr $16,%esi
04:00001963 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001965 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001969 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:0000196D 66C1EF10  	     9M 	shr $16,%edi
04:00001971 89F9      	    10M 	mov %di,%cx
04:00001973 80E10F    	    11M 	and $0x0f,%cl
04:00001976 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:0000197A 80E2F0    	    13M 	and $0xf0,%dl
04:0000197D 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001981 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc SU_SEG_PROT32, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   331: 	defGDTDesc TSS_PROT,      0xfff94000,0x00000fff,ACC_TYPE_TSS|ACC_PRESENT|ACC_DPL_3
                      	     1M 	.ifnc TSS_PROT, 0
                      	     2M 	.set TSS_PROT,GDTSelDesc
                      	     3M 	.endif
04:00001985 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:0000198A 15
04:0000198B 66B8680000	     5M 	mov $TSS_PROT,%eax
04:00001990 00
04:00001991 66BE0040F9	     6M 	mov $0xfff94000,%esi
04:00001996 FF
04:00001997 66BFFF0F00	     7M 	mov $0x00000fff,%edi
04:0000199C 00
04:0000199D BA00E9    	     8M 	mov $ACC_TYPE_TSS|ACC_PRESENT|ACC_DPL_3|0,%dx
                      	     9M 	initDescriptor
04:000019A0 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000019A5 00
04:000019A6 6601C3    	     2M 	add %eax,%ebx
04:000019A9 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000019AC 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:000019B0 66C1EE10  	     5M 	shr $16,%esi
04:000019B4 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:000019B6 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:000019BA 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:000019BE 66C1EF10  	     9M 	shr $16,%edi
04:000019C2 89F9      	    10M 	mov %di,%cx
04:000019C4 80E10F    	    11M 	and $0x0f,%cl
04:000019C7 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:000019CB 80E2F0    	    13M 	and $0xf0,%dl
04:000019CE 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:000019D2 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc TSS_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   332: 	defGDTDesc TSS_DSEG_PROT, 0xfff94000,0x00000fff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc TSS_DSEG_PROT, 0
                      	     2M 	.set TSS_DSEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:000019D6 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:000019DB 15
04:000019DC 66B8700000	     5M 	mov $TSS_DSEG_PROT,%eax
04:000019E1 00
04:000019E2 66BE0040F9	     6M 	mov $0xfff94000,%esi
04:000019E7 FF
04:000019E8 66BFFF0F00	     7M 	mov $0x00000fff,%edi
04:000019ED 00
04:000019EE BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:000019F1 6625F8FF00	     1M 	and $0xFFF8,%eax
04:000019F6 00
04:000019F7 6601C3    	     2M 	add %eax,%ebx
04:000019FA 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:000019FD 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001A01 66C1EE10  	     5M 	shr $16,%esi
04:00001A05 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001A07 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001A0B 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001A0F 66C1EF10  	     9M 	shr $16,%edi
04:00001A13 89F9      	    10M 	mov %di,%cx
04:00001A15 80E10F    	    11M 	and $0x0f,%cl
04:00001A18 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001A1C 80E2F0    	    13M 	and $0xf0,%dl
04:00001A1F 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001A23 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc TSS_DSEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   333: 	defGDTDesc FLAT_SEG_PROT, 0x00000000,0xffffffff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.ifnc FLAT_SEG_PROT, 0
                      	     2M 	.set FLAT_SEG_PROT,GDTSelDesc
                      	     3M 	.endif
04:00001A27 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001A2C 15
04:00001A2D 66B8780000	     5M 	mov $FLAT_SEG_PROT,%eax
04:00001A32 00
04:00001A33 66BE000000	     6M 	mov $0x00000000,%esi
04:00001A38 00
04:00001A39 66BFFFFFFF	     7M 	mov $0xffffffff,%edi
04:00001A3E FF
04:00001A3F BA0092    	     8M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     9M 	initDescriptor
04:00001A42 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001A47 00
04:00001A48 6601C3    	     2M 	add %eax,%ebx
04:00001A4B 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001A4E 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001A52 66C1EE10  	     5M 	shr $16,%esi
04:00001A56 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001A58 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001A5C 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001A60 66C1EF10  	     9M 	shr $16,%edi
04:00001A64 89F9      	    10M 	mov %di,%cx
04:00001A66 80E10F    	    11M 	and $0x0f,%cl
04:00001A69 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001A6D 80E2F0    	    13M 	and $0xf0,%dl
04:00001A70 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001A74 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc FLAT_SEG_PROT, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   334: 	defGDTDesc RING0_GATE # placeholder for a call gate used to switch to ring 0
                      	     1M 	.ifnc RING0_GATE, 0
                      	     2M 	.set RING0_GATE,GDTSelDesc
                      	     3M 	.endif
04:00001A78 662EC51E0B	     4M 	lds %cs:ptrGDTreal - TEST_CODE,%ebx # this macro is used in real mode to set up prot mode env.
04:00001A7D 15
04:00001A7E 66B8800000	     5M 	mov $RING0_GATE,%eax
04:00001A83 00
04:00001A84 66BE000000	     6M 	mov $0,%esi
04:00001A89 00
04:00001A8A 66BF000000	     7M 	mov $0,%edi
04:00001A8F 00
04:00001A90 BA0000    	     8M 	mov $0|0,%dx
                      	     9M 	initDescriptor
04:00001A93 6625F8FF00	     1M 	and $0xFFF8,%eax
04:00001A98 00
04:00001A99 6601C3    	     2M 	add %eax,%ebx
04:00001A9C 67893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001A9F 67897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001AA3 66C1EE10  	     5M 	shr $16,%esi
04:00001AA7 89F0      	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001AA9 67884304  	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001AAD 67887305  	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001AB1 66C1EF10  	     9M 	shr $16,%edi
04:00001AB5 89F9      	    10M 	mov %di,%cx
04:00001AB7 80E10F    	    11M 	and $0x0f,%cl
04:00001ABA 67884B06  	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001ABE 80E2F0    	    13M 	and $0xf0,%dl
04:00001AC1 67085306  	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001AC5 67886307  	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	    10M 	.ifnc RING0_GATE, 0
                      	    11M 	.set GDTSelDesc,GDTSelDesc+8
                      	    12M 	.endif
                      	   335: 
04:00001AC9 EB6B      	   336: 	jmp initIDT
                      	   337: 
                      	   338: ptrIDTprot: # pointer to the IDT for pmode
04:00001ACB 00000000  	   339: 	.4byte 0         		# 32-bit offset
04:00001ACF 2000      	   340: 	.2byte IDT_SEG_PROT # 16-bit segment selector
                      	   341: ptrIDTUprot: # pointer to the IDT for pmode
04:00001AD1 00000000  	   342: 	.4byte 0            	# 32-bit offset
04:00001AD5 2800      	   343: 	.2byte IDTU_SEG_PROT  # 16-bit segment selector
                      	   344: ptrGDTprot: # pointer to the GDT for pmode (kernel mode data segment)
04:00001AD7 00000000  	   345: 	.4byte 0
04:00001ADB 3000      	   346: 	.2byte GDT_DSEG_PROT
                      	   347: ptrGDTUprot: # pointer to the GDT for pmode (user mode data segment)
04:00001ADD 00000000  	   348: 	.4byte 0
04:00001AE1 3800      	   349: 	.2byte GDTU_DSEG_PROT
                      	   350: ptrLDTprot: # pointer to the LDT for pmode
04:00001AE3 00000000  	   351: 	.4byte 0
04:00001AE7 4800      	   352: 	.2byte LDT_DSEG_PROT
                      	   353: ptrPDprot: # pointer to the Page Directory for pmode
04:00001AE9 00000000  	   354: 	.4byte 0
04:00001AED 5000      	   355: 	.2byte PG_SEG_PROT
                      	   356: ptrPT0prot: # pointer to Page Table 0
04:00001AEF 00100000  	   357: 	.4byte 0x1000
04:00001AF3 5000      	   358: 	.2byte PG_SEG_PROT
                      	   359: ptrPT1prot: # pointer to Page Table 1
04:00001AF5 00200000  	   360: 	.4byte 0x2000
04:00001AF9 5000      	   361: 	.2byte PG_SEG_PROT
                      	   362: ptrSSprot: # pointer to the stack for pmode
04:00001AFB FFFF0000  	   363: 	.4byte ESP_R0_PROT
04:00001AFF 5800      	   364: 	.2byte S_SEG_PROT32
                      	   365: ptrTSSprot: # pointer to the task state segment
04:00001B01 00000000  	   366: 	.4byte 0
04:00001B05 7000      	   367: 	.2byte TSS_DSEG_PROT
                      	   368: addrProtIDT: # address of pmode IDT to be used with lidt
04:00001B07 FF00      	   369: 	.2byte 0xFF              						# 16-bit limit
04:00001B09 0000FFFF  	   370: 	.4byte 0xffff0000|(IDT_SEG_REAL << 4) 	# 32-bit base address
                      	   371: addrGDT: # address of GDT to be used with lgdt
04:00001B0D FF02      	   372: 	.2byte GDT_SEG_LIMIT
04:00001B0F 0005FFFF  	   373: 	.4byte 0xffff0000|(GDT_SEG_REAL << 4)
                      	   374: 
                      	   375: # Initializes an interrupt gate in system memory in real mode
                      	   376: initIntGateReal:
04:00001B13 6660      	   377: 	pushal
                      	   378: 	initIntGate
04:00001B15 66C1E003  	     1M 	shl $3,%eax
04:00001B19 6601C3    	     2M 	add	%eax,%ebx
04:00001B1C 67893B    	     3M 	movw %di,(%ebx)
04:00001B1F 67897302  	     4M 	movw %si,2(%ebx)
04:00001B23 81CA008E  	     5M 	orw $ACC_TYPE_GATE386_INT | ACC_PRESENT, %dx
04:00001B27 67895304  	     6M 	movw %dx,4(%ebx)
04:00001B2B 66C1EF10  	     7M 	shr $16,%edi
04:00001B2F 67897B06  	     8M 	movw %di,6(%ebx)
04:00001B33 6661      	   379: 	popal
04:00001B35 C3        	   380: 	ret
                      	   381: 
                      	   382: initIDT:
04:00001B36 662EC51E11	   383: 	lds %cs:ptrIDTreal-TEST_CODE,%ebx
04:00001B3B 15
04:00001B3C 66BE080000	   384: 	mov $C_SEG_PROT32,%esi
04:00001B41 00
04:00001B42 66BFAF2401	   385: 	mov $DefaultExcHandler-TEST_CODE,%edi
04:00001B47 00
04:00001B48 BA0000    	   386: 	mov $ACC_DPL_0,%dx
                      	   387: .set vector,00
                      	   388: .rept 0x15
                      	   389: 	mov $vector,%eax
                      	   390: 	call initIntGateReal
                      	   391: .set vector,vector+1
                      	   392: .endr
04:00001B4B 66B8000000	     1R 	mov $vector,%eax
04:00001B50 00
04:00001B51 E8BFFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B54 66B8010000	     1R 	mov $vector,%eax
04:00001B59 00
04:00001B5A E8B6FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B5D 66B8020000	     1R 	mov $vector,%eax
04:00001B62 00
04:00001B63 E8ADFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B66 66B8030000	     1R 	mov $vector,%eax
04:00001B6B 00
04:00001B6C E8A4FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B6F 66B8040000	     1R 	mov $vector,%eax
04:00001B74 00
04:00001B75 E89BFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B78 66B8050000	     1R 	mov $vector,%eax
04:00001B7D 00
04:00001B7E E892FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B81 66B8060000	     1R 	mov $vector,%eax
04:00001B86 00
04:00001B87 E889FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B8A 66B8070000	     1R 	mov $vector,%eax
04:00001B8F 00
04:00001B90 E880FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B93 66B8080000	     1R 	mov $vector,%eax
04:00001B98 00
04:00001B99 E877FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001B9C 66B8090000	     1R 	mov $vector,%eax
04:00001BA1 00
04:00001BA2 E86EFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BA5 66B80A0000	     1R 	mov $vector,%eax
04:00001BAA 00
04:00001BAB E865FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BAE 66B80B0000	     1R 	mov $vector,%eax
04:00001BB3 00
04:00001BB4 E85CFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BB7 66B80C0000	     1R 	mov $vector,%eax
04:00001BBC 00
04:00001BBD E853FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BC0 66B80D0000	     1R 	mov $vector,%eax
04:00001BC5 00
04:00001BC6 E84AFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BC9 66B80E0000	     1R 	mov $vector,%eax
04:00001BCE 00
04:00001BCF E841FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BD2 66B80F0000	     1R 	mov $vector,%eax
04:00001BD7 00
04:00001BD8 E838FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BDB 66B8100000	     1R 	mov $vector,%eax
04:00001BE0 00
04:00001BE1 E82FFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BE4 66B8110000	     1R 	mov $vector,%eax
04:00001BE9 00
04:00001BEA E826FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BED 66B8120000	     1R 	mov $vector,%eax
04:00001BF2 00
04:00001BF3 E81DFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BF6 66B8130000	     1R 	mov $vector,%eax
04:00001BFB 00
04:00001BFC E814FF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
04:00001BFF 66B8140000	     1R 	mov $vector,%eax
04:00001C04 00
04:00001C05 E80BFF    	     2R 	call initIntGateReal
                      	     3R .set vector,vector+1
                      	   393: 
04:00001C08 EB00      	   394: 	jmp initPaging
                      	   395: 
                      	   396: initPaging:
                      	   397: #
                      	   398: # pages:
                      	   399: #  FFF90000-FFF90FFF   1  1000h   4K IDTs, GDT and LDT
                      	   400: #  FFF80000-FFF81FFF   1  2000h   8K page directory
                      	   401: #  FFF82000-FFF83FFF   1  2000h   8K page table 0
                      	   402: #  FFF84000-FFF85FFF   1  2000h   8K page table 1
                      	   403: #  FFF94000-FFF95FFF   1  2000h   8K task switch segments
                      	   404: #  FFFC0000-FFFCFFFF  8  10000h   64K stack
                      	   405: #  FFFF0000-FFFFFFFF  8  10000h   64K tests
                      	   406: #  FFF86000-FFF87FFF   1  2000h   8K used for page faults (PTE 9Fh)
                      	   407: #
                      	   408: .set PAGE_DIR_ADDR,0x2000
                      	   409: .set PAGE_TBL0_ADDR,PAGE_DIR_ADDR+0x2000
                      	   410: .set PAGE_TBL1_ADDR,PAGE_DIR_ADDR+0x4000
                      	   411: 
                      	   412: #   Now we want to build a page table. We need two pages of
                      	   413: #   8K-aligned physical memory.  We use a hard-coded address, segment 0x8000,
                      	   414: #   corresponding to physical address 0xFFF80000.
                      	   415: #
04:00001C0A 66BE002000	   416: 	mov $PAGE_DIR_ADDR,%esi
04:00001C0F 00
04:00001C10 6689F0    	   417: 	mov %esi,%eax
04:00001C13 66C1E804  	   418: 	shr $4,%eax
04:00001C17 0D0080    	   419: 	or $0x8000,%ax
04:00001C1A 8EC0      	   420: 	mov %ax,%es
                      	   421: #
                      	   422: #   Build a page table at ES:EDI (8000:0000) with only 64 valid PTEs at end,
                      	   423: #   because we're not going to access any memory outside the last 512kB.
                      	   424: #
                      	   425: # The .if is to avoid a long loop during simulation.
                      	   426: .if 0
                      	   427: 	cld
                      	   428: 	xor %edi,%edi
                      	   429: 	mov $1919,%ecx		# ECX == number of dwords to write = ((1024-64)*8)/4-1
                      	   430: 	xor %eax,%eax    	# fill PTEs with 0
                      	   431: 	rep
                      	   432: 	stosl
                      	   433: .endif
04:00001C1C 66BF001E00	   434: 	mov $7680,%edi		# index of last 64 PTEs
04:00001C21 00
04:00001C22 66B97F0000	   435: 	mov $127,%ecx			# ECX = (64 * 8) / 4 - 1
04:00001C27 00
04:00001C28 66BA0000F8	   436: 	mov $0xfff80000,%edx
04:00001C2D FF
                      	   437: .ipt1:
04:00001C2E 66B8150000	   438: 	mov $PTE_PRESENT | PTE_USER | PTE_WRITE,%eax
04:00001C33 00
04:00001C34 6601D0    	   439: 	add %edx,%eax			# add in the address
04:00001C37 66AB      	   440: 	stosl
                      	   441: 	# Bits 32 to 63 can all be zero. The high order page number is not used
                      	   442: 	# because the test system uses only a 32-bit physical address.
04:00001C39 6631C0    	   443: 	xor %eax,%eax			# page table hi order page number
04:00001C3C 66AB      	   444: 	stosl
04:00001C3E 6681C20020	   445: 	add $0x2000,%edx	# increment address to next page
04:00001C43 0000
04:00001C45 E2E7      	   446: 	loop .ipt1
                      	   447: 
                      	   448: switchToProtMode:
04:00001C47 FA        	   449: 	cli 							# make sure interrupts are off now, since we've not initialized the IDT yet
04:00001C48 66        	   450: 	data32
04:00001C49 2E0F011E07	   451: 	lidt %cs:addrProtIDT-TEST_CODE
04:00001C4E 1B
04:00001C4F 66        	   452: 	data32
04:00001C50 2E0F01160D	   453: 	lgdt %cs:addrGDT-TEST_CODE
04:00001C55 1B
04:00001C56 0F22DE    	   454: 	mov %esi,%cr3
04:00001C59 0F20C0    	   455: 	mov %cr0,%eax
04:00001C5C 660D010000	   456: 	or $CR0_MSW_PE | CR0_PG,%eax
04:00001C61 80
04:00001C62 0F22C0    	   457: 	mov %eax,%cr0
04:00001C65 EA08006A1C	   458: 	jmp $C_SEG_PROT32,$toProt32 	# jump to flush the prefetch queue
                      	   459: toProt32:
                      	   460: 	.code32
04:00001C6A E981000000	   461: 	jmp initLDT
                      	   462: 
                      	   463: .include "protected_p.asm"

Source: "protected_p.asm"
                      	     1: # Procedures for 32 bit code segment
                      	     2: 
                      	     3: initIntGateProt:
                      	     4: 	initIntGate
04:00001C6F C1E003    	     1M 	shl $3,%eax
04:00001C72 01C3      	     2M 	add	%eax,%ebx
04:00001C74 66893B    	     3M 	movw %di,(%ebx)
04:00001C77 66897302  	     4M 	movw %si,2(%ebx)
04:00001C7B 6681CA008E	     5M 	orw $ACC_TYPE_GATE386_INT | ACC_PRESENT, %dx
04:00001C80 66895304  	     6M 	movw %dx,4(%ebx)
04:00001C84 C1EF10    	     7M 	shr $16,%edi
04:00001C87 66897B06  	     8M 	movw %di,6(%ebx)
04:00001C8B C3        	     5: 	ret
                      	     6: 
                      	     7: initDescriptorProt:
                      	     8: 	initDescriptor
04:00001C8C 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001C91 01C3      	     2M 	add %eax,%ebx
04:00001C93 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001C96 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001C9A C1EE10    	     5M 	shr $16,%esi
04:00001C9D 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001CA0 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001CA3 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001CA6 C1EF10    	     9M 	shr $16,%edi
04:00001CA9 6689F9    	    10M 	mov %di,%cx
04:00001CAC 80E10F    	    11M 	and $0x0f,%cl
04:00001CAF 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001CB2 80E2F0    	    13M 	and $0xf0,%dl
04:00001CB5 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001CB8 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
04:00001CBB C3        	     9: 	ret
                      	    10: 
                      	    11: #
                      	    12: # Defines a Call Gate in GDT
                      	    13: #
                      	    14: #    7                             0 7                             0
                      	    15: #   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â
                      	    16: # +7â•‘                  DESTINATION OFFSET 31-16                     â•‘+6
                      	    17: #   â•Ÿâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â
                      	    18: # +5â•‘ P â”‚  DPL  â”‚ 0 â”‚ 1   1   0   0 â”‚ x   x   x â”‚  WORD COUNT 4-0   â•‘+4
                      	    19: #   â•Ÿâ”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â
                      	    20: # +3â•‘                 DESTINATION SELECTOR 15-2             â”‚ x   x â•‘+2
                      	    21: #   â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â
                      	    22: # +1â•‘                  DESTINATION OFFSET 15-0                      â•‘ 0
                      	    23: #   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â
                      	    24: #    15                                                            0
                      	    25: #
                      	    26: # FS:EBX pointer to the GDT
                      	    27: # EAX GDT selector
                      	    28: # SI  destination selector
                      	    29: # EDI destination offset
                      	    30: # DL word count
                      	    31: # DH DPL (as bit field, use ACC_DPL_* equs on dx)
                      	    32: #;
                      	    33: initCallGate:
04:00001CBC 25F8FF0000	    34: 	and $0xFFF8,%eax
04:00001CC1 01C3      	    35: 	add %eax,%ebx
04:00001CC3 6664893C1D	    36: 	movw %di,%fs:(,%ebx,1)   	# DESTINATION OFFSET 15-0
04:00001CC8 00000000
04:00001CCC 666489341D	    37: 	movw %si,%fs:2(,%ebx,1)		# DESTINATION SELECTOR 15-2
04:00001CD1 02000000
04:00001CD5 6681CA008C	    38: 	or $ACC_TYPE_GATE386_CALL | ACC_PRESENT,%dx
04:00001CDA 666489141D	    39: 	movw %dx,%fs:4(,%ebx,1) 	# ACC byte | WORD COUNT 4-0
04:00001CDF 04000000
04:00001CE3 C1EF10    	    40: 	shr $16,%edi
04:00001CE6 6664893C1D	    41: 	movw %di,%fs:6(,%ebx,1) 	# DESTINATION OFFSET 31-16
04:00001CEB 06000000
04:00001CEF C3        	    42: 	ret
                      	    43: 

Source: "t386.asm"
                      	   464: 
                      	   465: initLDT:
                      	   466: 	defLDTDesc D_SEG_PROT16,   TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.set D_SEG_PROT16,LDTSelDesc
04:00001CF0 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001CF5 0000
04:00001CF7 B804000000	     3M 	mov $D_SEG_PROT16,%eax
04:00001CFC BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001D01 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001D06 66BA0092  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     7M 	initDescriptor
04:00001D0A 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001D0F 01C3      	     2M 	add %eax,%ebx
04:00001D11 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001D14 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001D18 C1EE10    	     5M 	shr $16,%esi
04:00001D1B 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001D1E 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001D21 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001D24 C1EF10    	     9M 	shr $16,%edi
04:00001D27 6689F9    	    10M 	mov %di,%cx
04:00001D2A 80E10F    	    11M 	and $0x0f,%cl
04:00001D2D 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001D30 80E2F0    	    13M 	and $0xf0,%dl
04:00001D33 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001D36 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   467: 	defLDTDesc D_SEG_PROT32,   TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT,EXT_32BIT
                      	     1M 	.set D_SEG_PROT32,LDTSelDesc
04:00001D39 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001D3E 0000
04:00001D40 B80C000000	     3M 	mov $D_SEG_PROT32,%eax
04:00001D45 BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001D4A BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001D4F 66BA4092  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|EXT_32BIT,%dx
                      	     7M 	initDescriptor
04:00001D53 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001D58 01C3      	     2M 	add %eax,%ebx
04:00001D5A 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001D5D 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001D61 C1EE10    	     5M 	shr $16,%esi
04:00001D64 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001D67 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001D6A 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001D6D C1EF10    	     9M 	shr $16,%edi
04:00001D70 6689F9    	    10M 	mov %di,%cx
04:00001D73 80E10F    	    11M 	and $0x0f,%cl
04:00001D76 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001D79 80E2F0    	    13M 	and $0xf0,%dl
04:00001D7C 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001D7F 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   468: 	defLDTDesc DU_SEG_PROT,    TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3
                      	     1M 	.set DU_SEG_PROT,LDTSelDesc
04:00001D82 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001D87 0000
04:00001D89 B814000000	     3M 	mov $DU_SEG_PROT,%eax
04:00001D8E BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001D93 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001D98 66BA00F2  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3|0,%dx
                      	     7M 	initDescriptor
04:00001D9C 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001DA1 01C3      	     2M 	add %eax,%ebx
04:00001DA3 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001DA6 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001DAA C1EE10    	     5M 	shr $16,%esi
04:00001DAD 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001DB0 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001DB3 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001DB6 C1EF10    	     9M 	shr $16,%edi
04:00001DB9 6689F9    	    10M 	mov %di,%cx
04:00001DBC 80E10F    	    11M 	and $0x0f,%cl
04:00001DBF 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001DC2 80E2F0    	    13M 	and $0xf0,%dl
04:00001DC5 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001DC8 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   469: 	defLDTDesc D1_SEG_PROT,    TEST_BASE1,0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.set D1_SEG_PROT,LDTSelDesc
04:00001DCB 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001DD0 0000
04:00001DD2 B81C000000	     3M 	mov $D1_SEG_PROT,%eax
04:00001DD7 BE0040FCFF	     4M 	mov $TEST_BASE1,%esi
04:00001DDC BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001DE1 66BA0092  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     7M 	initDescriptor
04:00001DE5 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001DEA 01C3      	     2M 	add %eax,%ebx
04:00001DEC 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001DEF 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001DF3 C1EE10    	     5M 	shr $16,%esi
04:00001DF6 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001DF9 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001DFC 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001DFF C1EF10    	     9M 	shr $16,%edi
04:00001E02 6689F9    	    10M 	mov %di,%cx
04:00001E05 80E10F    	    11M 	and $0x0f,%cl
04:00001E08 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001E0B 80E2F0    	    13M 	and $0xf0,%dl
04:00001E0E 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001E11 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   470: 	defLDTDesc D2_SEG_PROT,    TEST_BASE2,0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT
                      	     1M 	.set D2_SEG_PROT,LDTSelDesc
04:00001E14 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001E19 0000
04:00001E1B B824000000	     3M 	mov $D2_SEG_PROT,%eax
04:00001E20 BE0060FCFF	     4M 	mov $TEST_BASE2,%esi
04:00001E25 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001E2A 66BA0092  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|0,%dx
                      	     7M 	initDescriptor
04:00001E2E 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001E33 01C3      	     2M 	add %eax,%ebx
04:00001E35 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001E38 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001E3C C1EE10    	     5M 	shr $16,%esi
04:00001E3F 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001E42 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001E45 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001E48 C1EF10    	     9M 	shr $16,%edi
04:00001E4B 6689F9    	    10M 	mov %di,%cx
04:00001E4E 80E10F    	    11M 	and $0x0f,%cl
04:00001E51 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001E54 80E2F0    	    13M 	and $0xf0,%dl
04:00001E57 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001E5A 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   471: 	defLDTDesc DC_SEG_PROT32,  TEST_BASE1,0x000fffff,ACC_TYPE_CODE_R|ACC_PRESENT,EXT_32BIT
                      	     1M 	.set DC_SEG_PROT32,LDTSelDesc
04:00001E5D 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001E62 0000
04:00001E64 B82C000000	     3M 	mov $DC_SEG_PROT32,%eax
04:00001E69 BE0040FCFF	     4M 	mov $TEST_BASE1,%esi
04:00001E6E BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001E73 66BA409A  	     6M 	mov $ACC_TYPE_CODE_R|ACC_PRESENT|EXT_32BIT,%dx
                      	     7M 	initDescriptor
04:00001E77 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001E7C 01C3      	     2M 	add %eax,%ebx
04:00001E7E 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001E81 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001E85 C1EE10    	     5M 	shr $16,%esi
04:00001E88 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001E8B 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001E8E 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001E91 C1EF10    	     9M 	shr $16,%edi
04:00001E94 6689F9    	    10M 	mov %di,%cx
04:00001E97 80E10F    	    11M 	and $0x0f,%cl
04:00001E9A 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001E9D 80E2F0    	    13M 	and $0xf0,%dl
04:00001EA0 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001EA3 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   472: 	defLDTDesc RO_SEG_PROT,    TEST_BASE, 0x000fffff,ACC_TYPE_DATA_R|ACC_PRESENT
                      	     1M 	.set RO_SEG_PROT,LDTSelDesc
04:00001EA6 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001EAB 0000
04:00001EAD B834000000	     3M 	mov $RO_SEG_PROT,%eax
04:00001EB2 BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001EB7 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001EBC 66BA0090  	     6M 	mov $ACC_TYPE_DATA_R|ACC_PRESENT|0,%dx
                      	     7M 	initDescriptor
04:00001EC0 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001EC5 01C3      	     2M 	add %eax,%ebx
04:00001EC7 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001ECA 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001ECE C1EE10    	     5M 	shr $16,%esi
04:00001ED1 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001ED4 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001ED7 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001EDA C1EF10    	     9M 	shr $16,%edi
04:00001EDD 6689F9    	    10M 	mov %di,%cx
04:00001EE0 80E10F    	    11M 	and $0x0f,%cl
04:00001EE3 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001EE6 80E2F0    	    13M 	and $0xf0,%dl
04:00001EE9 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001EEC 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   473: 	defLDTDesc ROU_SEG_PROT,   TEST_BASE, 0x000fffff,ACC_TYPE_DATA_R|ACC_PRESENT|ACC_DPL_3
                      	     1M 	.set ROU_SEG_PROT,LDTSelDesc
04:00001EEF 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001EF4 0000
04:00001EF6 B83C000000	     3M 	mov $ROU_SEG_PROT,%eax
04:00001EFB BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001F00 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001F05 66BA00F0  	     6M 	mov $ACC_TYPE_DATA_R|ACC_PRESENT|ACC_DPL_3|0,%dx
                      	     7M 	initDescriptor
04:00001F09 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001F0E 01C3      	     2M 	add %eax,%ebx
04:00001F10 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001F13 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001F17 C1EE10    	     5M 	shr $16,%esi
04:00001F1A 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001F1D 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001F20 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001F23 C1EF10    	     9M 	shr $16,%edi
04:00001F26 6689F9    	    10M 	mov %di,%cx
04:00001F29 80E10F    	    11M 	and $0x0f,%cl
04:00001F2C 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001F2F 80E2F0    	    13M 	and $0xf0,%dl
04:00001F32 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001F35 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   474: 	defLDTDesc DTEST_SEG_PROT, TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT,EXT_32BIT
                      	     1M 	.set DTEST_SEG_PROT,LDTSelDesc
04:00001F38 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001F3D 0000
04:00001F3F B844000000	     3M 	mov $DTEST_SEG_PROT,%eax
04:00001F44 BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001F49 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001F4E 66BA4092  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|EXT_32BIT,%dx
                      	     7M 	initDescriptor
04:00001F52 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001F57 01C3      	     2M 	add %eax,%ebx
04:00001F59 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001F5C 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001F60 C1EE10    	     5M 	shr $16,%esi
04:00001F63 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001F66 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001F69 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001F6C C1EF10    	     9M 	shr $16,%edi
04:00001F6F 6689F9    	    10M 	mov %di,%cx
04:00001F72 80E10F    	    11M 	and $0x0f,%cl
04:00001F75 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001F78 80E2F0    	    13M 	and $0xf0,%dl
04:00001F7B 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001F7E 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   475: 	defLDTDesc DPL1_SEG_PROT,  TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_1
                      	     1M 	.set DPL1_SEG_PROT,LDTSelDesc
04:00001F81 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001F86 0000
04:00001F88 B84C000000	     3M 	mov $DPL1_SEG_PROT,%eax
04:00001F8D BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001F92 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001F97 66BA00B2  	     6M 	mov $ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_1|0,%dx
                      	     7M 	initDescriptor
04:00001F9B 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001FA0 01C3      	     2M 	add %eax,%ebx
04:00001FA2 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001FA5 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001FA9 C1EE10    	     5M 	shr $16,%esi
04:00001FAC 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001FAF 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001FB2 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001FB5 C1EF10    	     9M 	shr $16,%edi
04:00001FB8 6689F9    	    10M 	mov %di,%cx
04:00001FBB 80E10F    	    11M 	and $0x0f,%cl
04:00001FBE 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00001FC1 80E2F0    	    13M 	and $0xf0,%dl
04:00001FC4 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00001FC7 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   476: 	defLDTDesc NP_SEG_PROT,    TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W
                      	     1M 	.set NP_SEG_PROT,LDTSelDesc
04:00001FCA 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00001FCF 0000
04:00001FD1 B854000000	     3M 	mov $NP_SEG_PROT,%eax
04:00001FD6 BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00001FDB BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00001FE0 66BA0012  	     6M 	mov $ACC_TYPE_DATA_W|0,%dx
                      	     7M 	initDescriptor
04:00001FE4 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00001FE9 01C3      	     2M 	add %eax,%ebx
04:00001FEB 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00001FEE 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:00001FF2 C1EE10    	     5M 	shr $16,%esi
04:00001FF5 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00001FF8 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00001FFB 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00001FFE C1EF10    	     9M 	shr $16,%edi
04:00002001 6689F9    	    10M 	mov %di,%cx
04:00002004 80E10F    	    11M 	and $0x0f,%cl
04:00002007 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:0000200A 80E2F0    	    13M 	and $0xf0,%dl
04:0000200D 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00002010 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   477: 	defLDTDesc SYS_SEG_PROT,   TEST_BASE, 0x000fffff,ACC_PRESENT
                      	     1M 	.set SYS_SEG_PROT,LDTSelDesc
04:00002013 2EC51DE31A	     2M 	lds %cs:ptrLDTprot,%ebx  # this macro is used in prot mode to set up prot mode env.
04:00002018 0000
04:0000201A B85C000000	     3M 	mov $SYS_SEG_PROT,%eax
04:0000201F BE0000FCFF	     4M 	mov $TEST_BASE,%esi
04:00002024 BFFFFF0F00	     5M 	mov $0x000fffff,%edi
04:00002029 66BA0080  	     6M 	mov $ACC_PRESENT|0,%dx
                      	     7M 	initDescriptor
04:0000202D 25F8FF0000	     1M 	and $0xFFF8,%eax
04:00002032 01C3      	     2M 	add %eax,%ebx
04:00002034 66893B    	     3M 	movw %di,(%ebx)						# LIMIT 15-0
04:00002037 66897302  	     4M 	movw %si,2(%ebx)					# BASE 15-0
04:0000203B C1EE10    	     5M 	shr $16,%esi
04:0000203E 6689F0    	     6M 	mov %si,%ax								# AX := BASE 31-16
04:00002041 884304    	     7M 	movb %al,4(%ebx)					# BASE 23-16
04:00002044 887305    	     8M 	movb %dh,5(%ebx)					# acc byte
04:00002047 C1EF10    	     9M 	shr $16,%edi
04:0000204A 6689F9    	    10M 	mov %di,%cx
04:0000204D 80E10F    	    11M 	and $0x0f,%cl
04:00002050 884B06    	    12M 	movb %cl,6(%ebx)					# LIMIT 19-16
04:00002053 80E2F0    	    13M 	and $0xf0,%dl
04:00002056 085306    	    14M 	orb %dl,6(%ebx)						# ext nybble
04:00002059 886307    	    15M 	movb %ah,7(%ebx)					# BASE 31-24
                      	     8M 	.set LDTSelDesc,LDTSelDesc+8
                      	   478: 
04:0000205C 66B84000  	   479: 	mov  $LDT_SEG_PROT,%ax
04:00002060 0F00D0    	   480: 	lldt %ax
04:00002063 66B86800  	   481: 	mov $TSS_PROT,%ax
04:00002067 0F00D8    	   482: 	ltr %ax
04:0000206A EB00      	   483: 	jmp protTests
                      	   484: 
                      	   485: #.include "tss_p.asm"
                      	   486: #.include "protected_rings_p.asm"
                      	   487: 
                      	   488: protTests:
                      	   489: 
                      	   490: .include "lea_m.asm"

Source: "lea_m.asm"
                      	     1: #
                      	     2: #   Execs LEA op with 16-bit addressing and compares the result with given value
                      	     3: #   %1 address to calculate
                      	     4: #   %2 value to compare
                      	     5: #   Uses: flags.
                      	     6: #
                      	     7: .macro testLEA16 arg1,arg2
                      	     8: 	push %ax
                      	     9: 	lea \arg1,%ax
                      	    10: 	cmp \arg2,%ax
                      	    11: 	jne error
                      	    12: 	pop %ax
                      	    13: .endm
                      	    14: 
                      	    15: #
                      	    16: #   Execs LEA op with 32-bit addressing and compares the result with given value
                      	    17: #   %1 address to calculate
                      	    18: #   %2 value to compare
                      	    19: #   Uses: flags.
                      	    20: #
                      	    21: .macro testLEA32 arg1,arg2
                      	    22: 	push %eax
                      	    23: 	lea \arg1,%eax
                      	    24: 	cmp \arg2,%eax
                      	    25: 	jne error
                      	    26: 	pop %eax
                      	    27: .endm
                      	    28: 

Source: "t386.asm"
                      	   491: #.include "lea_p.asm"
                      	   492: postD:
                      	   493: 
                      	   494: #-------------------------------------------------------------------------------
                      	   495: 	POST $0x0D
04:0000206C B00D      	     1M 	movb $0x0D,%al
04:0000206E 66BA9001  	     2M 	movw $POST_PORT,%dx
04:00002072 EE        	     3M 	out %al,%dx
                      	   496: #-------------------------------------------------------------------------------
                      	   497: #
                      	   498: #   16-bit addressing modes (LEA)
                      	   499: #
04:00002073 66B80100  	   500: 	mov $1,%ax
04:00002077 66BB0200  	   501: 	mov $2,%bx
04:0000207B 66B90400  	   502: 	mov $4,%cx
04:0000207F 66BA0800  	   503: 	mov $8,%dx
04:00002083 66BE1000  	   504: 	mov $0x10,%si
04:00002087 66BF2000  	   505: 	mov $0x20,%di
                      	   506: 	testLEA16 0x4000, $0x4000
04:0000208B 6650      	     1M 	push %ax
04:0000208D 668D050040	     2M 	lea 0x4000,%ax
04:00002092 0000
04:00002094 663D0040  	     3M 	cmp $0x4000,%ax
04:00002098 0F85110400	     4M 	jne error
04:0000209D 00
04:0000209E 6658      	     5M 	pop %ax
                      	   507: 	testLEA16 (%bx), $0x0002
04:000020A0 6650      	     1M 	push %ax
04:000020A2 67668D07  	     2M 	lea (%bx),%ax
04:000020A6 6683F802  	     3M 	cmp $0x0002,%ax
04:000020AA 0F85FF0300	     4M 	jne error
04:000020AF 00
04:000020B0 6658      	     5M 	pop %ax
                      	   508: 	testLEA16 (%si), $0x0010
04:000020B2 6650      	     1M 	push %ax
04:000020B4 67668D04  	     2M 	lea (%si),%ax
04:000020B8 6683F810  	     3M 	cmp $0x0010,%ax
04:000020BC 0F85ED0300	     4M 	jne error
04:000020C1 00
04:000020C2 6658      	     5M 	pop %ax
                      	   509: 	testLEA16 (%di), $0x0020
04:000020C4 6650      	     1M 	push %ax
04:000020C6 67668D05  	     2M 	lea (%di),%ax
04:000020CA 6683F820  	     3M 	cmp $0x0020,%ax
04:000020CE 0F85DB0300	     4M 	jne error
04:000020D3 00
04:000020D4 6658      	     5M 	pop %ax
                      	   510: 	testLEA16 0x40(%bx), $0x0042
04:000020D6 6650      	     1M 	push %ax
04:000020D8 67668D4740	     2M 	lea 0x40(%bx),%ax
04:000020DD 6683F842  	     3M 	cmp $0x0042,%ax
04:000020E1 0F85C80300	     4M 	jne error
04:000020E6 00
04:000020E7 6658      	     5M 	pop %ax
                      	   511: 	testLEA16 0x40(%si), $0x0050
04:000020E9 6650      	     1M 	push %ax
04:000020EB 67668D4440	     2M 	lea 0x40(%si),%ax
04:000020F0 6683F850  	     3M 	cmp $0x0050,%ax
04:000020F4 0F85B50300	     4M 	jne error
04:000020F9 00
04:000020FA 6658      	     5M 	pop %ax
                      	   512: 	testLEA16 0x40(%di), $0x0060
04:000020FC 6650      	     1M 	push %ax
04:000020FE 67668D4540	     2M 	lea 0x40(%di),%ax
04:00002103 6683F860  	     3M 	cmp $0x0060,%ax
04:00002107 0F85A20300	     4M 	jne error
04:0000210C 00
04:0000210D 6658      	     5M 	pop %ax
                      	   513: 	testLEA16 0x4000(%bx), $0x4002
04:0000210F 6650      	     1M 	push %ax
04:00002111 67668D8700	     2M 	lea 0x4000(%bx),%ax
04:00002116 400000
04:00002119 663D0240  	     3M 	cmp $0x4002,%ax
04:0000211D 0F858C0300	     4M 	jne error
04:00002122 00
04:00002123 6658      	     5M 	pop %ax
                      	   514: 	testLEA16 0x4000(%si), $0x4010
04:00002125 6650      	     1M 	push %ax
04:00002127 67668D8400	     2M 	lea 0x4000(%si),%ax
04:0000212C 400000
04:0000212F 663D1040  	     3M 	cmp $0x4010,%ax
04:00002133 0F85760300	     4M 	jne error
04:00002138 00
04:00002139 6658      	     5M 	pop %ax
                      	   515: 	testLEA16 (%bx,%si), $0x0012
04:0000213B 6650      	     1M 	push %ax
04:0000213D 67668D00  	     2M 	lea (%bx,%si),%ax
04:00002141 6683F812  	     3M 	cmp $0x0012,%ax
04:00002145 0F85640300	     4M 	jne error
04:0000214A 00
04:0000214B 6658      	     5M 	pop %ax
                      	   516: 	testLEA16 (%bx,%di), $0x0022
04:0000214D 6650      	     1M 	push %ax
04:0000214F 67668D01  	     2M 	lea (%bx,%di),%ax
04:00002153 6683F822  	     3M 	cmp $0x0022,%ax
04:00002157 0F85520300	     4M 	jne error
04:0000215C 00
04:0000215D 6658      	     5M 	pop %ax
                      	   517: 	testLEA16 0x40(%bx,%si), $0x0052
04:0000215F 6650      	     1M 	push %ax
04:00002161 67668D4040	     2M 	lea 0x40(%bx,%si),%ax
04:00002166 6683F852  	     3M 	cmp $0x0052,%ax
04:0000216A 0F853F0300	     4M 	jne error
04:0000216F 00
04:00002170 6658      	     5M 	pop %ax
                      	   518: 	testLEA16 0x40(%bx,%di), $0x0062
04:00002172 6650      	     1M 	push %ax
04:00002174 67668D4140	     2M 	lea 0x40(%bx,%di),%ax
04:00002179 6683F862  	     3M 	cmp $0x0062,%ax
04:0000217D 0F852C0300	     4M 	jne error
04:00002182 00
04:00002183 6658      	     5M 	pop %ax
                      	   519: 	testLEA16 0x4000(%bx,%si), $0x4012
04:00002185 6650      	     1M 	push %ax
04:00002187 67668D8000	     2M 	lea 0x4000(%bx,%si),%ax
04:0000218C 400000
04:0000218F 663D1240  	     3M 	cmp $0x4012,%ax
04:00002193 0F85160300	     4M 	jne error
04:00002198 00
04:00002199 6658      	     5M 	pop %ax
                      	   520: 	testLEA16 0x4000(%bx,%di), $0x4022
04:0000219B 6650      	     1M 	push %ax
04:0000219D 67668D8100	     2M 	lea 0x4000(%bx,%di),%ax
04:000021A2 400000
04:000021A5 663D2240  	     3M 	cmp $0x4022,%ax
04:000021A9 0F85000300	     4M 	jne error
04:000021AE 00
04:000021AF 6658      	     5M 	pop %ax
                      	   521: 
                      	   522: 
                      	   523: #-------------------------------------------------------------------------------
                      	   524: 	POST $0xE0
04:000021B1 B0E0      	     1M 	movb $0xE0,%al
04:000021B3 66BA9001  	     2M 	movw $POST_PORT,%dx
04:000021B7 EE        	     3M 	out %al,%dx
                      	   525: #-------------------------------------------------------------------------------
                      	   526: 
                      	   527: .shifts386FlagsTest:
                      	   528: 
                      	   529: 	# SHR al,cl - SHR ax,cl
                      	   530: 	# undefined flags:
                      	   531: 	#  CF when cl>7 (byte) or cl>15 (word):
                      	   532: 	#    if byte operand and cl=8 or cl=16 or cl=24 then CF=MSB(operand)
                      	   533: 	#    if word operand and cl=16 then CF=MSB(operand)
                      	   534: 	#  OF when cl>1: set according to result   *** rf386 calc's overflow cl>1
                      	   535: 	#  AF when cl>0: always 1
                      	   536: 	# shift count is modulo 32 so if cl=32 then result is equal to cl=0
                      	   537: 
                      	   538: 	testShiftBFlags shrb, $0x81, $1, $0, $(PS_CF|PS_AF|PS_OF)
04:000021B8 66B80000  	     1M 	mov $0,%ax
04:000021BC 6650      	     2M 	push %ax
04:000021BE 9D        	     3M 	popf
04:000021BF B4FF      	     4M 	mov $0xff,%ah
04:000021C1 B081      	     5M 	mov $0x81,%al
04:000021C3 B101      	     6M 	mov $1,%cl
04:000021C5 D2E8      	     7M 	shrb %cl,%al
04:000021C7 9C        	     8M 	pushf
04:000021C8 6658      	     9M 	pop %ax
04:000021CA 6625D508  	    10M 	and $PS_ARITH,%ax
04:000021CE 663D1108  	    11M 	cmp $(PS_CF|PS_AF|PS_OF),%ax
04:000021D2 0F85D70200	    12M 	jne error
04:000021D7 00
                      	   539: 	testShiftBFlags shrb, $0x82, $2, $0, $(PS_CF|PS_AF|PS_OF)
04:000021D8 66B80000  	     1M 	mov $0,%ax
04:000021DC 6650      	     2M 	push %ax
04:000021DE 9D        	     3M 	popf
04:000021DF B4FF      	     4M 	mov $0xff,%ah
04:000021E1 B082      	     5M 	mov $0x82,%al
04:000021E3 B102      	     6M 	mov $2,%cl
04:000021E5 D2E8      	     7M 	shrb %cl,%al
04:000021E7 9C        	     8M 	pushf
04:000021E8 6658      	     9M 	pop %ax
04:000021EA 6625D508  	    10M 	and $PS_ARITH,%ax
04:000021EE 663D1108  	    11M 	cmp $(PS_CF|PS_AF|PS_OF),%ax
04:000021F2 0F85B70200	    12M 	jne error
04:000021F7 00
                      	   540: 	testShiftBFlags shrb, $0x80, $8, $0, $(PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF)
04:000021F8 66B80000  	     1M 	mov $0,%ax
04:000021FC 6650      	     2M 	push %ax
04:000021FE 9D        	     3M 	popf
04:000021FF B4FF      	     4M 	mov $0xff,%ah
04:00002201 B080      	     5M 	mov $0x80,%al
04:00002203 B108      	     6M 	mov $8,%cl
04:00002205 D2E8      	     7M 	shrb %cl,%al
04:00002207 9C        	     8M 	pushf
04:00002208 6658      	     9M 	pop %ax
04:0000220A 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000220E 663D5508  	    11M 	cmp $(PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF),%ax
04:00002212 0F85970200	    12M 	jne error
04:00002217 00
                      	   541: 	testShiftBFlags shrb, $0x00,   $8,  $PS_CF, $(PS_PF|PS_ZF)
04:00002218 66B80100  	     1M 	mov $PS_CF,%ax
04:0000221C 6650      	     2M 	push %ax
04:0000221E 9D        	     3M 	popf
04:0000221F B4FF      	     4M 	mov $0xff,%ah
04:00002221 B000      	     5M 	mov $0x00,%al
04:00002223 B108      	     6M 	mov $8,%cl
04:00002225 D2E8      	     7M 	shrb %cl,%al
04:00002227 9C        	     8M 	pushf
04:00002228 6658      	     9M 	pop %ax
04:0000222A 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000222E 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:00002232 0F85770200	    12M 	jne error
04:00002237 00
                      	   542: 	testShiftBFlags shrb, $0x80,   $16, $0,     $(PS_PF|PS_ZF|PS_OF)
04:00002238 66B80000  	     1M 	mov $0,%ax
04:0000223C 6650      	     2M 	push %ax
04:0000223E 9D        	     3M 	popf
04:0000223F B4FF      	     4M 	mov $0xff,%ah
04:00002241 B080      	     5M 	mov $0x80,%al
04:00002243 B110      	     6M 	mov $16,%cl
04:00002245 D2E8      	     7M 	shrb %cl,%al
04:00002247 9C        	     8M 	pushf
04:00002248 6658      	     9M 	pop %ax
04:0000224A 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000224E 663D4408  	    11M 	cmp $(PS_PF|PS_ZF|PS_OF),%ax
04:00002252 0F85570200	    12M 	jne error
04:00002257 00
                      	   543: 	testShiftBFlags shrb, $0x00,   $16, $PS_CF, $(PS_PF|PS_ZF)
04:00002258 66B80100  	     1M 	mov $PS_CF,%ax
04:0000225C 6650      	     2M 	push %ax
04:0000225E 9D        	     3M 	popf
04:0000225F B4FF      	     4M 	mov $0xff,%ah
04:00002261 B000      	     5M 	mov $0x00,%al
04:00002263 B110      	     6M 	mov $16,%cl
04:00002265 D2E8      	     7M 	shrb %cl,%al
04:00002267 9C        	     8M 	pushf
04:00002268 6658      	     9M 	pop %ax
04:0000226A 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000226E 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:00002272 0F85370200	    12M 	jne error
04:00002277 00
                      	   544: 	testShiftBFlags shrb, $0x80,   $24, $0,     $(PS_PF|PS_ZF|PS_OF)
04:00002278 66B80000  	     1M 	mov $0,%ax
04:0000227C 6650      	     2M 	push %ax
04:0000227E 9D        	     3M 	popf
04:0000227F B4FF      	     4M 	mov $0xff,%ah
04:00002281 B080      	     5M 	mov $0x80,%al
04:00002283 B118      	     6M 	mov $24,%cl
04:00002285 D2E8      	     7M 	shrb %cl,%al
04:00002287 9C        	     8M 	pushf
04:00002288 6658      	     9M 	pop %ax
04:0000228A 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000228E 663D4408  	    11M 	cmp $(PS_PF|PS_ZF|PS_OF),%ax
04:00002292 0F85170200	    12M 	jne error
04:00002297 00
                      	   545: 	testShiftBFlags shrb, $0x00,   $24, $PS_CF, $(PS_PF|PS_ZF)
04:00002298 66B80100  	     1M 	mov $PS_CF,%ax
04:0000229C 6650      	     2M 	push %ax
04:0000229E 9D        	     3M 	popf
04:0000229F B4FF      	     4M 	mov $0xff,%ah
04:000022A1 B000      	     5M 	mov $0x00,%al
04:000022A3 B118      	     6M 	mov $24,%cl
04:000022A5 D2E8      	     7M 	shrb %cl,%al
04:000022A7 9C        	     8M 	pushf
04:000022A8 6658      	     9M 	pop %ax
04:000022AA 6625D508  	    10M 	and $PS_ARITH,%ax
04:000022AE 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:000022B2 0F85F70100	    12M 	jne error
04:000022B7 00
                      	   546: 	testShiftBFlags shrb, $0x80,   $32, $0,     $PS_SF
04:000022B8 66B80000  	     1M 	mov $0,%ax
04:000022BC 6650      	     2M 	push %ax
04:000022BE 9D        	     3M 	popf
04:000022BF B4FF      	     4M 	mov $0xff,%ah
04:000022C1 B080      	     5M 	mov $0x80,%al
04:000022C3 B120      	     6M 	mov $32,%cl
04:000022C5 D2E8      	     7M 	shrb %cl,%al
04:000022C7 9C        	     8M 	pushf
04:000022C8 6658      	     9M 	pop %ax
04:000022CA 6625D508  	    10M 	and $PS_ARITH,%ax
04:000022CE 663D8000  	    11M 	cmp $PS_SF,%ax
04:000022D2 0F85D70100	    12M 	jne error
04:000022D7 00
                      	   547: 	testShiftWFlags shrw, $0x8000, $16, $0,     $(PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF)
04:000022D8 66B80000  	     1M 	mov $0,%ax
04:000022DC 6650      	     2M 	push %ax
04:000022DE 9D        	     3M 	popf
04:000022DF 66B80080  	     4M 	mov $0x8000,%ax
04:000022E3 B110      	     5M 	mov $16,%cl
04:000022E5 66D3E8    	     6M 	shrw %cl,%ax
04:000022E8 9C        	     7M 	pushf
04:000022E9 6658      	     8M 	pop %ax
04:000022EB 6625D508  	     9M 	and $PS_ARITH,%ax
04:000022EF 663D5508  	    10M 	cmp $(PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF),%ax
04:000022F3 0F85B60100	    11M 	jne error
04:000022F8 00
                      	   548: 	testShiftWFlags shrw, $0x0000, $16, $PS_CF, $(PS_PF|PS_ZF)
04:000022F9 66B80100  	     1M 	mov $PS_CF,%ax
04:000022FD 6650      	     2M 	push %ax
04:000022FF 9D        	     3M 	popf
04:00002300 66B80000  	     4M 	mov $0x0000,%ax
04:00002304 B110      	     5M 	mov $16,%cl
04:00002306 66D3E8    	     6M 	shrw %cl,%ax
04:00002309 9C        	     7M 	pushf
04:0000230A 6658      	     8M 	pop %ax
04:0000230C 6625D508  	     9M 	and $PS_ARITH,%ax
04:00002310 6683F844  	    10M 	cmp $(PS_PF|PS_ZF),%ax
04:00002314 0F85950100	    11M 	jne error
04:00002319 00
                      	   549: 	testShiftWFlags shrw, $0x8000, $32, $0,     $PS_SF|PS_PF
04:0000231A 66B80000  	     1M 	mov $0,%ax
04:0000231E 6650      	     2M 	push %ax
04:00002320 9D        	     3M 	popf
04:00002321 66B80080  	     4M 	mov $0x8000,%ax
04:00002325 B120      	     5M 	mov $32,%cl
04:00002327 66D3E8    	     6M 	shrw %cl,%ax
04:0000232A 9C        	     7M 	pushf
04:0000232B 6658      	     8M 	pop %ax
04:0000232D 6625D508  	     9M 	and $PS_ARITH,%ax
04:00002331 663D8400  	    10M 	cmp $PS_SF|PS_PF,%ax
04:00002335 0F85740100	    11M 	jne error
04:0000233A 00
                      	   550: 
                      	   551: 	# SHL al,cl - SHL ax,cl
                      	   552: 	# undefined flags:
                      	   553: 	#  CF when cl>7 (byte) or cl>15 (word):
                      	   554: 	#    if byte operand and cl=8 or cl=16 or cl=24 then CF=LSB(operand)
                      	   555: 	#    if word operand and cl=16 then CF=LSB(operand)
                      	   556: 	#  OF when cl>1: set according to result
                      	   557: 	#  AF when cl>0: always 1
                      	   558: 	# shift count is modulo 32 so if cl=32 then result is equal to cl=0
                      	   559: 
                      	   560: 	testShiftBFlags shlb, $0x81, $1,  $0,     $(PS_CF|PS_OF)
04:0000233B 66B80000  	     1M 	mov $0,%ax
04:0000233F 6650      	     2M 	push %ax
04:00002341 9D        	     3M 	popf
04:00002342 B4FF      	     4M 	mov $0xff,%ah
04:00002344 B081      	     5M 	mov $0x81,%al
04:00002346 B101      	     6M 	mov $1,%cl
04:00002348 D2E0      	     7M 	shlb %cl,%al
04:0000234A 9C        	     8M 	pushf
04:0000234B 6658      	     9M 	pop %ax
04:0000234D 6625D508  	    10M 	and $PS_ARITH,%ax
04:00002351 663D0108  	    11M 	cmp $(PS_CF|PS_OF),%ax
04:00002355 0F85540100	    12M 	jne error
04:0000235A 00
                      	   561: 	testShiftBFlags shlb, $0x41, $2,  $0,     $(PS_CF|PS_OF)
04:0000235B 66B80000  	     1M 	mov $0,%ax
04:0000235F 6650      	     2M 	push %ax
04:00002361 9D        	     3M 	popf
04:00002362 B4FF      	     4M 	mov $0xff,%ah
04:00002364 B041      	     5M 	mov $0x41,%al
04:00002366 B102      	     6M 	mov $2,%cl
04:00002368 D2E0      	     7M 	shlb %cl,%al
04:0000236A 9C        	     8M 	pushf
04:0000236B 6658      	     9M 	pop %ax
04:0000236D 6625D508  	    10M 	and $PS_ARITH,%ax
04:00002371 663D0108  	    11M 	cmp $(PS_CF|PS_OF),%ax
04:00002375 0F85340100	    12M 	jne error
04:0000237A 00
                      	   562: 	testShiftBFlags shlb, $0x01, $8,  $0,     $(PS_CF|PS_PF|PS_ZF|PS_OF)
04:0000237B 66B80000  	     1M 	mov $0,%ax
04:0000237F 6650      	     2M 	push %ax
04:00002381 9D        	     3M 	popf
04:00002382 B4FF      	     4M 	mov $0xff,%ah
04:00002384 B001      	     5M 	mov $0x01,%al
04:00002386 B108      	     6M 	mov $8,%cl
04:00002388 D2E0      	     7M 	shlb %cl,%al
04:0000238A 9C        	     8M 	pushf
04:0000238B 6658      	     9M 	pop %ax
04:0000238D 6625D508  	    10M 	and $PS_ARITH,%ax
04:00002391 663D4508  	    11M 	cmp $(PS_CF|PS_PF|PS_ZF|PS_OF),%ax
04:00002395 0F85140100	    12M 	jne error
04:0000239A 00
                      	   563: 	testShiftBFlags shlb, $0x00, $8,  $PS_CF, $(PS_PF|PS_ZF)
04:0000239B 66B80100  	     1M 	mov $PS_CF,%ax
04:0000239F 6650      	     2M 	push %ax
04:000023A1 9D        	     3M 	popf
04:000023A2 B4FF      	     4M 	mov $0xff,%ah
04:000023A4 B000      	     5M 	mov $0x00,%al
04:000023A6 B108      	     6M 	mov $8,%cl
04:000023A8 D2E0      	     7M 	shlb %cl,%al
04:000023AA 9C        	     8M 	pushf
04:000023AB 6658      	     9M 	pop %ax
04:000023AD 6625D508  	    10M 	and $PS_ARITH,%ax
04:000023B1 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:000023B5 0F85F40000	    12M 	jne error
04:000023BA 00
                      	   564: 	testShiftBFlags shlb, $0x01, $16, $0,     $(PS_CF|PS_PF|PS_ZF|PS_OF)
04:000023BB 66B80000  	     1M 	mov $0,%ax
04:000023BF 6650      	     2M 	push %ax
04:000023C1 9D        	     3M 	popf
04:000023C2 B4FF      	     4M 	mov $0xff,%ah
04:000023C4 B001      	     5M 	mov $0x01,%al
04:000023C6 B110      	     6M 	mov $16,%cl
04:000023C8 D2E0      	     7M 	shlb %cl,%al
04:000023CA 9C        	     8M 	pushf
04:000023CB 6658      	     9M 	pop %ax
04:000023CD 6625D508  	    10M 	and $PS_ARITH,%ax
04:000023D1 663D4508  	    11M 	cmp $(PS_CF|PS_PF|PS_ZF|PS_OF),%ax
04:000023D5 0F85D40000	    12M 	jne error
04:000023DA 00
                      	   565: 	testShiftBFlags shlb, $0x00, $16, $PS_CF, $(PS_PF|PS_ZF)
04:000023DB 66B80100  	     1M 	mov $PS_CF,%ax
04:000023DF 6650      	     2M 	push %ax
04:000023E1 9D        	     3M 	popf
04:000023E2 B4FF      	     4M 	mov $0xff,%ah
04:000023E4 B000      	     5M 	mov $0x00,%al
04:000023E6 B110      	     6M 	mov $16,%cl
04:000023E8 D2E0      	     7M 	shlb %cl,%al
04:000023EA 9C        	     8M 	pushf
04:000023EB 6658      	     9M 	pop %ax
04:000023ED 6625D508  	    10M 	and $PS_ARITH,%ax
04:000023F1 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:000023F5 0F85B40000	    12M 	jne error
04:000023FA 00
                      	   566: 	testShiftBFlags shlb, $0x01, $24, $0,     $(PS_CF|PS_PF|PS_ZF|PS_OF)
04:000023FB 66B80000  	     1M 	mov $0,%ax
04:000023FF 6650      	     2M 	push %ax
04:00002401 9D        	     3M 	popf
04:00002402 B4FF      	     4M 	mov $0xff,%ah
04:00002404 B001      	     5M 	mov $0x01,%al
04:00002406 B118      	     6M 	mov $24,%cl
04:00002408 D2E0      	     7M 	shlb %cl,%al
04:0000240A 9C        	     8M 	pushf
04:0000240B 6658      	     9M 	pop %ax
04:0000240D 6625D508  	    10M 	and $PS_ARITH,%ax
04:00002411 663D4508  	    11M 	cmp $(PS_CF|PS_PF|PS_ZF|PS_OF),%ax
04:00002415 0F85940000	    12M 	jne error
04:0000241A 00
                      	   567: 	testShiftBFlags shlb, $0x00, $24, $PS_CF, $(PS_PF|PS_ZF)
04:0000241B 66B80100  	     1M 	mov $PS_CF,%ax
04:0000241F 6650      	     2M 	push %ax
04:00002421 9D        	     3M 	popf
04:00002422 B4FF      	     4M 	mov $0xff,%ah
04:00002424 B000      	     5M 	mov $0x00,%al
04:00002426 B118      	     6M 	mov $24,%cl
04:00002428 D2E0      	     7M 	shlb %cl,%al
04:0000242A 9C        	     8M 	pushf
04:0000242B 6658      	     9M 	pop %ax
04:0000242D 6625D508  	    10M 	and $PS_ARITH,%ax
04:00002431 6683F844  	    11M 	cmp $(PS_PF|PS_ZF),%ax
04:00002435 7578      	    12M 	jne error
                      	   568: 	testShiftBFlags shlb, $0x01, $32, $0,     $0
04:00002437 66B80000  	     1M 	mov $0,%ax
04:0000243B 6650      	     2M 	push %ax
04:0000243D 9D        	     3M 	popf
04:0000243E B4FF      	     4M 	mov $0xff,%ah
04:00002440 B001      	     5M 	mov $0x01,%al
04:00002442 B120      	     6M 	mov $32,%cl
04:00002444 D2E0      	     7M 	shlb %cl,%al
04:00002446 9C        	     8M 	pushf
04:00002447 6658      	     9M 	pop %ax
04:00002449 6625D508  	    10M 	and $PS_ARITH,%ax
04:0000244D 6683F800  	    11M 	cmp $0,%ax
04:00002451 755C      	    12M 	jne error
                      	   569: 	testShiftWFlags shlw, $0x01, $16, $0,     $(PS_CF|PS_PF|PS_ZF|PS_OF)
04:00002453 66B80000  	     1M 	mov $0,%ax
04:00002457 6650      	     2M 	push %ax
04:00002459 9D        	     3M 	popf
04:0000245A 66B80100  	     4M 	mov $0x01,%ax
04:0000245E B110      	     5M 	mov $16,%cl
04:00002460 66D3E0    	     6M 	shlw %cl,%ax
04:00002463 9C        	     7M 	pushf
04:00002464 6658      	     8M 	pop %ax
04:00002466 6625D508  	     9M 	and $PS_ARITH,%ax
04:0000246A 663D4508  	    10M 	cmp $(PS_CF|PS_PF|PS_ZF|PS_OF),%ax
04:0000246E 753F      	    11M 	jne error
                      	   570: 	testShiftWFlags shlw, $0x00, $16, $PS_CF, $(PS_PF|PS_ZF)
04:00002470 66B80100  	     1M 	mov $PS_CF,%ax
04:00002474 6650      	     2M 	push %ax
04:00002476 9D        	     3M 	popf
04:00002477 66B80000  	     4M 	mov $0x00,%ax
04:0000247B B110      	     5M 	mov $16,%cl
04:0000247D 66D3E0    	     6M 	shlw %cl,%ax
04:00002480 9C        	     7M 	pushf
04:00002481 6658      	     8M 	pop %ax
04:00002483 6625D508  	     9M 	and $PS_ARITH,%ax
04:00002487 6683F844  	    10M 	cmp $(PS_PF|PS_ZF),%ax
04:0000248B 7522      	    11M 	jne error
                      	   571: 	testShiftWFlags shlw, $0x01, $32, $0,     $0
04:0000248D 66B80000  	     1M 	mov $0,%ax
04:00002491 6650      	     2M 	push %ax
04:00002493 9D        	     3M 	popf
04:00002494 66B80100  	     4M 	mov $0x01,%ax
04:00002498 B120      	     5M 	mov $32,%cl
04:0000249A 66D3E0    	     6M 	shlw %cl,%ax
04:0000249D 9C        	     7M 	pushf
04:0000249E 6658      	     8M 	pop %ax
04:000024A0 6625D508  	     9M 	and $PS_ARITH,%ax
04:000024A4 6683F800  	    10M 	cmp $0,%ax
04:000024A8 7505      	    11M 	jne error
                      	   572: 
04:000024AA E9FCFFFFFF	   573: 	jmp _bootrom
                      	   574: 
                      	   575: #	pushl $10
                      	   576: #	call _Fibonacci
                      	   577: 
                      	   578: #
                      	   579: # Default exception handler and error routine
                      	   580: #
                      	   581: DefaultExcHandler:
                      	   582: error:
                      	   583: # CLI and HLT are privileged instructions, don't use them in ring3
04:000024AF 668CC8    	   584: 	mov %cs,%ax
                      	   585: 
                      	   586: # when in real mode, the jnz will be decoded together with test as
                      	   587: # "test eax,0xfe750007" (66A9070075FE)
04:000024B2 66A90700  	   588: 	test $7,%ax     # 66 A9 07 00
04:000024B6 75FE      	   589: .ring3: jnz .ring3 # 75 FE
04:000024B8 FA        	   590: 	cli
04:000024B9 F4        	   591: 	hlt
04:000024BA EBF3      	   592: 	jmp error
                      	   593: 
                      	   594: 
                      	   595: .rept 16
                      	   596: 	nop
                      	   597: .endr
04:000024BC 90        	     1R 	nop
04:000024BD 90        	     1R 	nop
04:000024BE 90        	     1R 	nop
04:000024BF 90        	     1R 	nop
04:000024C0 90        	     1R 	nop
04:000024C1 90        	     1R 	nop
04:000024C2 90        	     1R 	nop
04:000024C3 90        	     1R 	nop
04:000024C4 90        	     1R 	nop
04:000024C5 90        	     1R 	nop
04:000024C6 90        	     1R 	nop
04:000024C7 90        	     1R 	nop
04:000024C8 90        	     1R 	nop
04:000024C9 90        	     1R 	nop
04:000024CA 90        	     1R 	nop
04:000024CB 90        	     1R 	nop
                      	   598: 	
                      	   599: #	.type	_start,@function
                      	   600: #	.size	_start,$-_start
                      	   601: 
                      	   602: #.include "Fibonacci.asm"
                      	   603: #.include "serial.asm"
                      	   604: #.include "xmodem.asm"
                      	   605: #.include "bootrom.asm"
                      	   606: 
                      	   607: .global _disable_int
                      	   608: .global _restore_int
                      	   609: .extern _start_data
                      	   610: .extern _start_rodata
                      	   611: .extern _start_bss
                      	   612: 


Symbols by name:
.ipt1                           04:00001C2E
.ring3                          04:000024B6
.shifts386FlagsTest             04:000021B8
ACC_DPL_0                        S:00000000
ACC_DPL_1                        S:00002000
ACC_DPL_3                        S:00006000
ACC_PRESENT                      S:00008000
ACC_TYPE_CODE_R                  S:00001A00
ACC_TYPE_CONFORMING              S:00000400
ACC_TYPE_DATA_R                  S:00001000
ACC_TYPE_DATA_W                  S:00001200
ACC_TYPE_GATE386_CALL            S:00000C00
ACC_TYPE_GATE386_INT             S:00000E00
ACC_TYPE_LDT                     S:00000200
ACC_TYPE_TSS                     S:00000900
CC_SEG_PROT32                    S:00000018
CR0_MSW_PE                       S:00000001
CR0_PG                           S:80000000
CU_SEG_PROT32                    S:00000010
C_SEG_PROT16                     S:00000000
C_SEG_PROT32                     S:00000008
C_SEG_REAL                       S:0000F000
D1_SEG_PROT                      S:0000001C
D1_SEG_REAL                      S:0FFFC400
D2_SEG_PROT                      S:00000024
D2_SEG_REAL                      S:0FFFC600
DC_SEG_PROT32                    S:0000002C
DPL1_SEG_PROT                    S:0000004C
DTEST_SEG_PROT                   S:00000044
DU_SEG_PROT                      S:00000014
D_SEG_PROT16                     S:00000004
D_SEG_PROT32                     S:0000000C
DefaultExcHandler               04:000024AF
ESP_R0_PROT                      S:0000FFFF
ESP_REAL                         S:00007FFC
EXT_32BIT                        S:00000040
EXT_NONE                         S:00000000
EX_UD                            S:00000006
FLAT_SEG_PROT                    S:00000078
GDTSelDesc                       S:00000088
GDTU_DSEG_PROT                   S:00000038
GDT_DSEG_PROT                    S:00000030
GDT_SEG_LIMIT                    S:000002FF
GDT_SEG_REAL                     S:00009050
IDTU_SEG_PROT                    S:00000028
IDT_SEG_PROT                     S:00000020
IDT_SEG_REAL                     S:00009000
LDTSelDesc                       S:00000064
LDT_DSEG_PROT                    S:00000048
LDT_SEG_PROT                     S:00000040
NP_SEG_PROT                      S:00000054
PAGE_DIR_ADDR                    S:00002000
PG_SEG_PROT                      S:00000050
POST_PORT                        S:00000190
PS_AF                            S:00000010
PS_ARITH                         S:000008D5
PS_CF                            S:00000001
PS_OF                            S:00000800
PS_PF                            S:00000004
PS_SF                            S:00000080
PS_ZF                            S:00000040
PTE_PRESENT                      S:00000001
PTE_USER                         S:00000010
PTE_WRITE                        S:00000004
RING0_GATE                       S:00000080
ROU_SEG_PROT                     S:0000003C
RO_SEG_PROT                      S:00000034
SU_SEG_PROT32                    S:00000060
SYS_SEG_PROT                     S:0000005C
S_SEG_PROT32                     S:00000058
S_SEG_REAL                       S:0000C000
TEST_BASE                        S:FFFC0000
TEST_BASE1                       S:FFFC4000
TEST_BASE2                       S:FFFC6000
TEST_CODE                        S:FFFF0000
TSS_DSEG_PROT                    S:00000070
TSS_PROT                         S:00000068
_Fibonacci                      external EXP
_bootrom                        external EXP
_disable_int                    external EXP
_restore_int                    external EXP
_start                          04:00000000
_start1                         04:0000005B
_start_bss                      external EXP
_start_data                     external EXP
_start_rodata                   external EXP
addrGDT                         04:00001B0D
addrProtIDT                     04:00001B07
aloop7                          04:00000076
b                                S:00000000
bytes                            S:00000100
continue25                      04:0000054D
continue28                      04:000005C7
d                                S:00000002
err110                          04:000000C7
err111                          04:00000209
err210                          04:0000013C
err211                          04:00000394
error                           04:000024AF
exit10                          04:0000014B
exit11                          04:000003A9
exit52                          04:0000134B
farfn1652                       04:000012F3
farfn3252                       04:00001314
header                          04:00000002
idt_addr                        03:00000000
initCallGate                    04:00001CBC
initDescriptorProt              04:00001C8C
initGDT                         04:00001517
initIDT                         04:00001B36
initIntGateProt                 04:00001C6F
initIntGateReal                 04:00001B13
initLDT                         04:00001CF0
initPaging                      04:00001C0A
items                            S:00000040
ja10                            04:000000EE
ja11                            04:00000242
jaok10                          04:000000FE
jaok11                          04:000002DD
jcok10                          04:000000C8
jcok11                          04:0000020A
jcxz10                          04:00000120
jcxz11                          04:00000311
jcxzok10                        04:00000147
jecxz10                         04:00000130
jecxze10                        04:0000013A
jecxzok10                       04:00000149
jl10                            04:00000117
jl11                            04:00000304
jle10                           04:0000011D
jle11                           04:0000030C
jleok10                         04:00000145
jleok11                         04:000003A5
jlok10                          04:00000143
jlok11                          04:000003A1
jna10                           04:000000BE
jna11                           04:0000017B
jnaok10                         04:000000D0
jnaok11                         04:0000021A
jnc10                           04:000000D2
jnc11                           04:0000021E
jncok10                         04:000000F6
jncok11                         04:000002CD
jnl10                           04:0000010D
jnl11                           04:000002F2
jnle10                          04:00000112
jnle11                          04:000002FB
jnleok10                        04:00000141
jnleok11                        04:0000039D
jnlok10                         04:0000013F
jnlok11                         04:00000399
jnp10                           04:000000E2
jnp11                           04:00000232
jnpok10                         04:000000FA
jnpok11                         04:000002D5
jns10                           04:000000E8
jns11                           04:0000023A
jnsok10                         04:000000FC
jnsok11                         04:000002D9
jnz10                           04:000000DC
jnz11                           04:0000022A
jnzok10                         04:000000F8
jnzok11                         04:000002D1
jo10                            04:00000100
jo11                            04:000002E1
jook10                          04:0000013D
jook11                          04:00000395
jp10                            04:000000AE
jp11                            04:00000163
jpok10                          04:000000CC
jpok11                          04:00000212
js10                            04:000000B6
js11                            04:0000016F
jsok10                          04:000000CE
jsok11                          04:00000216
jz10                            04:000000A6
jz11                            04:00000157
jzok10                          04:000000CA
jzok11                          04:0000020E
m161652                         04:00001326
m163252                         04:00001337
nearfn1651                      04:0000129F
nearfn3251                      04:000012BB
next110                         04:000000C5
next111                         04:00000186
next210                         04:000000F4
next211                         04:0000024A
o3252                           04:00001305
off_cmp                          S:0001FFFF
off_mask                         S:0000FFFF
off_value                        S:000100FF
postD                           04:0000206C
protTests                       04:0000206C
ptrGDTUprot                     04:00001ADD
ptrGDTprot                      04:00001AD7
ptrGDTreal                      04:0000150B
ptrIDTUprot                     04:00001AD1
ptrIDTprot                      04:00001ACB
ptrIDTreal                      04:00001511
ptrLDTprot                      04:00001AE3
ptrPDprot                       04:00001AE9
ptrPT0prot                      04:00001AEF
ptrPT1prot                      04:00001AF5
ptrSSprot                       04:00001AFB
ptrTSSprot                      04:00001B01
realmd_mask                      S:0000FFFF
rel1651                         04:00001295
rel3251                         04:000012B0
rm1651                          04:000012CD
rm3251                          04:000012D7
rodata_seg                       S:0FFFA000
romGDT                          04:00001505
romGDTEnd                       04:00001505
romGDTaddr                      04:00001505
start_rodata                     S:FFFA0000
switchToProtMode                04:00001C47
test25                          04:00000548
test28                          04:000005C0
toProt32                        04:00001C6A
val_mask                         S:FFFFFFFF
val_size                         S:00000004
value                            S:12345678
vector                           S:00000015
w                                S:00000001

Symbols by value:
FFFA0000 start_rodata
FFFC0000 TEST_BASE
FFFC4000 TEST_BASE1
FFFC6000 TEST_BASE2
FFFF0000 TEST_CODE
FFFFFFFF val_mask
00000000 b
00000000 EXT_NONE
00000000 idt_addr
00000000 ACC_DPL_0
00000000 C_SEG_PROT16
00000000 _start
00000001 w
00000001 PTE_PRESENT
00000001 PS_CF
00000001 CR0_MSW_PE
00000002 header
00000002 d
00000004 val_size
00000004 PS_PF
00000004 PTE_WRITE
00000004 D_SEG_PROT16
00000006 EX_UD
00000008 C_SEG_PROT32
0000000C D_SEG_PROT32
00000010 PS_AF
00000010 PTE_USER
00000010 CU_SEG_PROT32
00000014 DU_SEG_PROT
00000015 vector
00000018 CC_SEG_PROT32
0000001C D1_SEG_PROT
00000020 IDT_SEG_PROT
00000024 D2_SEG_PROT
00000028 IDTU_SEG_PROT
0000002C DC_SEG_PROT32
00000030 GDT_DSEG_PROT
00000034 RO_SEG_PROT
00000038 GDTU_DSEG_PROT
0000003C ROU_SEG_PROT
00000040 items
00000040 EXT_32BIT
00000040 LDT_SEG_PROT
00000040 PS_ZF
00000044 DTEST_SEG_PROT
00000048 LDT_DSEG_PROT
0000004C DPL1_SEG_PROT
00000050 PG_SEG_PROT
00000054 NP_SEG_PROT
00000058 S_SEG_PROT32
0000005B _start1
0000005C SYS_SEG_PROT
00000060 SU_SEG_PROT32
00000064 LDTSelDesc
00000068 TSS_PROT
00000070 TSS_DSEG_PROT
00000076 aloop7
00000078 FLAT_SEG_PROT
00000080 PS_SF
00000080 RING0_GATE
00000088 GDTSelDesc
000000A6 jz10
000000AE jp10
000000B6 js10
000000BE jna10
000000C5 next110
000000C7 err110
000000C8 jcok10
000000CA jzok10
000000CC jpok10
000000CE jsok10
000000D0 jnaok10
000000D2 jnc10
000000DC jnz10
000000E2 jnp10
000000E8 jns10
000000EE ja10
000000F4 next210
000000F6 jncok10
000000F8 jnzok10
000000FA jnpok10
000000FC jnsok10
000000FE jaok10
00000100 bytes
00000100 jo10
0000010D jnl10
00000112 jnle10
00000117 jl10
0000011D jle10
00000120 jcxz10
00000130 jecxz10
0000013A jecxze10
0000013C err210
0000013D jook10
0000013F jnlok10
00000141 jnleok10
00000143 jlok10
00000145 jleok10
00000147 jcxzok10
00000149 jecxzok10
0000014B exit10
00000157 jz11
00000163 jp11
0000016F js11
0000017B jna11
00000186 next111
00000190 POST_PORT
00000200 ACC_TYPE_LDT
00000209 err111
0000020A jcok11
0000020E jzok11
00000212 jpok11
00000216 jsok11
0000021A jnaok11
0000021E jnc11
0000022A jnz11
00000232 jnp11
0000023A jns11
00000242 ja11
0000024A next211
000002CD jncok11
000002D1 jnzok11
000002D5 jnpok11
000002D9 jnsok11
000002DD jaok11
000002E1 jo11
000002F2 jnl11
000002FB jnle11
000002FF GDT_SEG_LIMIT
00000304 jl11
0000030C jle11
00000311 jcxz11
00000394 err211
00000395 jook11
00000399 jnlok11
0000039D jnleok11
000003A1 jlok11
000003A5 jleok11
000003A9 exit11
00000400 ACC_TYPE_CONFORMING
00000548 test25
0000054D continue25
000005C0 test28
000005C7 continue28
00000800 PS_OF
000008D5 PS_ARITH
00000900 ACC_TYPE_TSS
00000C00 ACC_TYPE_GATE386_CALL
00000E00 ACC_TYPE_GATE386_INT
00001000 ACC_TYPE_DATA_R
00001200 ACC_TYPE_DATA_W
00001295 rel1651
0000129F nearfn1651
000012B0 rel3251
000012BB nearfn3251
000012CD rm1651
000012D7 rm3251
000012F3 farfn1652
00001305 o3252
00001314 farfn3252
00001326 m161652
00001337 m163252
0000134B exit52
00001505 romGDT
00001505 romGDTaddr
00001505 romGDTEnd
0000150B ptrGDTreal
00001511 ptrIDTreal
00001517 initGDT
00001A00 ACC_TYPE_CODE_R
00001ACB ptrIDTprot
00001AD1 ptrIDTUprot
00001AD7 ptrGDTprot
00001ADD ptrGDTUprot
00001AE3 ptrLDTprot
00001AE9 ptrPDprot
00001AEF ptrPT0prot
00001AF5 ptrPT1prot
00001AFB ptrSSprot
00001B01 ptrTSSprot
00001B07 addrProtIDT
00001B0D addrGDT
00001B13 initIntGateReal
00001B36 initIDT
00001C0A initPaging
00001C2E .ipt1
00001C47 switchToProtMode
00001C6A toProt32
00001C6F initIntGateProt
00001C8C initDescriptorProt
00001CBC initCallGate
00001CF0 initLDT
00002000 PAGE_DIR_ADDR
00002000 ACC_DPL_1
0000206C protTests
0000206C postD
000021B8 .shifts386FlagsTest
000024AF DefaultExcHandler
000024AF error
000024B6 .ring3
00006000 ACC_DPL_3
00007FFC ESP_REAL
00008000 ACC_PRESENT
00009000 IDT_SEG_REAL
00009050 GDT_SEG_REAL
0000C000 S_SEG_REAL
0000F000 C_SEG_REAL
0000FFFF realmd_mask
0000FFFF off_mask
0000FFFF ESP_R0_PROT
000100FF off_value
0001FFFF off_cmp
0FFFA000 rodata_seg
0FFFC400 D1_SEG_REAL
0FFFC600 D2_SEG_REAL
12345678 value
80000000 CR0_PG
